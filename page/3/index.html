<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>봄이네집 개발 블로그</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="봄이네집 개발 블로그">
<meta property="og:url" content="https://tech.wheejuni.com/page/3/index.html">
<meta property="og:site_name" content="봄이네집 개발 블로그">
<meta property="og:locale" content="ko">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="봄이네집 개발 블로그">
  
    <link rel="alternate" href="/atom.xml" title="봄이네집 개발 블로그" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+KR:100,300,400,700&amp;subset=korean" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <!--<div id="banner"></div>-->
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        <a href="/" id="main-nav-title" class="main-nav-link">봄이네집 개발 블로그</a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives/">Archives</a>
        
          <a class="main-nav-link" href="/about/">about</a>
        
      </nav>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-java-threadlocal" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/thread/">thread</a>►<a class="article-category-link" href="/categories/java/thread/concurrent/">concurrent</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/04/java-threadlocal/">ThreadLocal에 대한 짧은 정리</a>
    </h1>
  

        <a href="/2018/06/04/java-threadlocal/" class="article-date">
  <time datetime="2018-06-04T03:05:21.000Z" itemprop="datePublished">2018-06-04</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="Threadlocal에-대한-짧은-정리"><a href="#Threadlocal에-대한-짧은-정리" class="headerlink" title="Threadlocal에 대한 짧은 정리"></a>Threadlocal에 대한 짧은 정리</h3><p><em>(진짜 짧음 주의)</em></p>
<p><strong>Thread-safe하다?</strong></p>
<p>동시성 프로그래밍을 하다 보면 thread-safe, thread-unsafe에 대한 얘기를 하게 된다. </p>
<p>흔히 멤버 변수가 있는 객체를 thread-unsafe, 멤버 변수가 없는 객체를 thread-safe하다고도 하기도 하고, 혹은 synchronized나 volatile과 같은 키워드를 선언해서 thread-safe함을 보장해 주기도 한다. </p>
<p>같은 메모리 영역에 보관되어 있는 하나의 객체가 두 개 이상의 스레드에서 한번에 요청될 때, 한 쪽에서 읽기/쓰기 작업이 끝나지도 않았는데 다른 스레드가 객체의 정보를 요청하는 경우가 바로 <strong>thread-unsafe</strong> 한 상황이다. </p>
<p><strong>Java가 thread-safe를 보장하는 방법</strong></p>
<p>두 가지 방법이 있다. </p>
<ul>
<li><p>Synchronized: 가장 단순한 방법이다. 단순 명쾌하다. <strong>한 스레드의 작업이 끝날때까지 다른 스레드의 진입을 막아주는 것이다.</strong> 메소드, 혹은 변수에 선언할 수 있다. </p>
</li>
<li><p>Volatile: 생소한 개념일 수 있다. 조금 복잡하다. <strong>변수의 CPU Cache 복사를 금지하는 키워드다.</strong> 모든 작업은 RAM(혹은 어떤 형태이든지 주기억장치)에서 이뤄져야 한다. Java는 Heap 영역에 객체가 보관되기 때문에 이 경우 객체의 원자성이 보장된다. </p>
</li>
</ul>
<p><img src="http://thswave.github.io/assets/media/0308.jpg" alt="volatile"></p>
<p>이런 volatile의 작동 방식을 <strong>변수의 가시성을 보장한다</strong> 고도 말할 수 있다. </p>
<p>말 그대로다. CPU에 꽁쳐놓지 않고 모든 작업을 주기억장치에서 처리하니 어떤 스레드에서도 작업 내용을 투명하게 열람할 수 있는 것이다. </p>
<p><strong>ThreadLocal의 역할</strong></p>
<p>다만 inter-thread operability를 보장해주는 위의 두 키워드와는 다르게 만들어진 하나의 스레드 전역에서 공유되어야 할 정보가 있다. </p>
<p>이런 정보들을 thread-safe하게 구현하려면 복잡성이 수반되는데, 단순히 heap 영역에 보관해 공유하자니 thread-safe함이 무너지고, 그렇다고 매 stack마다 선언하고 해당 stack에서 쓰고 버릴 수도 없는 경우가 있기 때문이다. </p>
<p>ThreadLocal을 통해 이런 문제점을 해겷할 수 있다. </p>
<p><img src="http://cfs14.tistory.com/image/36/tistory/2009/02/13/15/44/499516b885314" alt="threadlocal"></p>
<p>말하자면 로컬 변수를 로컬처럼 쓰지 않게 도와주는 방법이라고 볼 수도 있겠다. </p>
<p><em>쓰임새?</em></p>
<p>하나의 스레드가 열린 상태에서 다양한 요청을 처리하고, 또 그에 따른 정보들을 공유해야 하는 상황에 대해 생각해보면 좋을 것 같다. </p>
<p>가장 쉽게 생각하자면 Spring Security의 <strong>SecurityContextHolder</strong>가 떠오른다. 처음 DispatcherServlet이 (혹은 그 앞의 filter가) 요청을 받았을 때 새로운 스레드가 생성되고, 이때 삽입된 인증 정보는 스레드 내에서 계속 공유되며 AOP 기반 인증 처리, 유저 정보 요청 등의 작동을 수행해야 하기 때문이다. </p>
<p><em>주의점?</em></p>
<p>Thread Pool을 통해 thread를 재사용할 경우 한번 쓴 ThreadLocal 객체는 .clear() 를 통해 비워줘야 한다. <strong>그러지 않으면 다음번 해당 스레드가 사용될 때 의도한 작동을 보장할 수 없다.</strong></p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/06/04/java-threadlocal/" data-id="ckkklasgh000sn49oc78ofgte" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/06/04/java-threadlocal/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-string" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/String/">String</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/21/java-string/">java.lang.String을 파 보았다</a>
    </h1>
  

        <a href="/2018/05/21/java-string/" class="article-date">
  <time datetime="2018-05-21T00:15:39.000Z" itemprop="datePublished">2018-05-21</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="자바의-문자열에-대해-제대로-공부해보자"><a href="#자바의-문자열에-대해-제대로-공부해보자" class="headerlink" title="자바의 문자열에 대해 제대로 공부해보자."></a>자바의 문자열에 대해 제대로 공부해보자.</h3><p>아마 어떤 언어를 배우든 그 시작은 “문자열 다루기” 일 것이다. “다룬다” 는 표현이 거창한가? 그렇지만 프로그래밍의 시작을 하려거든 어떤 식으로든 문자열과 만나는 경우가 많다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helloWorld</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello world!"</span>)</span><br></pre></td></tr></table></figure>
<p>쌍따옴표 안에 감싸진 것은 분명히 <strong>문자열이다.</strong> </p>
<p>자바는 뭐가 다를까? </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"hello world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>문자열 없이는 첫 발짝도 <strong>뗼 수 없다.</strong> 우리는 프로그래밍을 학습할 때 문자열을 가장 먼저 배운다. </p>
<p>어쩌면 문자열은 프로그래밍 언어에서 등장하는 유일한 “인간의 언어” 일지도 모르겠다는 생각이 든다. </p>
<hr>
<h4 id="오해"><a href="#오해" class="headerlink" title="오해"></a>오해</h4><p>문자열, 특히 Java에서의 문자열은 처음 배우는 개념인만큼 오개념이 생기기도 쉽고, 오개념이 잡혀도 오개념인 줄도 모르기때문에 나중에 바로잡기도 쉽지 않다. </p>
<p>뭐 완전 뉴비 시절에는 이런 실수도 종종 하긴 한다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = <span class="string">"안녕하세요"</span> == <span class="string">"안녕하세요"</span>;</span><br></pre></td></tr></table></figure>
<p>문자열을 ==으로 비교한다던지,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String hi = <span class="keyword">new</span> String(<span class="string">"Hellow"</span>);</span><br></pre></td></tr></table></figure>
<p>문자열에 생성자를 사용한다던지 하는 실수들 말이다. </p>
<p>이런 실수야 각자 해결하고 이 자리까지 왔을테니 굳이 언급하진 않겠다. 이번 글에서는 Java의 j 자 정도에 대한 이해가 생긴 프로그래머들조차도 흔히 갖는 오해, 그리고 흔히 하는 실수들에 대해 생각해보고자 한다. </p>
<hr>
<p><strong>java.lang.String은 어떻게 생성자 없이도 객체가 생성되나?</strong></p>
<p>궁금증 하나로 출발해보고 싶다. 우리는 Java에서 문자열은 <em>객체</em> 라고 배웠다. </p>
<p>그러나 생성자는 쓰지 말라고 한다. 어디서 이런 미스매치가 발생한 걸까? </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"hello"</span></span><br></pre></td></tr></table></figure>
<p>라는 짤막한 문자열 선언이, 컴파일러를 통해 아래와 같이 바뀐다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>&#125;).intern();</span><br></pre></td></tr></table></figure>
<p>.intern() 이 뭐냐면…. 일단 java.lang.String 에는 이렇게 돼 있다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>native 코드를 호출하는 것 같다. </p>
<p>이 짤막한 메소드의 기능은 문자열 풀링(pooling)을 담당하는 것이다. 즉, 우리가 문자열을 만들면 우리는 우리가 만든 객체를 그대로 사용하는 게 아닌, JVM 내부에 형성된 literal pool의 객체를 가져다 쓰게 된다. </p>
<p>처음 문자열이 선언됐을 때 .intern()이 호출되고, 이 메소드는 JVM의 문자열 풀에 해당 객체와 같은 내용의 문자열이 기 존재하는지를 질의한다. 이때 .equals()를 사용한다. </p>
<p>만약 이미 객체가 있다면 문자열 풀은 해당 객체를 리턴하고, <strong>없다면 만들어진 문자열 객체를 문자열 풀에 집어넣은 후, 그 객체로 가는 참조를 리턴해준다.</strong> 즉 어떠한 경우에도 우리가 문자열 객체의 생명주기를 직접 통제할 수는 없다. </p>
<p>그래서 이런 결과가 발생하는 것이다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"a"</span> == <span class="string">"a"</span>);</span><br><span class="line"><span class="comment">//true가 출력된다.</span></span><br></pre></td></tr></table></figure>
<p>그러나 모든 문자열 생성이 다 .intern()을 타는 것은 아니다. <strong>동적으로 문자열을 만들어주는 대부분의 메소드에서 만들어진 문자열은 new String() 을 쓴다.</strong> .intern() 안 탄다. </p>
<p>위와 같이 비교할 수 있다고 해서 .equals()를 안 써도 되는 게 아니란 얘기다. </p>
<p>말장난 아니냐고 하면 할 말은 없는데 어쨌든 <strong>객체가 풀링되고 있다는 사실이 중요한거다.</strong> 비슷한 원리를 따르는 JVM의 신비가 또 하나 있는데 바로 wrapper class interning이다. </p>
<p>아래 코드는 true일까, false일까? </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">1</span>;</span><br><span class="line">Integer i2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">i1 == i2;</span><br></pre></td></tr></table></figure>
<p>이거 true. <strong>객체는 equals로 비교하라며?</strong></p>
<p>자, 그럼 아래 코드는 true일까 false일까? </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer big1 = <span class="number">1024</span>;</span><br><span class="line">Integer big2 = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">big1 == big2</span><br></pre></td></tr></table></figure>
<p>이거 false다. <em>ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ</em></p>
<p><strong>왜 그럴까?</strong></p>
<p>퍼포먼스 튜닝 목적으로 Integer라는 wrapper class에 대해 -127 ~ 128 사이의 값을 <strong>미리 보관해서 별도의 배열에 보관하고 있기 때문이다.</strong></p>
<p>java.lang.Integer를 까보면 아래와 같은 구현이 나온다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[] = <span class="keyword">new</span> Integer[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">static</span> &#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">                 cache[i] = <span class="keyword">new</span> Integer(i - <span class="number">128</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>Integer 클래스가 최초로 사용됐을 때 무조건 한 번 돌게 돼 있다. </p>
<p>Integer도 문자열과 같은 원리의 interning을 수행하고 있는 모습이다. </p>
<hr>
<p><strong>문자열은 객체인데 어떻게 + 연산자가 먹나?</strong></p>
<p>String 객체 어딘가에 해당 연산을 수행해주는 메소드가 있고, 그 메소드를 호출하는 것으로 컴파일 타임에 바꿔치기되기 때문은 아닐까?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span> + <span class="string">"b"</span></span><br></pre></td></tr></table></figure>
<p>의 연산은, </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> StringBuilder(<span class="string">"s"</span>).append(<span class="string">"b"</span>).toString();</span><br></pre></td></tr></table></figure>
<p>으로 실행된다. </p>
<p><em>어, 그러면 StringBuilder 안 써도 되겠네요?</em></p>
<p><strong>아뇨.</strong> </p>
<p>개발자의 판단과 책임으로, 문자열 더하기 연산이 지나치게 많이 반복되는 경우 처음부터 깔끔하게 StringBuilder를 사용하는 것이 좋다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String hello = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    hello += <span class="string">"hi"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>당신은 조금 전 10개의 스트링 빌더 객체를 생성해, 고작 “hi” 두 글자 더하고 내다 버렸다. </p>
<p>동양 컴퓨터공학에서는 이렇게 쉽게 객체를 버리는 경우 컴퓨터의 균형이 깨진다고 본다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder hello = <span class="keyword">new</span> StringBuilder(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String hi: hiList) &#123;</span><br><span class="line">    hello.append(hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hello.toString();</span><br></pre></td></tr></table></figure>
<p>이게 훨씬 좋은 구현이다. </p>
<p><strong>추가</strong></p>
<p>정상혁(<a href="https://www.facebook.com/benelog" target="_blank" rel="noopener">Sanghyuck Jung</a>)님이 아래와 같은 내용을 보충해 주셨다. </p>
<p><em>Java 9에서의 String concat 최적화</em> - StringConcatFactory 로 연결된다. (JDK 9 이상에서만 존재)</p>
<p><a href="http://openjdk.java.net/jeps/280" target="_blank" rel="noopener">http://openjdk.java.net/jeps/280</a></p>
<p><strong>.concat()이란 것도 있다면서요?</strong></p>
<p>있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[count + otherLen];</span><br><span class="line">    getChars(<span class="number">0</span>, count, buf, <span class="number">0</span>);</span><br><span class="line">    str.getChars(<span class="number">0</span>, otherLen, buf, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(<span class="number">0</span>, count + otherLen, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이렇게 생겼다. 그러나 <strong>일부러 이걸 쓸 일은 없을 것이다.</strong></p>
<p>보면 알겠지만 합칠 문자열을 받고, 그 문자열의 길이를 파악한 후, 그 문자열 길이 + 원 문자열 길이 만큼의 배열을 선언하고, 거기다가 원래 문자열의 CharArray를 덮고, 거기다가 합칠 문자열으 내용을 덮고, 그걸 또 새로운 String 객체의 생성자 파라메터로 넘겨서 객체를 만들어서 돌려주는 것이다. </p>
<p>이렇게 만들어지는 객체는 오버헤드를 엄청나게 유발할 뿐만 아니라 앞서 설명한 interning도 안 되어있는 것이다. </p>
<p>위의 내용 중에 오타가 있는 건 나도 알지만 그냥 쓰다보니 빡쳐서 바로잡지 않은 것이다. </p>
<p><strong>쓰지 마세요.</strong></p>
<hr>
<p><em>StringBuilder도 있고, StringBuffer도 있잖아요?</em></p>
<p>맞다. <strong>두 클래스의 차이에 대해 인지한 후 정확한 상황판단 하에 사용해라.</strong></p>
<p>단순 취향 차이가 아닌 실제 퍼포먼스에서의 차이가 상당 부분 발생한다. </p>
<p>코드를 보자. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span>  <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>,<span class="title">CharSequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">AbstractStringBuilder() &#123;&#125;</span><br><span class="line"></span><br><span class="line">AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line"></span><br><span class="line">          value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>StringBuilder의 super class인 AbstractStringBuilder인데 char[] 로 문자열에 대한 관리를 하고 있음을 알 수 있다. </p>
<p>그럼 StringBuffer는? AbstractStringBuilder를 extend하는 것은 같지만….</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">char</span>[] toStringCache;</span><br></pre></td></tr></table></figure>
<p>문제의 코드다. char[] 를 transient로 관리하고 있는 모습이다. </p>
<p>뿐만 아니다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">char</span> More ...charAt(<span class="keyword">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= count))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">    <span class="keyword">return</span> value[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer More ...append(CharSequence s) &#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>모든 메소드에 synchronized 예약어가 달려있다. 느려질 수밖에 없는 구조다. </p>
<p><a href="https://stackoverflow.com/questions/1671089/why-are-synchronize-expensive-in-java" target="_blank" rel="noopener">synchronized가 왜 느릴까요?</a></p>
<p>JavaDoc에서 충분히 밝히고 있는 것처럼 StringBuffer는 thread-safe함이 요구되는 상황에서만 <strong>제한적으로</strong> 사용하는 것이 맞다. 남발할 경우 실행 속도가 느려질 수밖에 없을 것이다. </p>
<p>개인적인 실험을 해본 적이 있었는데 StringBuilder와 StringBuffer의 .append()를 1억번 정도 콜한 경우 대략 3초 내외의 퍼포먼스 차이가 났던 것으로 기억한다. </p>
<p>3초면 3000ms. 꽤 큰 차이다.</p>
<hr>
<h4 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h4><p>사실 우리 모두가 프로그래밍 좀 하다보면 문자열에 대한 이해가 출중할 거라 자부하지만 의외로 오개념을 갖고있을 수도 있다. </p>
<p>나도 이번 포스팅을 준비하며 찾아본 자료들에서 신선한 충격을 받은 경험이 꽤 있었다.</p>
<p>어쨌든, 기초가 참 중요한 것 같다. 익숙한 것부터 바로, 잘 알자!</p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/05/21/java-string/" data-id="ckkklasje004en49o1kkczutj" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/05/21/java-string/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-naver-hackday" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/naver/">naver</a>►<a class="article-category-link" href="/categories/naver/hackathon/">hackathon</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/19/naver-hackday/">2018 네이버 CAMPUS HACKDAY 참가기</a>
    </h1>
  

        <a href="/2018/05/19/naver-hackday/" class="article-date">
  <time datetime="2018-05-19T00:21:10.000Z" itemprop="datePublished">2018-05-19</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="2018-네이버-캠퍼스-핵데이-참가-후기"><a href="#2018-네이버-캠퍼스-핵데이-참가-후기" class="headerlink" title="2018 네이버 캠퍼스 핵데이 참가 후기"></a>2018 네이버 캠퍼스 핵데이 참가 후기</h3><p>네이버가 주최하는 대학생을 위한 해커톤 행사인 <a href="https://github.com/NAVER-CAMPUS-HACKDAY/common" target="_blank" rel="noopener">2018 네이버 캠퍼스 핵데이</a>에 다녀왔다. 매년 여름 겨울 두 차례 실시되는 이 행사는 소프트웨어 개발에 관심이 있고 기초 실력(?) 을 가진 대학생이라면 누구나 참가할 수 있는 행사로 이번이 다섯번째다. 우수 참가자에게는 <strong>기술면접 후 네이버 인턴 채용 기회</strong> 가 부여된다.</p>
<p>출발전 간단한 오리엔테이션이 이뤄졌는데 <em>매 행사마다 새로운 최고 경쟁률 기록을 갈아치우고 있다</em> 고 한다. 뭐…. 나중에 느낀 거지만 이정도의 <strong>고품격 해커톤을 운영</strong>한다면 당연한 결과라고 생각된다. </p>
<hr>
<h4 id="오리엔테이션과-출발-전-간단-미팅"><a href="#오리엔테이션과-출발-전-간단-미팅" class="headerlink" title="오리엔테이션과 출발 전 간단 미팅"></a>오리엔테이션과 출발 전 간단 미팅</h4><p><img src="https://s3.ap-northeast-2.amazonaws.com/techblog-static-imgs/KakaoTalk_Photo_2018-05-19-09-30-10.jpeg" alt="오리엔테이션"></p>
<p>오리엔테이션은 이제 <a href="http://nter.naver.com/naverletter/textyle/135326" target="_blank" rel="noopener">우리집 안방처럼</a> <a href="http://startupall.kr/blog/2017/09/22/2017-%EC%A4%91%EA%B5%AD%EC%9D%98-%ED%95%9C%EA%B5%AD%EC%9D%B8%EC%9D%84-%EA%B0%9C%EC%B5%9C%ED%95%A9%EB%8B%88%EB%8B%A4/" target="_blank" rel="noopener">편안하고</a> <a href="http://startupall.kr/blog/2018/03/09/%EC%8B%A4%EB%A6%AC%EC%BD%98%EB%B0%B8%EB%A6%AC%EC%9D%98-%ED%95%9C%EA%B5%AD%EC%9D%B8-2018/" target="_blank" rel="noopener">아늑한</a> 네이버 그린팩토리 커넥트홀에서 진행됐다. </p>
<p>단체로 이동할 때 통상적인 주의사항과 <strong>술 마시면 퇴소</strong> 라는 규정을 알려줬다. 가보면 알겠지만 술 사갖고 올 만한 슈퍼도 없긴 하다. 오리엔테이션 내용이 별로 없었던 이유는 이 행사 자체가 팀 별로 멘토의 주도 하에 고도의 자유도를 부여하는 행사로서 이미 멘토들의 판단에 따른 주의사항이 각종 연락 채널(Slack, 익명 카톡방(…) 등등…) 으로 전파가 되어 있는 상황이었다. </p>
<p>다른 팀의 이야기를 들어보니 모이기 전 <strong>이미 몇 번의 사전 준비 모임</strong>과 멘토와의 식사, 멘티들끼리의 식사 등을 가진 팀이 있었고, 프로젝트에 대해서는 (기본 요구사항 외에) 한 줄의 안내도 받지 못한 팀도 몇 군데 있었다. 팀의 성향 그리고 멘토의 성향에 따라 차이를 보인 부분으로, 사실 같은 핵데이 행사에 참여했다고 하더라도 본인이 참가한 소주제에 따라 경험이 많이 달라졌을 것 같다. </p>
<p>우리 팀은 사전 준비모임을 갖지 않았고(그 이유도 후술한다) 출발 직전 멘토님과 점심 식사를 가졌다. 멘토님은 네이버 쇼핑의 데이터정제파트에 근무하고 계시고 굳이 백 / 프론트를 나누자면 백엔드 개발자에 더 가까운 분이었다. </p>
<p>식사 자리는 극도의 긴장감 속에(…) 식은땀이 줄줄 흘렀다. 사실 식사 뿐만 아니라 멘토님 앞에서 기술적인 얘기 하려고 하면 식은땀이 막 났다. <em>되도 않는 헛소리 하고 있는건 아닐까 하고…</em></p>
<p>식사 자리에서의 멘토님의 말씀 중 인상적인 부분을, 공유할 수 있는 범위 내에서 공유해 보겠다. </p>
<ul>
<li>회사에서 <strong>채용을 위한 행사</strong> 로 비치지 않기를 원한다. 너무 과열되지 않기를 바라는 것 같다. </li>
<li>지나치게 구현 완성도에 집중하지 않았으면 좋겠고 편안한 분위기 속에서 즐코딩(멘토님이 즐겨쓰시는 표현)하셨으면 좋겠다. <strong>과정이 중요하다.</strong> </li>
<li>우수 참가자에게는 면접 후 인턴 채용 기회가 부여되는데 <strong>면접이 어렵다.</strong></li>
<li>(참가자 선발 기준은?) <strong>GitHub 보고 뽑았다.</strong> 전공 학점 등등 전혀 안 봤다. <ul>
<li>GitHub를 볼 때 두 가지를 봤다. <strong>커밋 빈도</strong> 와 <strong>커밋 메시지</strong> 를 봤다. 커밋을 얼마나 자주 많이 했는지를 봤고 메시지를 극도로 잘 쓰진 않아도 의미있게 작성하는지를 봤다. 1번 커밋, 2번 커밋, ㅋㅋㅋ 이런 식으로 남긴 것은 좋게 평가하지 않았다. </li>
</ul>
</li>
<li>팀별로 약간명을 후보자로 제출하면 인사팀에서 최종 스크리닝하는 절차를 거쳐 <strong>세 명을 추렸다.</strong></li>
</ul>
<p><em>(팀원 선발에 관한 부분은 멘토님과 팀의 개인 성향으로 획일적인 게 아니다. 실제로 최근 한달간 커밋 몇 건 없이 핵데이 오신 분들도 있다)</em></p>
<p>특히 내 경우 이번 여름 졸업이 아닌 이번 가을학기를 이수해야 하는 입장이라 참가 전에도 <em>헛수고하는 건 아닌가</em> 하고 걱정을 좀 했는데 나같은 경우 1월 입사가 가능하게끔 입사 시기도 배려해 준다고 하셨다. </p>
<p>이런 김칫국 끓이는 질문을 먼저 드릴 수 없었는데 <em>다들 몇학기 남았어요? 이번에 졸업이에요?</em> 하고 먼저 따스히 물어봐주셔서 답답함을 해소하고 새우튀김에 집중할 수 있었다. </p>
<hr>
<h4 id="입소-코딩-식사-코딩-야식-코딩-식사"><a href="#입소-코딩-식사-코딩-야식-코딩-식사" class="headerlink" title="입소, 코딩, 식사 , 코딩, 야식, 코딩, 식사"></a>입소, 코딩, 식사 , 코딩, 야식, 코딩, 식사</h4><p><img src="https://s3.ap-northeast-2.amazonaws.com/techblog-static-imgs/KakaoTalk_Photo_2018-05-19-10-14-42.jpeg" alt="중앙고속도로"></p>
<p>분당에서 춘천 가는 길이 참 멀게 느껴졌다. 마석 쯤 왔겠거니 하고 창밖을 보니 미사리라서 소름이 좀 돋았다. </p>
<p>어릴때부터 수도없이 달린 길인데 엄청 새롭게 느껴졌다. </p>
<p><img src="https://s3.ap-northeast-2.amazonaws.com/techblog-static-imgs/40226631-246fe304-5ac7-11e8-89f0-1742d9b4af6c.JPG" alt="커넥트원"></p>
<p>네이버 커넥트원 내부 시설은 <strong>사진 촬영을 엄금</strong> 했다. 외부 풍경사진 정도, 건물 내부시설이 전혀 비치지 않는 얼굴 사진과 프로젝트 진행 사진 정도만 허용이 됐고 이외에는 전혀 사진 촬영을 할 수 없었다. 남의 건물에 왔으면 하지 말라는 것은 무조건 하지 않는 게 좋으므로 내부시설 사진은 찍지 않았다. </p>
<p><strong>이후 일정</strong></p>
<p>숙소에 짐을 풀고 작업공간으로 내려왔다. <strong>코딩파티가 시작되었다.</strong> </p>
<p>이후로는 일정이랄 것도 없고 계속 코딩과 식사를 반복했다. <strong>밥을 엄청 잘 준다.</strong> 네이버가 이번 행사를 기획한 진짜 목적은 굶주린 청년들의 배를 채워주려는 것이 아니었을까 싶을 정도로 먹을 것 제공이 잘 됐다. </p>
<p>식사는 시설이 아니니까 사진 촬영을 좀 했다. </p>
<p><img src="https://s3.ap-northeast-2.amazonaws.com/techblog-static-imgs/KakaoTalk_Photo_2018-05-19-10-42-02.jpeg" alt="1일차저녁"></p>
<p>첫째날 저녁인데 <strong>무려 셰프님이 철판을 들고 나오셔서 닭갈비를 볶아주신다.</strong> 첫 식사부터 엄청난 퀄리티에 압도되었는데 이건 시작에 불과했다. </p>
<p><img src="https://s3.ap-northeast-2.amazonaws.com/techblog-static-imgs/KakaoTalk_Photo_2018-05-19-10-42-11.jpeg" alt="2일차아침"></p>
<p><strong>아니 내가 어디 호텔에 와 있나?</strong> 2일차 아침이다. </p>
<p><img src="https://s3.ap-northeast-2.amazonaws.com/techblog-static-imgs/KakaoTalk_Photo_2018-05-19-10-42-20.jpeg" alt="마지막"></p>
<p>마지막까지 이런 식사를…. 너무 감덩……</p>
<p>이외에도 밤에 <strong>즉석에서 튀긴 순살 치킨</strong> 이 제공됐다. 너무 행복했다. </p>
<p><strong>프로젝트 진행</strong></p>
<p>프로젝트 진행은 팀 별로 배정된 공간에서 각자의 개발 장비를 펼쳐놓고 진행한다. 팀 별로 공간이 배정되어있지만 이번 행사를 위해 <strong>커넥트원 시설을 통째로 사용</strong> 했으므로 커넥트원 내부에서 팀별로 코딩을 할 수 있는 장소라면 어디든지 사용할 수 있었다. </p>
<p>우리 팀도 어디로 옮겨볼까? 했지만 주행사장이 너무 안락하고 좋아서 그대로 앉아서 하기로 했다. 시설에는 프로젝트에 몰입할 수 있게 설계한 공간들이 많았고, 사진을 촬영하고 싶었지만 사진 촬영이 엄금되어 있어 사진을 촬영하지 못했던 점 이해해 주시길 바란다. </p>
<p>우리팀의 주제는 <strong>단위 테스트에 기반한 실시간 공지사항 플랫폼</strong> 이었다. 단위 테스트의 중요성이 크게 강조됐다. TDD까지는 아니어도 주요 컴포넌트에 대한 단위 테스트가 이뤄져야함을 멘토님이 늘 강조하셨다. </p>
<p>프로젝트의 요구사항을 그대로 옮기기는 어려울 것 같고, 내가 작성한 코드를 중심으로 간단한 해설과 우리 주제에 대한 내 생각을 곁들여본다. </p>
<p><strong>프로젝트의 결과물은 1인 1제출을 원칙으로 했다(우리팀의 경우).</strong></p>
<p><a href="http://naveradm.wheejuni.com" target="_blank" rel="noopener">배포된 프로젝트 사이트 구경가기</a></p>
<p>SupportedFileTypes.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SupportedFileTypes &#123;</span><br><span class="line"></span><br><span class="line">    XLS(<span class="string">"xls"</span>, <span class="string">"application/vnd.ms-excel"</span>),</span><br><span class="line">    XLSX(<span class="string">"xlsx"</span>, <span class="string">"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"</span>),</span><br><span class="line">    CSV(<span class="string">"csv"</span>, <span class="string">"text/csv"</span>),</span><br><span class="line">    TSV(<span class="string">"tsv"</span>, <span class="string">"text/tsv"</span>),</span><br><span class="line">    TXT(<span class="string">"txt"</span>, <span class="string">"text/plain"</span>),</span><br><span class="line">    PNG(<span class="string">"png"</span>, <span class="string">"image/png"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String extension;</span><br><span class="line">    <span class="keyword">private</span> String mimeType;</span><br><span class="line"></span><br><span class="line">    SupportedFileTypes(String extension, String mimeType) &#123;</span><br><span class="line">        <span class="keyword">this</span>.extension = extension;</span><br><span class="line">        <span class="keyword">this</span>.mimeType = mimeType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatchingType</span><span class="params">(String extension)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> extension.equalsIgnoreCase(<span class="keyword">this</span>.extension);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSupportedFile</span><span class="params">(MultipartFile file)</span> </span>&#123;</span><br><span class="line">        String filename = file.getOriginalFilename();</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(SupportedFileTypes.values()).anyMatch(t -&gt; t.isMatchingType(FilenameUtils.getExtension(filename)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>프로젝트의 요구사항 중, 특정 파일 타입에 대해서만 업로드를 허용하는 사항이 있었다. </p>
<p>물론 프론트에서도 유효성 검사를 시행하지만 이번 주제의 경우 프론트보다는 서버단의 구현이 훨씬 중시되는 것이 사실이기 때문에 백엔드에서의 검증 로직을 구현해봤다. </p>
<p>FileService 에서 파일 확장자에 대한 검증을 수행하는 것도 좋다고 생각했지만, 파일 확장자와 MIME type 등을 하드 코딩해서 구현한다면 차후 허용되는 확장자가 변경되는 상황에 대해 유연하게 대응하기 어렵다고 판단, 파일 형식을 Enum으로 구현하기로 결정했다. </p>
<p>파일 형식에 대한 Enum 구현을 마치고 나니 Multipartfile Request 자체에 대한 검증 로직을 파일타입 객체에서 전담하게 하는 것이 설계상 맞는 판단이라고 생각되어 isSupportedFile(MultipartFile file) 을 통한 파일 확장자 유효성 검증까지 맡겼다. </p>
<p>파일 타입에 대한 검증은 Java 8의 Stream API를 적극적으로 사용했다. </p>
<p>SupportedFileTypesTest.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupportedFileTypesTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MultipartFile file;</span><br><span class="line">    <span class="keyword">private</span> MultipartFile fileExcel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.file = mock(MultipartFile<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        when(<span class="keyword">this</span>.file.getOriginalFilename()).thenReturn(<span class="string">"testfile_withUnderBars_whynotworking.csv"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.fileExcel = mock(MultipartFile<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        when(<span class="keyword">this</span>.fileExcel.getOriginalFilename()).thenReturn(<span class="string">"testfile_multiperiods.xlsx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">supportedFileTypes_fileExtensionCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertTrue(SupportedFileTypes.isSupportedFile(<span class="keyword">this</span>.file));</span><br><span class="line">        assertTrue(SupportedFileTypes.isSupportedFile(<span class="keyword">this</span>.fileExcel));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>상기한 로직에 대한 검증은 이 유닛테스트로 시행하였다. </p>
<p>MultipartFile 객체를 직접 만드는 것은 의미도 없고 귀찮다고 생각하여 Mockito를 사용해 모의 객체를 생성하였다. .getOriginalFilename() 만 구현하면 되기 때문에 유닛테스트 작성이 무척 용이해졌다. </p>
<p>.csv, .xlsx 두 가지 파일이름을 가진 파일 업로드 요청이 정상적으로 분기 처리되는지를 검증했다. </p>
<p>ArticleListView.kt</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleListView</span></span>(</span><br><span class="line"></span><br><span class="line">        <span class="meta">@field:JsonProperty</span>(<span class="string">"title"</span>)</span><br><span class="line">        <span class="keyword">val</span> title: String? = <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">        <span class="meta">@field:JsonProperty</span>(<span class="string">"group"</span>)</span><br><span class="line">        <span class="keyword">val</span> group: String? = <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">        <span class="meta">@field:JsonProperty</span>(<span class="string">"href"</span>)</span><br><span class="line">        <span class="keyword">val</span> link: String? = <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">fromModel</span><span class="params">(article: <span class="type">Article</span>, link: <span class="type">String</span>)</span></span>: ArticleListView &#123;</span><br><span class="line">            <span class="keyword">return</span> ArticleListView(title = article.title, link = link)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DTO는 내 취향대로 코틀린으로 작성하였고 덕분에 보일러플레이트를 상당 부분 줄일 수 있었다. </p>
<p>기본값으로 null을 부여한 것은 com.fasterxml.jackson 의 요구사항 중 하나인 기본 생성자 구현 조건을 맞춰주기 위한 것으로 코틀린을 이용한 DTO 구현의 유일한 군더더기이다. (사실 이 부분도 jackson-kotlin-plugin을 통해 해결할 수 있다.)</p>
<p><strong>프론트엔드</strong></p>
<p>사실 프론트엔드 구현은 이번 프로젝트의 주안점이 아니라고 생각되어 너무 프론트에서 힘빼지 않으려고 노력했다.</p>
<p>그래도 하다보니 뭔가 쪼리는 느낌(?) 이 들어서 프론트에도 엄청난 공을 들이는 내 자신을 발견하게 됐다. </p>
<p>로그인 기능을 구현했고, 상태 관리 도구도 붙이려고 mobx를 유력히 검토했으나 시간 관계상 그러지 못했다. 전반적으로 프론트엔드 코드는 매우 지저분하고 즉각적인 리팩토링을 요하는 상태다. </p>
<p>프로젝트의 요구조건 중 하나인 REST API 제공과 간단한 프론트엔드 구현을 모두 충족하는 방향으로 개발하려면 React.js 기반의 SPA 제작이 제격인 것 같아 그렇게 구현했다. </p>
<p>NewArticlePage.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.state.submitFinished) &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;Redirect to="/"/&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div className=<span class="string">"articlewrite-container"</span>&gt;</span><br><span class="line">            &lt;h3 className=<span class="string">"articlewrite-pagetitle"</span>&gt;새 공지사항&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">            &lt;GroupCheckbox groups=&#123;this.state.availableGroups&#125; onCheckPressed=&#123;this.onGroupCheckChanged.bind(this)&#125; title=&#123;this.onTitleChange&#125;/</span>&gt;</span><br><span class="line">            &lt;div className=<span class="string">"articlewrite-editor-container"</span> ref=&#123;ref =&gt; <span class="keyword">this</span>.editorContainerRef = ref&#125;&gt;</span><br><span class="line">                </span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div className="articlewrite-wordcount"&gt;</span></span><br><span class="line"><span class="regexp">                &lt;h3 className="word-count"&gt;&#123;this.state.wordCount&#125;/</span><span class="number">1000</span>&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">            &lt;div className=<span class="string">"articlewrite-fileupload-container"</span>&gt;</span><br><span class="line">                &lt;div className=<span class="string">"fileupload-header"</span>&gt;</span><br><span class="line">                    &lt;h3 className=<span class="string">"fileupload-title"</span>&gt;파일 업로드&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;p className="fileupload-caption"&gt;파일은 5MB 이하의 xlsx, xls, txt, csv, tsv만 업로드하실 수 있습니다.&lt;/</span>p&gt;</span><br><span class="line">                &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">                &lt;div className="fileupload-component"&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;DropZone accept=&#123;this.fileTypes&#125; onDrop=&#123;this.onFileDrop&#125; className="fileupload-dropzone"&gt;</span></span><br><span class="line"><span class="regexp">                    &amp;nbsp;</span></span><br><span class="line"><span class="regexp">                        &lt;div className="dropzone-element fileupload-dropzone-caption"&gt;파일을 이곳에 드래그 앤 드롭 하세요.&lt;/</span>div&gt;</span><br><span class="line">                        &lt;button className=<span class="string">"dropzone-element fileupload-dropzone-click"</span>&gt;클릭해서 파일 탐색&lt;<span class="regexp">/button&gt; </span></span><br><span class="line"><span class="regexp">                    &lt;/</span>DropZone&gt;</span><br><span class="line">                &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">                &lt;UploadedFiles files=&#123;this.state.uploadedFiles&#125;/</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div className="articlewrite-submit"&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button className="btn btn-success" onClick=&#123;this.onSubmitClick&#125;&gt;공지사항 등록&lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>새로운 게시글을 올리는 smart component의 렌더 부분만 가져와봤다. 프론트엔드는 대체로 이런 수준의 구현이다. </p>
<p>child component 몇 개를 더 분리해낼 수 있는 지점이 보이지만 마크업 / UI 제작 -&gt; 컴포넌트 분리 -&gt; 로직 작성 의 flow를 따라가다보니 시간 관계상 컴포넌트 분리를 제대로 할 수 없었다. </p>
<p><img src="https://s3.ap-northeast-2.amazonaws.com/techblog-static-imgs/40226538-e25f0e5e-5ac6-11e8-954a-0a083551b3d2.JPG" alt="단체사진"></p>
<p>다들 수고가 많았다.</p>
<p><strong>멘토님의 총평</strong> </p>
<p>멘토님은 다음과 같은 평을 남겨주셨다. </p>
<ul>
<li><p>(멘토님 질문) 몽고DB를 사용한 이유가 궁금하다.</p>
<ul>
<li>(나의 답변) 사용자 알림이라는 데이터 자체가 JOIN 등 관계형 데이터베이스의 특성으로 보관할 이유가 없다고 보고 NoSQL을 도입해봄.</li>
<li>학습 목적으로 MongoDB를 실 프로젝트에 한 번 붙여보았다(진짜 멍청한 대답이었다고 생각된다)</li>
</ul>
</li>
<li><p>사실 알림 기능을 훨씬 단순히 구현할 수 있었을 텐데 별도의 저장소를 사용한 것이 신기하게 느껴진다(들으면서 식은땀이 줄줄 흘렀다).</p>
</li>
<li><p>(인텔리제이 REST Client 기능) .http 파일은 인텔리제이 플러그인인가? Postman을 사용하지 않는가? </p>
</li>
<li>서버 배포를 옵션 요구사항으로 포함한 것은 리눅스를 다루는 모습을 보기 위함이었다. </li>
</ul>
<p>이 정도의 말씀을 여기에 옮길 수 있을 것 같다. </p>
<p><strong>우리 주제에 대한 나의 소고</strong></p>
<p>우리 멘토님은 멘티들에게 프로젝트 진행에 있어 극도의 자유도를 부여하셨고 우리도 적극적으로 자유를 만끽하며 각자 하고싶은 대로 프로젝트를 구현했다. 셋 다 다른 버전의 스프링을 사용했고 어떤 분은 Spring @MVC, 어떤 분은 Spring Boot를 사용했다. 데이터 persistence에 있어서도 MyBatis를 사용한 분도 있고 Spring Data JPA를 사용하신 분도 있다. </p>
<p>약간의 부가기능이 추가된 CRUD 프로젝트를 진행하며 <strong>의외로 많은 평가의 포인트가 있었을 수도 있겠다</strong> 는 생각이 문득 들었다. 프론트 구현 능력은 어느정도가 되는지, 객체지향적 설계는 어느 정도 할 줄 아는지 등을 볼 수 있었을 것 같고 멘토님께서 직접 말씀하신 것처럼 배포 과제를 통해 리눅스환경 친숙도도 평가해볼만 할 것 같다. </p>
<p>한 가지 아쉬운 점은 “네이버 쇼핑” 이라는 사업분야와 직접적인 연관관계를 떠올릴 만한 주제는 아니었다고 생각되고, 예비 개발자들의 이목을 잡아끌 수 있는 흥미로운 주제는 아니었다는 생각이 들었다. 물론 다른팀 주제들이 좀 말도 안되게 재밌는 것들이 많아서 상대적으로 그래보인 부분도 있다. </p>
<p>나같은 경우 커머스, 광고 분야에 관심이 있고 향후 개발자로써의 커리어를 만드는데 있어 주 도메인을 커머스사업, 혹은 물류/모빌리티쪽으로 잡아나갈 생각이기에 내게 이번 주제는 의미도 있고 또 네이버 쇼핑을 만드는 개발자와 1박 2일간 같은 공간에서 호흡할 수 있는 기적같은 기회이기도 했다. <em>다른 친구들에겐 그정도까진 아니었을 것이다.</em> </p>
<hr>
<h4 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h4><p>1박 2일이 금방 지나갔다. 개인적으로는 너무나 큰 의미가 있는 시간이었다. </p>
<p>작년(2017년) 1월 깃허브에 첫 커밋, 이후 개인 프로젝트를 통해 개발에 흥미를 얻고 같은해 8월에 개발 공부 본격적 시작, 그리고 오늘 네이버 커넥트원에 서기까지의 시간들이 주마등처럼 흘러갔다. 물론 하나의 과정에 지나지 않는 거지만 다시 한 번 좋은 선생님들과 함께 <strong>기적같은 한 해를 보냈다</strong>는 생각이 들어 마음이 너무 벅찼다. </p>
<p>향후 네이버 인턴 기회로까지 이어지면 좋겠지만 결과에 관계 없이 당당하게 멋진 도전을 했다는 생각이 들어 내 자신이 대견하게 느껴졌다. 무엇보다 나의 개발자로써의 진로설정을 반신반의하시던 부모님께 어쨌든 국내 1위 IT기업의 행사 참가라는 가시적인 결과물을 보여드릴 수 있어 기쁘게 생각한다. </p>
<p>또 앞으로 무엇을 공부해야 할지에 대해 힌트를 얻을 수 있는 시간들이었다. <strong>데 이 터 베 이 스</strong> 를 지금보다 훨씬 더 잘 알아야겠다는 생각이 많이 들었다. 지금도 완전 모르는 것은 아니지만 <strong>오히려 지금같은 상태가 더 위험할 수도 있겠다</strong>는 생각이 문득 들었다. </p>
<p>신선한 충격과 자극을 쉴새없이 떨어트려 준 1박 2일이었다!</p>
<p><img src="https://s3.ap-northeast-2.amazonaws.com/techblog-static-imgs/40225954-7008e4fc-5ac5-11e8-915a-cb0504803d55.JPG" alt="핵데이"></p>
<p>즐거운 기회를 만들어주신 네이버 임직원 여러분들과 고수아 멘토님, 그리고 수고해주신 모든 분들께 깊이 감사드립니다.</p>
<p><strong>프로젝트 리포지토리 보러가기</strong></p>
<ul>
<li><a href="https://github.com/seulgiwendy/hackday-shopping-frontend" target="_blank" rel="noopener">프론트엔드</a></li>
<li><a href="https://github.com/seulgiwendy/hackday-shopping" target="_blank" rel="noopener">백엔드</a></li>
</ul>
<hr>
<p><strong>기술면접에 가게 됐다.</strong> 곧 면접 후기도 쓸게요. </p>
<p><em>내가 네이버 면접이라니 ㅜㅜㅜㅜㅜㅜ</em></p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/05/19/naver-hackday/" data-id="ckkklasnj00agn49onzt4up2i" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/05/19/naver-hackday/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring-aop-how" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Spring-Framework/">Spring_Framework</a>►<a class="article-category-link" href="/categories/Spring-Framework/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/02/spring-aop-how/">스프링 AOP는 어떻게 의도대로 작동하는가</a>
    </h1>
  

        <a href="/2018/05/02/spring-aop-how/" class="article-date">
  <time datetime="2018-05-02T03:26:36.000Z" itemprop="datePublished">2018-05-02</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="스프링-AOP는-어떻게-의도대로-작동하는가"><a href="#스프링-AOP는-어떻게-의도대로-작동하는가" class="headerlink" title="스프링 AOP는 어떻게 의도대로 작동하는가"></a>스프링 AOP는 어떻게 의도대로 작동하는가</h3><p>스프링이 거대한 DI(Dependency Injection, 종속성 주입)컨테이너임은 누구나 아는 사실이다. 그리고 우리는 이런 컨테이너의 도움을 받아 비즈니스 로직에 집중하고, POJO만으로 서비스를 개발할 수 있음에 하루 하루 감사함을 느끼며 살고 있다. </p>
<p>그러나 우리가 DI의 메카니즘 자체에 대해 고민해볼 일은 많지 않은 것이 사실이다. 단순히 <code>@Autowired</code>를 달면 알아서 종속성이 잘 주입되어 의도대로 작동하는 것을 보며 감탄하거나 무덤덤해 할 뿐 그 이상의 느낌을 갖지는 못하는 것 같다.</p>
<p>최근 프로젝트에서 AOP를 적용해볼까 고민하던 차에 AOP의 구현이 뭔가 장황하게 느껴지고 앞뒤가 맞지 않는듯한 느낌이 들어 학습에 어려움을 겪은 적이 있었다. 이 어려움은 Spring의 애플리케이션 콘텍스트가 사실은 거대한 DI 콘테이너에 불과하다는 것을 상기하고, DI 개념에 대한 기초 학습부터 다시 진행하니 조금씩 해결됐다. </p>
<p>이번 글을 통해 스프링의 종속성 주입이 어떻게 이뤄지는지를 다시 한 번 복습해 보고, AOP의 핵심 개념에 대해 알아보는 시간을 갖고자 한다. </p>
<p><strong>종속성 주입</strong></p>
<p>우리는 걸그룹의 인사 구호를 외쳐주는 클래스를 작성할 것이다. 걸그룹들은 저마다의 <a href="https://www.youtube.com/watch?v=6mS2iZa1QMA" target="_blank" rel="noopener">독특한 인사 구호</a> 를 갖고 있다. </p>
<p>단순하게 생각해보면 이런 식의 구현을 가져갈 수 있겠다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GirlGroupHello</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDVELVET_HELLO = <span class="string">"해피니스! 안녕하세요 레드벨벳입니다!"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TWICE_HELLO = <span class="string">"원 인어 밀리언!"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHi</span><span class="params">(String groupName)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span>(groupName) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"레드벨벳"</span>:</span><br><span class="line">                <span class="keyword">return</span> REDVELVET_HELLO;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"트와이스"</span>:</span><br><span class="line">                <span class="keyword">return</span> TWICE_HELLO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>단순하고 좋아보이는 구현이지만 몇 가지 문제점이 눈에 들어온다.</p>
<ul>
<li>객체지향 설계의 안티패턴(anti pattern)이라고 잘 알려져있는 <code>switch-case</code> 가 핵심 로직으로 구현돼있다. </li>
<li>차후 확장의 여지가 적다. <em>세상에는 레벨 트와 말고도 걸그룹이 많잖아?</em></li>
</ul>
<p>이런 방식이면 어떨까?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GirlGroupHello</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> HelloWords helloWords;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GirlGroupHello</span><span class="params">(HelloWords helloWords)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.helloWords = helloWords;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloWords.sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloWords</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">sayHi</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedVelvetHelloWords</span> <span class="keyword">implements</span> <span class="title">HelloWords</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"해피니스! 안녕하세요 레드벨벳입니다!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 <code>GirlGroupHello</code> 객체는 인사구호를 만들어주는 로직에 대한 통제권을 완전히 잃어버렸다. 대신, 객체가 생성될 때 주입받은 종속성이 만들어주는 인사구호를 그냥 전달해주는 역할만을 받게 되었다.</p>
<p>객체가 자신이 수행할 동작을 정의하지 않고 주입받은 종속성을 통해 자신의 행동을 통제받는 <strong>제어권의 역전(IoC)</strong> 이 일어난 것이다.</p>
<p>개발자는 이제 새로운 걸그룹이 나올 때마다 스파게티같이 늘어진 스위치 케이스 문을 수정할 생각에 밤잠을 설치지 않아도 된다. 그가 할 일은 <code>HelloWords</code>를 구현한 새로운 클래스를 작성해 적절하게 주입시켜주는 것 뿐이다. </p>
<p><strong>새로운 요구사항의 등장</strong></p>
<p>SM엔터테인먼트가 주 52시간 근로 규정을 준수하는지 알아보기 위해, 레드벨벳이 인사구호를 외칠 때마다 타임스탬프를 기록하는 요구사항을 구현해야 한다고 가정해보자. </p>
<p>가장 쉬운 것은 인터페이스를 수정하는 것이다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloWords</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">sayHi</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">LocalDateTime <span class="title">when</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 방식에는 다음과 같은 문제점이 있다.</p>
<ul>
<li>그동안 구현했던 <code>HelloWords</code>의 구현체를 일괄적으로 수정해야 한다. 그렇지 않으면 컴파일 에러가 발생한다.</li>
<li>정식 근로계약을 맺지 않아 요구사항의 구현이 필요 없는 걸그룹들도 있다. <em>(더 나쁜 것 같지만 넘어가자)</em></li>
</ul>
<p><strong>부가기능 구현 클래스</strong></p>
<p>다음과 같이 부가기능을 구현한 뒤 원래 구현체에 동작을 위임하는 구현을 할 수 있겠다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeAddedHelloWords</span> <span class="keyword">implements</span> <span class="title">HelloWords</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HelloWords helloWords;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeAddedHelloWords</span><span class="params">(HelloWords helloWords)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.helloWords = helloWords;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDateTime <span class="title">when</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalDateTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloWords.sayHi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이처럼 종속성 주입을 적절히 잘(…) 활용하면 <strong>원래 코드에 대한 수정 없이도</strong> 계속 요구사항 구현을 추가해 나갈 수 있고 기능별로 구현체를 고립시킴으로써 <strong>유닛 테스트와 유지보수도 용이해지는</strong> 이점을 가질 수 있다. </p>
<p><strong>AOP가 별건가?</strong></p>
<p>AOP라는 건 결국 공통의 관심사(aspect)를 추상화해 잘 보관하고 있다가 필요한 곳에 동적으로 삽입하여 부가기능을 구현해주는 방법론에 불과한 것이다. </p>
<p>스프링에서 공통의 관심사를 추상화해 잘 보관하고 있는 객체를 <strong>어드바이스(Advice)</strong> 라고 하고, 이 부가기능이 타깃 구현체에서 적용될 시점을 <strong>포인트컷(Pointcut)</strong> 이라 부른다.</p>
<p>스프링은 AOP를 구현하기 위해 프록시 객체를 만든다. 개발자가 작성한 빈 클래스에 부가기능을 추가하기 위해, 런타임에서 동적으로 부가기능을 주입하는 프록시 객체를 만드는 것이다. </p>
<p>프록시 객체를 만드는 방법에는 두 가지 방식이 사용된다.</p>
<ul>
<li><p>JDK Dynamic Proxy : <code>java.lang.reflect</code>를 사용하는 고전적 방식이다. 인터페이스에 대해서만 프록시 객체를 만들 수 있으므로 concrete class에 대해 바로 포인트컷을 준 경우에는 사용할 수 없다.</p>
</li>
<li><p>CGLIB : Code Generator Library의 약자라고 한다. 구현 방식은 개발자가 작성한 빈 클래스를 상속받아 프록시 객체를 만드는 것이다.</p>
<ul>
<li>클래스에 대해서도 프록시 객체를 만들어줄 수 있다는 장점이 있다(상속받으니까!).</li>
<li>때문에 Final class는 사용할 수 없다. </li>
<li>Kotlin과 병행 사용할때는 각별한 주의를 요한다. <a href="https://kotlinlang.org/docs/reference/classes.html" target="_blank" rel="noopener">Kotlin은 기본적으로 모든 클래스가 final이다</a>.<ul>
<li>이 문제를 해결해주는 Compiler Plugin이 있다(Spring, Spring-JPA 등). 나중에 살펴본다. </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>사실 포인트컷을 정의하는 일은 꽤나 까다롭다. 포인트컷 표현식(expression language)을 써서 메소드를 정확히 정의해야하는데 다양한 인터페이스에서 공통적으로 적용되는 포인트컷이라면 번거롭기 그지 없을 것이다. </p>
<p>이런 경우 커스텀 애너테이션을 붙여 포인트컷을 정의해주는 방법도 고려해볼만 하다. </p>
<p><a href="http://www.baeldung.com/spring-aop-annotation" target="_blank" rel="noopener">요렇게 하면 되겠다.</a></p>
<p>실제 AOP를 프로젝트에 적용해 본 사례는 다음 글을 통해 공유해 보겠다. </p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/05/02/spring-aop-how/" data-id="ckkklasjt004wn49oo9ns11ub" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/05/02/spring-aop-how/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-morningcs-adder" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/morning-cs/">morning_cs</a>►<a class="article-category-link" href="/categories/morning-cs/hardware/">hardware</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/19/morningcs-adder/">아침 CS - (7) 가산기</a>
    </h1>
  

        <a href="/2018/04/19/morningcs-adder/" class="article-date">
  <time datetime="2018-04-18T23:12:00.000Z" itemprop="datePublished">2018-04-19</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="가산기"><a href="#가산기" class="headerlink" title="가산기"></a>가산기</h3><p>지식인에 <em>1 + 1이 뭐에요</em> 라고 물어본 적이 있다. 중학교 1학년때였다.</p>
<p><a href="https://kin.naver.com/qna/detail.nhn?d1id=13&amp;dirId=130103&amp;docId=38110613" target="_blank" rel="noopener">흑역사의 현장 바로가기</a></p>
<p>답변은…의외로 고퀄리티다. 솔직히 지금 읽어도 완전히 이해되진 않지만, 핵심은 <strong>모든 자연수는 연속된다. 바로 다음 수가 같다면 자연수는 같은 수이다</strong> 라는 대전제를 통해 1 + 1을 풀이해 주신 것으로 생각된다. </p>
<p><strong>컴퓨터 프로그램이란 별 거 아니다, 더하고 빼고 곱학고 나누고 하는거다</strong> 라는 누군가 했는지 잘 기억나지 않는… 명언이 있다. 결국 누군가가 컴퓨터 안에서 더하고 빼고 곱하고 나누는 작업을 수행해줘야 로직을 작동시킬 수 있는 것이다. 우리는 그런 역할을 수행하는 주체가 CPU임은 상식으로 알고 있지만, 생각해보면 CPU가 어떤 원리로 사칙 연산을 수행하는지는 고민해본 적이 별로 없다. </p>
<p>CPU는 어떻게 1 + 1을 수행하는가? 오늘은 가산기에 대해 알아보자. </p>
<hr>
<h4 id="반가산기"><a href="#반가산기" class="headerlink" title="반가산기"></a>반가산기</h4><p>반가산기는 이진수의 한자리수를 연산한다. 만약 자리올림이 필요하다면, 자리올림수 출력에 따라 출력한다. </p>
<table>
<thead>
<tr>
<th>입력 (A, B)</th>
<th>자리올림수, 출력(C. S)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0, 0</td>
<td>0, 0</td>
</tr>
<tr>
<td>0, 1</td>
<td>0, 1</td>
</tr>
<tr>
<td>1, 0</td>
<td>0, 1</td>
</tr>
<tr>
<td>1, 1</td>
<td>1, 1</td>
</tr>
</tbody>
</table>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/14/Half-adder.svg/325px-Half-adder.svg.png" alt="전가산기 회로도"></p>
<h4 id="전가산기"><a href="#전가산기" class="headerlink" title="전가산기"></a>전가산기</h4><p>반가산기를 통해 연산한 자릿수를 포함해 연산한다. </p>
<p>하위 자리올림수 출력을 받아 상위 입력으로 연결하는 것이다. 초등학생 덧셈 공부하듯…..</p>
<p>하나의 전가산기는 두 개의 반가산기와 하나의 OR 로 이뤄진다고 한다. </p>
<table>
<thead>
<tr>
<th>입력 (A, B, 자리올림 입력)</th>
<th>출력(자리올림 출력, 출력)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0, 1, 1</td>
<td>1, 0</td>
</tr>
<tr>
<td>1, 1, 1</td>
<td>1, 1</td>
</tr>
<tr>
<td>1, 0, 0</td>
<td>0, 1</td>
</tr>
<tr>
<td>1, 0, 1</td>
<td>1, 0</td>
</tr>
<tr>
<td>1, 1, 0</td>
<td>1, 0</td>
</tr>
</tbody>
</table>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a9/Full-adder.svg/550px-Full-adder.svg.png" alt="전가산기 회로도"></p>
<p>A, B 입력을 일단 한 번 반가산기에 올린 후, 자리올림수 값과 출력값을 받는다. 받은 출력값을 두 번째 반가산기에 연결시킨다. </p>
<p>두 번째 반가산기에는 첫번째 반가산기의 결과값과 처음에 받았던 자리올림 입력을 넣으면 된다. 두 번째 반가산기의 출력이 출력값(S)이 되고, 자리올림수는 두 반가산기의 자리올림 출력을 OR 연산하면 된다. </p>
<hr>
<p><strong>아니 그럼, 뺄셈은 어떻게 하나?</strong></p>
<p>변속레버를 R에 놓으면 차가 뒤로 가듯 가산기를 거꾸로 돌리면 뺄셈이 된다. </p>
<p>입력 A, B는 피감수와 감수로, (감산을 당한다는 뜻일 게다.)</p>
<p>자리올림수는 빌림수가 된다. 낮은 위치에서 1을 한 개 꿔 와 감산하고, 다음 비트 연산에 반영하는 것이다. 출력은 차이수(D)와 빌림수로 한다. </p>
<hr>
<p><strong>아니 그럼, 곱셈은 어떻게 하나?</strong></p>
<p>초등학생 때로 돌아가보자. 당신이 파인만이나 토발즈 급의 천재가 아니었다면 나처럼 엄마한테 볼기짝을 맞아가며 구구단을 공부했을 것이다. </p>
<p>구구단은 외워주는 것이 제맛이지만 평가 시간만 되면 까먹기 마련이므로 둔부를 맞지 않기 위한 일련의 방책을 준비해 두는 것이 가장 좋다. </p>
<p>즉 <code>8 * 5</code> , <code>4 * 5</code> 와 같이 암기하기 간편한 값을 캐싱해 두고 그 이후의 단수는 캐시된 값에 피승수를 더해가며 계산하는 것이 좋다. 4 5는 20! 이므로 4 6 은 20 + 4, 24가 되는 것이다. </p>
<p>컴퓨터의 곱셈도 마찬가지다. 앞서 살펴본 가산기를 통해 컴퓨터가 덧셈을 처리하는 방식은 알았으니, 컴퓨터가 덧셈을 처리하는 방식에 대한 이견은 없을 것 같다. 다만 멍청한 컴퓨터를 위해 그가 지금까지 몇 번 덧셈을 수행했는지를 알려줄 부품이 필요할 것이다. <em>체육시간에 앉아번호 할 때 꼭 지 번호 까먹는 놈들이 있지 않았던가.</em> 이런 부품을 계수기(counter)라고 한다. </p>
<p>다만 이런 방식의 곱셈은 엄청난 문제가 있다. 19 * 19 정도의 연산이면 문제가 전혀 없다. 문제는 자릿수가 엄청나게 커지면 커질 수록 연산의 비용도 커진다는 것이다. </p>
<p>이런 방식의 곱셈 연산은 <code>O(2^n)</code>의 시간복잡도를 갖는다. </p>
<p>그래서 이런 방식을…</p>
<p><img src="https://www.electronicshub.org/wp-content/uploads/2015/06/Binary-Multiplication.jpg" alt="이진수 곱셈"></p>
<p>사실 이진수의 곱셈은 십진수보다 쉽다. 승수가 0 아니면 1 둘중에 하나기 때문에 피승수 혹은 0을 한 칸씩 왼쪽으로 옮긴 후 각 행별로 가산 연산을 해주면 된다. 위 그림처럼 말이다. </p>
<p>왼쪽으로 한칸씩 옮기는 과정을 시프팅(shifting)이라고 부르고, 이를 수행하는 연산 유닛을 시프터(shifter)라고 한다. 곱셈 회로는 시프터와 가산기만 있으면 만들 수 있다. 또 시간 복잡도는 <code>O(N)</code>으로 대폭 개선된다. 32비트 이진수를 곱해도 32번의 시프팅과 32번의 가산 연산만 하면 계산할 수 있는 것이다. </p>
<hr>
<p><strong>아니 그럼, 나눗셈은 어떻게 하나?</strong></p>
<p>다행히 우리 엄마는 나눗셈을 못한다고 나를 혼내진 않았다. 그래서 나눗셈을 쉽게 할 방법은 별로 고민하지 못한 것 같다. </p>
<p>그러나 라이프니츠나 폰 노이만 같은 분들은 고민했을 것이다.</p>
<p>나눗셈도 단순히 생각하면 곱셈의 단순한 방법과 같이 피제수에서 제수를 정해진 횟수만큼 빼면 되지만 그랬다간 <code>O(2^n)</code>을 피할 수 없을 것이다. </p>
<p><img src="https://s3.ap-northeast-2.amazonaws.com/wheejuni-techblog-static/Division2.png" alt="이진 나눗셈"></p>
<p><strong>오른쪽 쪽지는 무시해라.</strong></p>
<p>곱셈과 같은 방식으로 한 행씩 감산 연산을 해 나가면 된다. 제수를 피제수의 첫 세자리에서 빼고, 한 칸씩 오른쪽으로 가며 같은 연산을 수행하면 된다. 피제수의 남은 숫자가 제수보다 작아질 때까지. </p>
<p>시프터를 거꾸로 돌리고 감산 회로만 있으면 나눗셈도 <code>O(N)</code>에 수행할 수 있고, 제수와 피제수의 자릿수가 일치하는 최상의 경우에는 <code>O(1)</code>로도 가능하다(감산 한 번).</p>
<hr>
<p><strong>참고 문헌</strong></p>
<p><a href="https://ko.wikipedia.org/wiki/%EA%B0%80%EC%82%B0%EA%B8%B0" target="_blank" rel="noopener">가산기</a></p>
<p><a href="http://www.ddaily.co.kr/news/article.html?no=125593" target="_blank" rel="noopener">[MCU강의⑤] CPU 실행방법… 덧셈·뺄셈·곱셈·나눗셈 어떻게?</a></p>
<p>….이외에 집에 굴러다니던 과학 교재, 수학책, 정처기 교재 등…..</p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/04/19/morningcs-adder/" data-id="ckkklasgp0013n49ofoblgani" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/04/19/morningcs-adder/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-morningcs-bool" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/morning-cs/">morning_cs</a>►<a class="article-category-link" href="/categories/morning-cs/boolean-algebra/">boolean_algebra</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/14/morningcs-bool/">아침 CS - (6) 논리 연산</a>
    </h1>
  

        <a href="/2018/04/14/morningcs-bool/" class="article-date">
  <time datetime="2018-04-13T23:27:45.000Z" itemprop="datePublished">2018-04-14</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="논리-연산"><a href="#논리-연산" class="headerlink" title="논리 연산"></a>논리 연산</h3><p>부울 대수(Boolean Algebra)라고도 불리는 논리 연산의 기본 개념은 19세기 중반 영국의 수학자 조지 부울이 창안했다고 한다. </p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/ce/George_Boole_color.jpg" alt="조지 불"></p>
<p>두 개의 상태(True - 1, False - 0)를 갖고 연산을 수행하기때문에 컴퓨터 과학에서는 빼놓을 수 없는 주제이며 프로그래밍에선 IF문, FOR - EACH, WHILE 등 정말 이거 없이 프로그래밍을 어떻게 하나 싶을 정도로 폭넓게 사용되고 있다. </p>
<p><em>논리 게이트?</em></p>
<p>논리 게이트는 하나 또는 그 이상의 입력신호로부터 하나의 출력값을 발생시키도록 구성된 전자 회로다. 전자 회로는 두 개의 구분되는 전기적 신호에 따라 작동하도록 설계되고, 논리 - 1, 논리 - 0 과 같은 이진 변수로 표현할 수 있는 구분된 응답을 되돌려주게 된다. </p>
<p>허용된 범위 내의 전기적 신호가 회로에 들어오면, 그 범위를 판단하여 정해진 전기 신호를 출력하는 것이다. <strong>Arduino를 해보면 잘 알게 된다.</strong></p>
<h4 id="진리표"><a href="#진리표" class="headerlink" title="진리표"></a>진리표</h4><p>논리연산을 공부할 때 꼭 그려봐야 하는 것이 바로 진리표다. </p>
<p>논리 연산의 가능한 결과값을 표에 모두 나타낸 것을 진리표라고 한다. 논리 연산의 결과가 혼동되거나 뭔가 이해가 안된다 싶으면 그려보는 것이 좋다. </p>
<p><code>A AND B</code> 논리연산 </p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>결과값</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="논리-연산의-종류"><a href="#논리-연산의-종류" class="headerlink" title="논리 연산의 종류"></a>논리 연산의 종류</h3><p>크게 7가지의 종류가 있다. </p>
<h4 id="부정-NOT"><a href="#부정-NOT" class="headerlink" title="부정(NOT)"></a>부정(NOT)</h4><p>부정하는 것이다. <em>여러분 이거 다~ 거짓말인 거 아시죠?</em></p>
<table>
<thead>
<tr>
<th>입력값</th>
<th>결과값</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>C의 영향을 받은 언어에서는 <code>!</code>를 부정 연산자로 쓴다. <code>~</code> 라고도 표현한다. </p>
<p>“보수 연산자” 혹은 “부울 보수” 라고도 하는 모양이다. 보수 연산자라는 표현은 자주 들어봤지만…</p>
<h4 id="논리곱-AND"><a href="#논리곱-AND" class="headerlink" title="논리곱(AND)"></a>논리곱(AND)</h4><p>“앤드 조건문” 안 들어본 사람은 없을 것이다. 주로 <code>&amp;</code> 기호를 사용한다. </p>
<p>두 명제가 모두 참이여야 참이 되는 연산이다.</p>
<table>
<thead>
<tr>
<th>입력값</th>
<th>결과값</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 , 0</td>
<td>0</td>
</tr>
<tr>
<td>0 , 1</td>
<td>0</td>
</tr>
<tr>
<td>1 , 0</td>
<td>0</td>
</tr>
<tr>
<td>1 , 1</td>
<td>1</td>
</tr>
</tbody>
</table>
<h4 id="논리합-OR"><a href="#논리합-OR" class="headerlink" title="논리합(OR)"></a>논리합(OR)</h4><p>“OR 조건문” 안 들어본 사람은 없을 것이다. 주로 <code>|</code> 기호를 사용한다. </p>
<p>두 명제 중 하나만 참이라도 참이 되는 연산이다. </p>
<table>
<thead>
<tr>
<th>입력값</th>
<th>결과값</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 , 0</td>
<td>0</td>
</tr>
<tr>
<td>0 , 1</td>
<td>1</td>
</tr>
<tr>
<td>1 , 0</td>
<td>1</td>
</tr>
<tr>
<td>1 , 1</td>
<td>1</td>
</tr>
</tbody>
</table>
<h4 id="부정-논리곱-NAND"><a href="#부정-논리곱-NAND" class="headerlink" title="부정 논리곱(NAND)"></a>부정 논리곱(NAND)</h4><p>Not AND 라고 한다. 논리곱의 결과를 한 번 부정(NOT)한 것이다. </p>
<p>여기서부턴 안 들어본 사람도 있을 것이다. </p>
<p>두 명제가 모두 참이면 거짓, 이외에는 모두 참이다. 논리곱의 경우 두 명제가 모두 참일때만 참을 돌려주므로 이를 부정하니 당연한 결과이다. 낸드 메모리는 진짜 NAND 회로로 만드는 것이라고 한다. </p>
<table>
<thead>
<tr>
<th>입력값</th>
<th>결과값</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 , 0</td>
<td>1</td>
</tr>
<tr>
<td>0 , 1</td>
<td>1</td>
</tr>
<tr>
<td>1 , 0</td>
<td>1</td>
</tr>
<tr>
<td>1 , 1</td>
<td>0</td>
</tr>
</tbody>
</table>
<h4 id="부정-논리합-NOR"><a href="#부정-논리합-NOR" class="headerlink" title="부정 논리합(NOR)"></a>부정 논리합(NOR)</h4><p>Not OR 이다. 논리합의 결과를 부정한 것이다. 두 명제가 모두 거짓이어야 참, 이외엔 모두 거짓. </p>
<table>
<thead>
<tr>
<th>입력값</th>
<th>결과값</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 , 0</td>
<td>1</td>
</tr>
<tr>
<td>0 , 1</td>
<td>0</td>
</tr>
<tr>
<td>1 , 0</td>
<td>0</td>
</tr>
<tr>
<td>1 , 1</td>
<td>0</td>
</tr>
</tbody>
</table>
<h4 id="배타적-논리합-XOR-동치-EQV"><a href="#배타적-논리합-XOR-동치-EQV" class="headerlink" title="배타적 논리합(XOR), 동치(EQV)"></a>배타적 논리합(XOR), 동치(EQV)</h4><p><strong>XOR</strong></p>
<p>두 명제 중 하나만 참이거나, 두 명제의 참거짓이 다를때 참이다. 암호화 기법으로도 많이 사용된다고 한다. </p>
<table>
<thead>
<tr>
<th>입력값</th>
<th>결과값</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 , 0</td>
<td>0</td>
</tr>
<tr>
<td>0 , 1</td>
<td>1</td>
</tr>
<tr>
<td>1 , 0</td>
<td>1</td>
</tr>
<tr>
<td>1 , 1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><strong>EQV</strong></p>
<p>두 명제가 같은 값을 가지면 참, 아니면 거짓. 배타적 논리곱이라고도 한다. </p>
<table>
<thead>
<tr>
<th>입력값</th>
<th>결과값</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 , 0</td>
<td>1</td>
</tr>
<tr>
<td>0 , 1</td>
<td>0</td>
</tr>
<tr>
<td>1 , 0</td>
<td>0</td>
</tr>
<tr>
<td>1 , 1</td>
<td>1</td>
</tr>
</tbody>
</table>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/04/14/morningcs-bool/" data-id="ckkklasgt0017n49odoct0cs0" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/04/14/morningcs-bool/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-morningcs-hash" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/morning-cs/">morning_cs</a>►<a class="article-category-link" href="/categories/morning-cs/hash/">hash</a>►<a class="article-category-link" href="/categories/morning-cs/hash/algorithm/">algorithm</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/morningcs-hash/">아침 CS - (5) 해시 함수</a>
    </h1>
  

        <a href="/2018/04/13/morningcs-hash/" class="article-date">
  <time datetime="2018-04-12T22:59:34.000Z" itemprop="datePublished">2018-04-13</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="해시-함수"><a href="#해시-함수" class="headerlink" title="해시 함수"></a>해시 함수</h3><p>해시 함수는 프로그래밍을 하며 가장 흔하게 접할 수 있는 함수 중 하나로 자바의 <code>HashMap, HashSet</code> 등 자료형과 파이썬의 <code>Dictionary</code> 등에서 사용되고 있다. </p>
<p>또 개발하며 <code>equals(), hashCode()</code>를 같이 오버라이드해본 경험은 다들 갖고 있을 것이다. </p>
<p>왜 두 녀석이 따라다니는지, 해시코드가 뭔지, 그리고 해시 함수는 무슨 역할을 하는지 알아보자. </p>
<hr>
<h4 id="개념"><a href="#개념" class="headerlink" title="개념"></a>개념</h4><p><strong>정의</strong></p>
<p>임의의 길이의 데이터를 <strong>고정된 길이의 데이터</strong>로 매핑하는 함수이다. 그리고 그 데이터를 해시 값, 해시 코드 혹은 해시 체크섬이라고도 부른다. </p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/Hash_table_4_1_1_0_0_1_0_LL.svg/300px-Hash_table_4_1_1_0_0_1_0_LL.svg.png" alt="해시함수 개념도"></p>
<p>사람의 이름을 해시코드로 바꿔주는 위 해시함수의 개념도에서 <em>고정된 길이</em> 는 두 자리의 정수일 것이다. </p>
<p>위 개념도에서 나타난 해시 함수의 기본적인 성질이 두 가지가 있다. </p>
<ul>
<li>결정적: 해시값이 다르면 원래의 데이터도 다르다. </li>
<li>단사 함수가 아님: 같은 해시값을 같더라도 원래의 입력값이 같은 것은 아니다. <ul>
<li>위 그림을 보면 Sandra Dee, John Smith가 모두 같은 해시값 02를 갖지만, 원 데이터는 분명히 다르다. </li>
</ul>
</li>
</ul>
<hr>
<h4 id="해시의-충돌"><a href="#해시의-충돌" class="headerlink" title="해시의 충돌"></a>해시의 충돌</h4><p>상기한 것처럼 다른 두 개 이상의 값이 같은 해시코드를 가질 수 있다. </p>
<p>이러한 충돌은 알고리즘이나 자료구조의 효율성을 저해하기 때문에 최대한 억제해야 한다. </p>
<p><strong>비둘기집의 원리</strong></p>
<p>해시코드가 왜 충돌하는지를 살펴보려면 먼저 비둘기집의 원리를 간단히 이해할 필요가 있겠다. </p>
<blockquote>
<p><code>n + 1</code>개의 물건을 <code>n</code>개의 상자에 넣은 경우, 최소한 한 상자에는 두 개 이상의 물건이 들어있다.</p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/5/5c/TooManyPigeons.jpg" alt="비둘기집"></p>
<p>위 사진에서 만약 10마리의 비둘기를 보관하려고 했다면, 당연히 충돌이 발생할 것이다. </p>
<p>해시 함수를 통해 처리되는 데이터의 범위보다 해시값의 범위가 더 좁다면 <strong>당연히</strong> 같은 원리로 충돌이 발생한다. </p>
<hr>
<h4 id="자바에서의-hashCode-작동"><a href="#자바에서의-hashCode-작동" class="headerlink" title="자바에서의 hashCode() 작동"></a>자바에서의 <code>hashCode()</code> 작동</h4><p>사실 자바 자체가 메소드를 만들어주는 것이 아닌, 각자 사용하는 개발 환경(Eclipse, IntelliJ, 혹은 Google Commons 같은 외부 라이브러리….)에 따라 구현이 달라지기때문에 몇 가지의 대표적인 경우만 보고 넘어가도록 하겠다. </p>
<p><strong><code>java.lang.Object</code></strong> 에서의 존재</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>(…)  이게 끝이다. </p>
<p>자바의 native 키워드에 대해서도 알면 좋겠지만 나중에 보도록 하고 일단 이 메소드가 어떻게 해시코드를 만들어주는지에 대해 알아보자. </p>
<p><strong>작동 원리</strong></p>
<p><strong>OpenJDK</strong> 에서의 구현 </p>
<p>네이티브 코드의 호출은 각 JVM 구현체별로 그 결과가 상이하게 나타날 수 있다. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))</span><br><span class="line">   JVMWrapper(<span class="string">"JVM_IHashCode"</span>);</span><br><span class="line">   <span class="comment">// as implemented in the classic virtual machine; return 0 if object is NULL</span></span><br><span class="line">      <span class="keyword">return</span> handle == <span class="literal">NULL</span> ? <span class="number">0</span> : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>
<p>NULL 이라면 0을 돌려주고 뭔가 값이 있다면 <code>ObjectSynchronizer.FastHashCode()</code> 라는게 호출되는 것 같다. </p>
<p>OpenJDK는 기본적으로 해시코드를 만드는 전략 여섯 개를 갖고 있는데, 다음과 같다. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> value = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (hashCode == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">// This form uses an unguarded global Park-Miller RNG,</span></span><br><span class="line">   <span class="comment">// so it's possible for two threads to race and generate the same RNG.</span></span><br><span class="line">   <span class="comment">// On MP system we'll have lots of RW access to a global, so the</span></span><br><span class="line">   <span class="comment">// mechanism induces lots of coherency traffic.</span></span><br><span class="line">   value = os::random() ;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> (hashCode == <span class="number">1</span>) &#123;</span><br><span class="line">   <span class="comment">// This variation has the property of being stable (idempotent)</span></span><br><span class="line">   <span class="comment">// between STW operations.  This can be useful in some of the 1-0</span></span><br><span class="line">   <span class="comment">// synchronization schemes.</span></span><br><span class="line">   <span class="keyword">intptr_t</span> addrBits = cast_from_oop&lt;<span class="keyword">intptr_t</span>&gt;(obj) &gt;&gt; <span class="number">3</span> ;</span><br><span class="line">   value = addrBits ^ (addrBits &gt;&gt; <span class="number">5</span>) ^ GVars.stwRandom ;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> (hashCode == <span class="number">2</span>) &#123;</span><br><span class="line">   value = <span class="number">1</span> ;            <span class="comment">// for sensitivity testing</span></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> (hashCode == <span class="number">3</span>) &#123;</span><br><span class="line">   value = ++GVars.hcSequence ;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> (hashCode == <span class="number">4</span>) &#123;</span><br><span class="line">   value = cast_from_oop&lt;<span class="keyword">intptr_t</span>&gt;(obj) ;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// Marsaglia's xor-shift scheme with thread-specific state</span></span><br><span class="line">   <span class="comment">// This is probably the best overall implementation -- we'll</span></span><br><span class="line">   <span class="comment">// likely make this the default in future releases.</span></span><br><span class="line">   <span class="keyword">unsigned</span> t = Self-&gt;_hashStateX ;</span><br><span class="line">   t ^= (t &lt;&lt; <span class="number">11</span>) ;</span><br><span class="line">   Self-&gt;_hashStateX = Self-&gt;_hashStateY ;</span><br><span class="line">   Self-&gt;_hashStateY = Self-&gt;_hashStateZ ;</span><br><span class="line">   Self-&gt;_hashStateZ = Self-&gt;_hashStateW ;</span><br><span class="line">   <span class="keyword">unsigned</span> v = Self-&gt;_hashStateW ;</span><br><span class="line">   v = (v ^ (v &gt;&gt; <span class="number">19</span>)) ^ (t ^ (t &gt;&gt; <span class="number">8</span>)) ;</span><br><span class="line">   Self-&gt;_hashStateW = v ;</span><br><span class="line">   value = v ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>정리해보면…. </p>
<table>
<thead>
<tr>
<th>번호</th>
<th style="text-align:center">작동방식</th>
<th style="text-align:right">비고</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align:center">완전 랜덤 숫자 출력</td>
<td style="text-align:right">아예 랜덤 숫자임. Park-Miller 난수 생성 방식 <a href="https://en.wikipedia.org/wiki/Lehmer_random_number_generator" target="_blank" rel="noopener">참고</a></td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">메모리 주소 함수</td>
<td style="text-align:right">-</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">하드코딩된 1</td>
<td style="text-align:right">민감성 체크 용</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">시퀸스</td>
<td style="text-align:right">-</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">메모리 주소</td>
<td style="text-align:right">-</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:center">XOR shift 난수생성법과 혼합된 스레드 상태</td>
<td style="text-align:right"><a href="https://en.wikipedia.org/wiki/Xorshift" target="_blank" rel="noopener">참고</a></td>
</tr>
</tbody>
</table>
<p>솔직히 어떤 상황에서 어떤 전략이 사용될지 보장할 수도 없고(기본값이 4번이기는 하다, 우리가 흔히 알고있는 것처럼) 저 다섯가지를 바꿔가며 쓸 필요가 있는 것도 (일상적인 상황에서는) 아니다. </p>
<p><strong>그냥 각자 IDE가 만들어주는 해시함수 잘 쓰자.</strong></p>
<p><strong>참고 문헌</strong></p>
<p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509/src/share/vm/runtime/synchronizer.cpp" target="_blank" rel="noopener">OpenJDK source</a></p>
<p><a href="https://srvaroa.github.io/jvm/java/openjdk/biased-locking/2017/01/30/hashCode.html" target="_blank" rel="noopener">How does the default hashCode() work?</a></p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/04/13/morningcs-hash/" data-id="ckkklasgq0014n49olz68a2pf" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/04/13/morningcs-hash/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-morningcs-rbt" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/morning-cs/">morning_cs</a>►<a class="article-category-link" href="/categories/morning-cs/data-structure/">data_structure</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/12/morningcs-rbt/">아침 CS - (4) 레드 블랙 트리</a>
    </h1>
  

        <a href="/2018/04/12/morningcs-rbt/" class="article-date">
  <time datetime="2018-04-11T23:19:35.000Z" itemprop="datePublished">2018-04-12</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="레드-블랙-트리"><a href="#레드-블랙-트리" class="headerlink" title="레드 블랙 트리"></a>레드 블랙 트리</h3><p>레드벨벳과 이름이 비슷하여(…) 관심을 갖게된 레드 블랙 트리(Red - Black Tree) 는 최근 함수형 프로그래밍의 추세에서 특히 많이 사용되고 있는 트리라고 한다. </p>
<p>이진 트리가 불완전하거나 편향되면 가질 수 있는 여러 문제를 해결해줄 수 있으며 <strong>삽입과 삭제, 검색에서 최악의 경우에도 일정한 실행시간을 보장</strong>한다.  </p>
<p>일정한 실행 시간을 보장해야만 하는 다양한 상황에서 유용하게 쓰일 수 있을 것이다. </p>
<hr>
<h4 id="개념"><a href="#개념" class="headerlink" title="개념"></a>개념</h4><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/800px-Red-black_tree_example.svg.png" alt="레드 블랙 트리"></p>
<p>다섯 가지의 대원칙이 있다. </p>
<ul>
<li>노드는 레드 혹은 블랙 중의 하나이다. </li>
<li>루트 노드는 블랙이다. </li>
<li>모든 리프 노드는 블랙이다. </li>
<li>레드 노드의 자식노드 양쪽은 언제나 모두 블랙이다(레드 노드는 연달아 나타날 수 없다).</li>
<li>어떤 노드로부터 시작되어 리프 노드에 도달하는 모든 경로에는 리프노드를 제외하면 모두 같은 개수의 블랙 노드가 있다. </li>
</ul>
<p><strong>뭔 소리냐?</strong></p>
<hr>
<h4 id="이진-탐색-트리-BST-Binary-Search-Tree-에-대하여"><a href="#이진-탐색-트리-BST-Binary-Search-Tree-에-대하여" class="headerlink" title="이진 탐색 트리(BST, Binary Search Tree)에 대하여"></a>이진 탐색 트리(BST, Binary Search Tree)에 대하여</h4><p>레드 블랙 트리에 대해 자세히 알아보기에 앞서 이진 탐색 트리에 대해 먼저 간략히 알아본다. </p>
<p>이진 트리와 다르게 <strong>부모 노드보다 작은 값은 왼쪽에, 큰 값은 오른쪽에 배치</strong>하는 트리를 이진 탐색 트리라고 한다. </p>
<p>이런 식의 정렬을 수행해 놓으면 단순히 트리를 <a href="https://tech.wheejuni.com/2018/04/09/morningcs-treetraversal/">중위 순회</a> 하는 것만으로도 오름차순 정렬된 값을 얻을 수 있다. </p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/300px-Binary_search_tree.svg.png" alt="이진 탐색 트리"></p>
<p>위 트리를 중위 순회(왼쪽 - 부모 - 오른쪽 순으로 방문)하면 </p>
<p><code>1 3 4 6 7 8 10 13 14</code> 순으로 방문하며 값을 빼올 수 있다. </p>
<p>그러나 효율적인 것처럼 보이는 이진 탐색 트리도 <strong>편향 트리</strong>의 문제를 해결할 순 없다. 즉 루트 노드보다 큰 값이 계속 들어온다면 트리의 오른쪽에만 노드들이 쌓이게 되고, <code>O(n)</code>의 시간으로 탐색할 수밖에 없게 된다. </p>
<p><strong>삼촌 노드란?</strong> 삼촌 노드는 부모와 같은 부모를 갖는 다른 노드를 말하는 것이다.</p>
<p>위 예제에서 보자면 4번 노드의 삼촌 노드는 1번일 것이다. 이모 노드라고 해도 좋다. 어쨌든 공식 명칭은 uncle node다. </p>
<hr>
<h4 id="레드-블랙-트리는-어떻게-문제를-해결하는가"><a href="#레드-블랙-트리는-어떻게-문제를-해결하는가" class="headerlink" title="레드 블랙 트리는 어떻게 문제를 해결하는가"></a>레드 블랙 트리는 어떻게 문제를 해결하는가</h4><p>레드 블랙 트리는 <strong>균형 트리</strong> 이다. 편향성을 보이지 않는다. </p>
<p><em>어떻게?</em></p>
<hr>
<p><strong>삽입</strong></p>
<p>아래 그림을 보며 이해하려고 노력해보자. </p>
<p><img src="https://s3.ap-northeast-2.amazonaws.com/techblog-static-imgs/269_a.gif" alt="참고 그림"></p>
<p><strong>일단, 첫 노드를 블랙으로 삽입한다</strong></p>
<p>(규칙 2, 루트 노드는 블랙이다)</p>
<p>지금부터는 삽입 과정에서 발견될 수 있는 규칙 위반상황, 그리고 레드 블랙 트리가 이 문제를 어떻게 해결하는지에 대해 보겠다.</p>
<h4 id="부모가-빨간색인데-삼촌도-빨간색인-경우-Case-1"><a href="#부모가-빨간색인데-삼촌도-빨간색인-경우-Case-1" class="headerlink" title="부모가 빨간색인데 삼촌도 빨간색인 경우 (Case 1)"></a>부모가 빨간색인데 삼촌도 빨간색인 경우 (Case 1)</h4><p>이런 경우는 부모 노드의 부모 노드, 즉 조부모 노드는 반드시 검은색이여야 한다. </p>
<p><code>규칙 4. 레드 노드는 연달아 나타날 수 없다</code> 를 위배하게 되기 때문이다.</p>
<p>이 conflict를 해결하기 위해서 할아버지를 빨간 색으로 바꾸고 부모와 삼촌은 검은색으로 바꿔주는 작업을 수행하면 된다. 이를 <strong>색 변환</strong> 이라고 부른다. </p>
<h4 id="부모가-빨간색인데-삼촌은-검은색인-경우-Case-3"><a href="#부모가-빨간색인데-삼촌은-검은색인-경우-Case-3" class="headerlink" title="부모가 빨간색인데 삼촌은 검은색인 경우(Case 3)"></a>부모가 빨간색인데 삼촌은 검은색인 경우(Case 3)</h4><p>이번에도 2번과 7번 노드가 모두 빨간 노드로 규칙 4가 위배되었다. </p>
<p>아까와 같이 11번과 7번의 색깔을 바꾸는 것만으로는 문제를 해결하기 어렵다. 루트 노드가 빨간 노드일 수 없기 때문이다. </p>
<p>이런 경우 노드 전체를 오른쪽으로 한칸씩 미는 작업을 수행하면 되겠는데 이를 <strong>회전</strong> 이라고 부른다. </p>
<p>조금 더 간단한 그림으로 다시 알아보자. </p>
<p><img src="https://s3.ap-northeast-2.amazonaws.com/techblog-static-imgs/d0014632_05022619.gif" alt="회전 참고도"></p>
<p>새로 삽입된 노드 X가 부모 A와 같은 붉은색을 갖는 문제가 발생하였다. 이 문제를 해결하기 위해 우회전을 수행하고 트리를 재구조화하면 된다. </p>
<hr>
<h4 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h4><p>솔직히 말해 아직 레드블랙트리에 대한 정확한 이해는 하지 못한 상태이다. </p>
<p>그러나 완벽한 학습 후 정리를 하기 보단 학습을 하며 정리를 조금씩 해 나가고, 오랜만에 이진 탐색 트리의 개념도 다시 살펴보는 게 의미있다 판단하여 아침 CS 주제로 좀 부담스런 주제를 선정해보게 됐다. </p>
<p>이 포스트는 두고두고 조금씩 업데이트할 생각이다. </p>
<hr>
<p><strong>참고 문헌</strong></p>
<p><a href="http://staff.ustc.edu.cn/~csli/graduate/algorithms/book6/chap14.htm" target="_blank" rel="noopener">CHAPTER 14: RED-BLACK TREES</a></p>
<p><a href="http://egloos.zum.com/sweeper/v/900135" target="_blank" rel="noopener">Red-Black Tree (from 2-4 Tree #1)</a></p>
<p><a href="https://www.youtube.com/watch?v=5IBxA-bZZH8&amp;" target="_blank" rel="noopener">Red-Black trees in 5 minutes - Insertions(Strategy)</a></p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/04/12/morningcs-rbt/" data-id="ckkklasgv0019n49ohcsi9l9h" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/04/12/morningcs-rbt/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-morningcs-binarytree" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/morning-cs/">morning_cs</a>►<a class="article-category-link" href="/categories/morning-cs/data-structure/">data_structure</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/11/morningcs-binarytree/">아침 CS - (3) 이진 트리</a>
    </h1>
  

        <a href="/2018/04/11/morningcs-binarytree/" class="article-date">
  <time datetime="2018-04-10T23:16:14.000Z" itemprop="datePublished">2018-04-11</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="이진트리의-개념과-구조"><a href="#이진트리의-개념과-구조" class="headerlink" title="이진트리의 개념과 구조"></a>이진트리의 개념과 구조</h3><p>사실 트리에는 이진 트리만 있는 것이 <strong>아니다.</strong></p>
<p>삼진 트리도 있고 십육진 트리도 있을 것이다. 그러나 우리가 가장 잘 알아야 하는 이진트리에 대해 가장 먼저 살펴보기로 하고 다른 구조를 갖는 트리들은 어디에 쓰이는지 나중에 또…. 공부할 기회가 뭐 있겠죠.</p>
<p>우선 트리에서 사용하는 용어들을 잠깐 살펴봅시다. </p>
<hr>
<h4 id="기본-용어와-개념들"><a href="#기본-용어와-개념들" class="headerlink" title="기본 용어와 개념들"></a>기본 용어와 개념들</h4><p><img src="https://s3.ap-northeast-2.amazonaws.com/techblog-static-imgs/%E1%84%87%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%82%E1%85%A5%E1%84%85%E1%85%B5%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5.001.jpeg" alt="예제 트리"></p>
<p><strong>노드</strong></p>
<ul>
<li>우리가 트리에서 가장 쉽게 보는 그 동글뱅이. </li>
<li><p>노드에도 몇 가지 종류가 있음. </p>
</li>
<li><p>계층에 따른 노드 구분</p>
<ul>
<li>부모 노드 : 자식을 1개 이상 갖고 있는, 즉, 하위레벨에 노드가 한 개라도 있는 모든 노드 </li>
<li>자식 노드 : 상위 노드를 갖고 있는, 즉 부모 노드가 아닌 노드 </li>
</ul>
</li>
<li><p>특성에 따른 노드 구분</p>
<ul>
<li>루트 노드 : 트리의 최상단에 위치하는 노드. 각 트리별로 하나 뿐이다. </li>
<li>단말 노드 : 마지막 노드. 최하위 노드. 자식이 없는 노드이다. </li>
<li>내부 노드 : 단말 노드를 제외한 모든 노드. </li>
<li>형제 : 같은 부모를 갖고 있는 두 개의 노드.</li>
</ul>
</li>
<li><p>노드의 ~ </p>
<ul>
<li>크기 : 자신을 포함한 자손들의 총 갯수. </li>
<li>깊이 : 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 링크의 수</li>
<li>차수 : 노드가 가진 가지의 수 </li>
</ul>
</li>
</ul>
<p><strong>링크</strong></p>
<ul>
<li>노드를 이어주는 선</li>
<li><code>n</code>개의 노드를 갖는 트리에서, 링크의 갯수는 <code>n-1</code>개임 </li>
</ul>
<p><strong>레벨</strong></p>
<ul>
<li>같은 깊이에 있는 노드들의 총 집합 </li>
<li>최상단이 레벨 1부터 시작, 아래로 내려갈때마다 1씩 커짐 </li>
</ul>
<hr>
<h4 id="이진-트리의-종류"><a href="#이진-트리의-종류" class="headerlink" title="이진 트리의 종류"></a>이진 트리의 종류</h4><p><img src="https://farm5.staticflickr.com/4456/23854064708_945beebd1a_o.png" alt="이진트리 예시"></p>
<ul>
<li><p>포화 이진 트리 : 모든 레벨에서 노드들이 꽉 채워진 상태. </p>
<ul>
<li>높이가 h인 포화 이진 트리는 2^h - 1 개의 노드를 가짐.</li>
</ul>
</li>
<li><p>완전 이진 트리 : 마지막 레벨을 제외하고 모든 노드가 채워짐, 마지막 레벨도 다 채워져도 무방. </p>
</li>
<li><p>편향 트리 : 보시다시피….</p>
<ul>
<li>트리 최악의 경우가 발생 : 최악의 경우 노드가 N개인 이진 트리의 높이는 O(N)이 될 수도 있음. </li>
<li>포화 트리, 혹은 완전 트리의 경우 : O(logN)</li>
</ul>
</li>
</ul>
<h4 id="참고-문헌"><a href="#참고-문헌" class="headerlink" title="참고 문헌"></a>참고 문헌</h4><p><a href="https://jiwondh.github.io/2017/10/15/tree/" target="_blank" rel="noopener">[Algorithm] 트리의 개념과 용어정리</a></p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/04/11/morningcs-binarytree/" data-id="ckkklasgm000yn49owp73ij41" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/04/11/morningcs-binarytree/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-morningcs-treetraversal" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/data-structure/">data_structure</a>►<a class="article-category-link" href="/categories/data-structure/algorithm/">algorithm</a>►<a class="article-category-link" href="/categories/data-structure/algorithm/morning-cs/">morning_cs</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/09/morningcs-treetraversal/">아침 CS - (2) 트리 순회</a>
    </h1>
  

        <a href="/2018/04/09/morningcs-treetraversal/" class="article-date">
  <time datetime="2018-04-09T00:55:06.000Z" itemprop="datePublished">2018-04-09</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="트리-순회"><a href="#트리-순회" class="headerlink" title="트리 순회"></a>트리 순회</h3><p>트리 순회는 트리 자료구조를 탐색해 데이터를 찾는 순회 방법을 말하는 것이다.</p>
<p><strong>후위 순회, 중위 순회, 전위 순회, 레벨 순회</strong> 의 큰 네가지로 이뤄진다. </p>
<hr>
<h4 id="예제-트리"><a href="#예제-트리" class="headerlink" title="예제 트리"></a>예제 트리</h4><p>아래의 그림으로 네 가지의 순회법을 설명한다. </p>
<p><img src="https://www.geeksforgeeks.org/wp-content/uploads/2009/06/tree12.gif" alt="이진 트리"></p>
<hr>
<h4 id="후위-순회"><a href="#후위-순회" class="headerlink" title="후위 순회"></a>후위 순회</h4><p><strong>내가 제일 좋아하는 순회라서 가장 앞에 소개한다.</strong> </p>
<blockquote>
<p>왼쪽 오른쪽 부모 </p>
</blockquote>
<p>간단하다. </p>
<p>먼저 왼쪽 노드의 왼쪽 자식(무조건 왼쪽, 좌파다)을 방문하고, 오른쪽 노드, 그리고 부모 순으로 방문하면 된다. </p>
<p><em>부모는 무조건 맨 나중이다.</em> 4 - 5 - 2 - 3 - 1 순서로 방문. </p>
<hr>
<h4 id="중위-순회"><a href="#중위-순회" class="headerlink" title="중위 순회"></a>중위 순회</h4><blockquote>
<p>왼쪽 부모 오른쪽 </p>
</blockquote>
<p>어떻게보면 가장 상식적으로 추론할 수 있는 순회법이다. </p>
<p>가장 왼쪽의 노드를 먼저 방문한 다음 슬래시를 치듯이 방문하면 된다. </p>
<p>4 - 2 - 5 - 1 - 3.</p>
<hr>
<h4 id="전위-순회"><a href="#전위-순회" class="headerlink" title="전위 순회"></a>전위 순회</h4><blockquote>
<p>부모 왼쪽 오른쪽 </p>
</blockquote>
<p>부모님을 공경하는 순회법이다. </p>
<p>그러나 자식 노드를 방문할 땐 왼쪽부터 방문해야 하는 건 같다. </p>
<p><strong>오해하면 안되는게 재귀적으로 왼쪽을 쭉 탐색한 다음 오른쪽 노드로 넘어가는 것이다.</strong> 즉 왼쪽 노드가 자식을 갖고 있으면 그 자식들 중 왼쪽 노드를 또 탐색해야 한다. </p>
<p>1 - 2 - 4 - 5 - 3.</p>
<hr>
<h4 id="레벨-순회"><a href="#레벨-순회" class="headerlink" title="레벨 순회"></a>레벨 순회</h4><p><em>부야!</em></p>
<blockquote>
<p>같은 층부터 방문 </p>
</blockquote>
<p>나와 같은 레벨의 노드들부터 방문, 하나씩 레벨을 내려가며 왼쪽 노드부터 읽는다.</p>
<p>1 - 2 - 3 - 4 - 5.</p>
<hr>
<h4 id="추가로-학습할-점"><a href="#추가로-학습할-점" class="headerlink" title="추가로 학습할 점"></a>추가로 학습할 점</h4><ul>
<li>각 순회를 코드로 구현해보면 좋겠다. </li>
</ul>
<hr>
<h4 id="트리-순회를-실생활에-적용하는-법"><a href="#트리-순회를-실생활에-적용하는-법" class="headerlink" title="트리 순회를 실생활에 적용하는 법"></a>트리 순회를 실생활에 적용하는 법</h4><p>명절날 친정부터 갈지 시댁부터 갈지 정할때 활용해보면 좋다. </p>
<p><strong>여보, 이번 추석은 후위 순회 할까?</strong></p>
<hr>
<h4 id="연습문제-풀어보기"><a href="#연습문제-풀어보기" class="headerlink" title="연습문제 풀어보기"></a>연습문제 풀어보기</h4><p><a href="https://jiwondh.github.io/2017/10/15/tree_traversal/#-%EC%A4%91%EC%9C%84-%EC%88%9C%ED%9A%8C-inorder-traversal" target="_blank" rel="noopener">링크</a></p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/04/09/morningcs-treetraversal/" data-id="ckkklash2001jn49oump1onlq" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/04/09/morningcs-treetraversal/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; 이전</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">다음 &raquo;</a>
  </nav>

</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 정휘준<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> with 
      theme_by <a href="http://hexo.io/" target="_blank">mango</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives/" class="mobile-nav-link">Archives</a>
  
    <a href="/about/" class="mobile-nav-link">about</a>
  
</nav>
    
<script>
  var disqus_shortname = 'bomee';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>