<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>봄이네집 개발 블로그</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="봄이네집 개발 블로그">
<meta property="og:url" content="https://tech.wheejuni.com/page/2/index.html">
<meta property="og:site_name" content="봄이네집 개발 블로그">
<meta property="og:locale" content="ko">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="봄이네집 개발 블로그">
  
    <link rel="alternate" href="/atom.xml" title="봄이네집 개발 블로그" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+KR:100,300,400,700&amp;subset=korean" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <!--<div id="banner"></div>-->
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        <a href="/" id="main-nav-title" class="main-nav-link">봄이네집 개발 블로그</a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives/">Archives</a>
        
          <a class="main-nav-link" href="/about/">about</a>
        
      </nav>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-jpa-cartesian" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/jpa/">jpa</a>►<a class="article-category-link" href="/categories/jpa/database/">database</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/16/jpa-cartesian/">JPA N + 1 문제를 해결하자.</a>
    </h1>
  

        <a href="/2018/06/16/jpa-cartesian/" class="article-date">
  <time datetime="2018-06-16T01:57:31.000Z" itemprop="datePublished">2018-06-16</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="JPA-N-1-문제를-해결하자"><a href="#JPA-N-1-문제를-해결하자" class="headerlink" title="JPA N + 1 문제를 해결하자."></a>JPA N + 1 문제를 해결하자.</h3><p>지난 겨울 프로젝트를 진행하며 일대다 관계를 많이 갖는 엔티티 클래스를 작성할 일이 있었다. 여느 때처럼 JPA의 도움을 받아 어렵지 않게 작성했다고 생각했는데, 데이터베이스 관리와 데브옵스 역할을 담당하고 있던 팀원이 난처한 표정을 짓는 것을 볼 수 있었다. </p>
<p><strong>엔티티 한 개 조회할 때마다 엄청난 양의 쿼리가 발생한 것이다.</strong> </p>
<p>처음에는 이 문제에 대해 정확히 이해하지 못하고 자식 엔티티의 자료구조를 바꾼다던지, named query를 사용한다던지 하는 피상적인 해결책만을 생각해낼 수밖에 없었다. SQL의 관점에서 생각해보면 자식 엔티티는 당연히 INNER JOIN 과 같은 키워드로 한 번에 빼오면 되는 문제였는데 이렇게 많은 쿼리가 발생한다는 것을 이해하지 못했기 때문이었다. </p>
<p>그러나 JPA에 대해 학습하면 할수록 이런 동작은 단순한 우연이 아닌 필연적인 부분이란 것을 알게됐고 이런 이슈를 최적화하는 것이 <strong>역량있는 개발자의 모습</strong> 이 아닐까 하고 생각하게 됐다. 더불어 상당수 조직과 초보 개발자들이 JPA 도입을 꺼리는 이유이기도 하다는 걸 알게 됐다. </p>
<h4 id="언제-발생하는가"><a href="#언제-발생하는가" class="headerlink" title="언제 발생하는가?"></a>언제 발생하는가?</h4><p>다음의 예제 엔티티 클래스들과 함께 설명을 진행해보겠다. </p>
<p>마스터와 학생은 일대다 관계를 갖고 있다. 한 마스터가 여러명의 학생을 관리하고 있고, 양방향 연관관계가 수립되어 있다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Master</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="keyword">private</span> Master master;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>아래는 마스터들을 조회할 수 있는 레포지토리 인터페이스이다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MasterRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Long</span>, <span class="title">Master</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    (JPA 레포지토리가 기본 제공해주는 메소드들이 당연히 포함되어 있다.)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 상황에서 MasterRepository.findAll() 을 실행했을 때, 우리는 이런 쿼리가 날라가길 기대할 것이다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">MASTER</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> STUDENT</span><br><span class="line"><span class="keyword">ON</span> STUDENT.MASTER_ID = MASTER.ID</span><br></pre></td></tr></table></figure>
<p><em>현실은…..</em></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">MASTER</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> MASTER_ID = <span class="number">0</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> MASTER_ID = <span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> MASTER_ID = <span class="number">2</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> MASTER_ID = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>DB에 상당한 부하를 일으키게 된다. </p>
<h4 id="왜-이러는가"><a href="#왜-이러는가" class="headerlink" title="왜 이러는가?"></a>왜 이러는가?</h4><p>JPA가 객체를 조회할 때 SQL이 아닌 <strong>JPQL의 생성과 파싱</strong> 으로 출발하기 때문이다. JPQL이란 SQL을 추상화한 객체지향 쿼리 언어로써, 자바 코드에서 데이터베이스를 조회할 때 특정 SQL 방언이나 저장 엔진에 종속되지 않게 도와준다. 또한 자바 코드를 작성하며 조회할 수 없을만 한 데이터베이스의 테이블명이나 컬럼 이름 대신 POJO의 필드명을 쿼리에 사용할 수 있으므로 개발에 편의성을 제공해 준다. </p>
<p>그리고 JDBC template의 Prepared Statement보다 한 단계 더 사용하기 편리한 지명 파라메터(named parameter) 기능을 제공한다. 말 그대로 쿼리 안에 변수를 대입할 수 있는 기능으로 잘 활용해 쿼리의 재사용성을 확보하여 조회 성능을 튜닝하고, SQL 주입 공격을 방어할 수 있다. </p>
<p>언뜻 보면 SQL보다도 좋아보이는 외계인의 기술 같지만 <strong>JPQL의 생성과 실행도 결국 SQL의 실행으로 귀결된다</strong> 는 점을 기억해야 하겠다. 우리가 겪고 있는 N + 1 문제도 사실 여기서 출발한 것이다. </p>
<p><em>간단한 JPQL 시범</em></p>
<p>모든 마스터 엔티티를 조회한다고 해보자. </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> m <span class="keyword">from</span> <span class="keyword">Master</span> m</span><br></pre></td></tr></table></figure>
<p>언뜻 보면 마스터의 모든 정보를 조회한 것 같지만 그렇지 않다. 애스터리스크가 있어야 할 자리에 객체의 별칭(alias)이 들어가 있는 점에 주목하자. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Master&gt; masters = em.createQuery(<span class="string">"select m from Master m"</span>, Master<span class="class">.<span class="keyword">class</span>).<span class="title">getResultList</span>()</span>;</span><br></pre></td></tr></table></figure>
<p>모든 마스터를 불러온다. 아까 살펴본 것처럼 마스터 객체에는 List<student> students 라는 필드가 있었다. </student></p>
<p>상기한 쿼리가 실행된 시점에서 이 필드는 <em>아직 조회되지 않았다.</em> </p>
<p><strong>지연 로딩</strong></p>
<p>객체에서 해당 필드에 대한 정보를 필요로하게 된 시점에, 지연 로딩이 발생하고, 여기서 모든 문제가 시작된다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Master m = masters.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(m.getStudents.size());</span><br></pre></td></tr></table></figure>
<p>마스터 객체에 대한 조회는 이미 끝났는데 학생 객체를 다시 조회해야 하므로 JOIN 문을 사용할 수 없고, 마스터의 @Id 값만 가지고 일일이 SELECT문을 만들어 다시 조회해야 하는 부담이 생긴다. </p>
<h3 id="해결책"><a href="#해결책" class="headerlink" title="해결책"></a>해결책</h3><p><strong>단순하게 생각하면 - EAGER 하게 로딩한다. (즉시 로딩)</strong></p>
<p>초보 개발자들이 흔히 하는 오해이고 이렇게 되면 모든 문제가 해결되리라 생각한다. 이렇게 엔티티 클래스를 고치는 것이다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OneToMany</span>(fetch = FetchType.EAGER)</span><br><span class="line">List&lt;Student&gt; students = Lists.newArrayList();</span><br></pre></td></tr></table></figure>
<p>그러나 작성된 쿼리 메소드가 JPQL로 변환되고 다시 그 JPQL이 실행되는 Spring Data JPA의 특성상, 이런 수정은 <strong>절대로 문제를 해결해주지 않는다.</strong></p>
<h4 id="두-번-생각하면-join-fetch-전략-사용"><a href="#두-번-생각하면-join-fetch-전략-사용" class="headerlink" title="두 번 생각하면 - join fetch 전략 사용"></a>두 번 생각하면 - join fetch 전략 사용</h4><p>커스텀 레포지토리를 작성한 후 직접 쿼리 메소드에 사용할 JPQL을 명시해주면서, fetch 키워드를 추가해주는 것이다. </p>
<p>커스텀 레포지토리의 작성은 이 글의 범위를 벗어나는 것 같아 다루지 않겠다. 아래와 같은 JPQL을 넣어주면 된다. </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> m <span class="keyword">from</span> <span class="keyword">Master</span> m <span class="keyword">join</span> <span class="keyword">fetch</span> m.students</span><br></pre></td></tr></table></figure>
<p>이는 아래와 같은 SQL문으로 번역된다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">MASTER</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> STUDENT</span><br><span class="line"><span class="keyword">ON</span> STUDENT.MASTER_ID = MASTER.ID</span><br></pre></td></tr></table></figure>
<p><em>(실제 번역내용은 하이버네이트의 규칙을 따르므로 이와 상이하다)</em></p>
<h4 id="자식-엔티티-조회에-조건이-걸린다면-FetchMode-SUBSELECT"><a href="#자식-엔티티-조회에-조건이-걸린다면-FetchMode-SUBSELECT" class="headerlink" title="자식 엔티티 조회에 조건이 걸린다면 - FetchMode.SUBSELECT"></a>자식 엔티티 조회에 조건이 걸린다면 - FetchMode.SUBSELECT</h4><p>JPQL을 직접 작성해 영속성 콘텍스트에서 데이터를 조회하는 시점에 조건문이 걸린다면 이와 같은 구현을 해볼만 하다. </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> m <span class="keyword">from</span> <span class="keyword">Master</span> m <span class="keyword">where</span> m.id &gt; <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>학생을 관리하는 리스트 필드에 @Fetch(FetchMode.SUBSELECT) 가 걸려있다면 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT</span><br><span class="line"><span class="keyword">WHERE</span> STUDENT.MASTER_ID <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">ID</span> <span class="keyword">FROM</span> <span class="keyword">MASTER</span></span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">ID</span> &gt; <span class="number">10</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>위와 같이 실행된다. </p>
<h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>N + 1과의 사투는 JPA 개발자라면 누구나 한번쯤 겪어보며 경험치를 올려야 할 이슈들 중에 하나다. </p>
<p>물론 이 글에서 나는 단편적으로 N + 1 문제만을 해결하는 방법 몇 가지에 대해서만 설명한 것이고 실제 MVC계층 구조를 갖는 Spring 환경에서 이 해결책들을 적용하려면 Lazy Initialization Exception 문제를 비롯해서 JPA 객체의 생명주기에 따른 다양한 문제점들이 파생되어 나올 것이다(DETACHED 상태에서 지연로딩이 발생하지 않는다는 것을 기억하자). </p>
<p>다음에 기회가 되면 이런 문제들에 대한 솔루션도 글로 정리해보고 싶다. </p>
<p>여튼, N + 1 문제를 해결하려면 다음 두 가지를 잘하자. </p>
<ul>
<li>어지간해선 지연 로딩을 사용하자(기본값이 즉시로딩인 경우에도 애노테이션을 통해 지연 로딩을 강제하자)</li>
<li>JOIN이 필요하다고 생각되는 시점에 인위적으로 JOIN을 걸어주자. </li>
</ul>
<p>끝. </p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/06/16/jpa-cartesian/" data-id="ckk5ihpr8000wdg9oy7t8b5v7" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/06/16/jpa-cartesian/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-database-transaction" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/database/">database</a>►<a class="article-category-link" href="/categories/database/mysql/">mysql</a>►<a class="article-category-link" href="/categories/database/mysql/jpa/">jpa</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/14/database-transaction/">데이터베이스 트랜잭션을 잘 알고싶다.</a>
    </h1>
  

        <a href="/2018/06/14/database-transaction/" class="article-date">
  <time datetime="2018-06-14T09:33:38.000Z" itemprop="datePublished">2018-06-14</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="데이터베이스-트랜잭션을-잘-알고싶다"><a href="#데이터베이스-트랜잭션을-잘-알고싶다" class="headerlink" title="데이터베이스 트랜잭션을 잘 알고싶다."></a>데이터베이스 트랜잭션을 잘 알고싶다.</h3><p>Git을 처음 배우던 시절 Git에 대한 오해들이 좀 있었는데, 그 중 하나는 <code>git commit</code> 과 <code>git push</code>를 혼동하던 것이었다. </p>
<p><strong>커밋만 하면 원격 저장소에 반영되었다고 생각한 적이 있었다.</strong> 이런 오해는 대형 참사를 불러왔다. 특히 노트북이 없어 학교 전산실에서 작업하고 깃에 올려놓고 집에서 또 작업하고 하던 시기였기 때문에 앗차 하고 컴퓨터를 다시 켜 봐도 데이터는 이미 롤백된 후였다. </p>
<p>시간이 흘러 데이터베이스 공부를 시작하는 시점이 됐다. 별 생각 없이 사용하던 <code>INSERT INTO</code>가 사실은 깃의 커밋에 불과한 일이란 것을 알게 됐다. </p>
<p>그치만 데이터가 다행히도 전부 살아있었던 것은 MySQL이 <em>기본값으로 오토 커밋을 지원하기 때문</em> 이라는 소름돋는 사실을 알게됐다. </p>
<p><strong>트랜잭션과 커밋</strong> </p>
<p>트랜잭션은 데이터베이스에 변경 사항을 반영하는 행위, 혹은 행위의 집합을 일컫는다(실제 정의는 다를 수 있겠다. 하지만 나는 이렇게 이해해보려고 한다). </p>
<p>데이터베이스의 트랜잭션은 아래의 네 가지 속성을 만족시켜야 한다. </p>
<ul>
<li><p>A - Atomicity(원자성)</p>
<ul>
<li>각 트랜잭션은 시작부터 끝까지 결과를 보장해야 하며 중도에 간섭이나 장애가 발생해서는 안된다. </li>
<li>e.g. 은행 거래 - 입금 트랜잭션이 발생하려면 내 계좌에서 돈을 까고 상대 계좌에 잔액을 더하는 일련의 과정이 한번에 성공해야 한다. </li>
<li>입금 트랜잭션에 문제가 발생할 것 같으면 <strong>내 계좌에 있는 돈을 차라리 까지 말고 모든 거래 과정이 모두 실패해야만 한다.</strong> </li>
</ul>
</li>
<li><p>C - Consistency(일관성)</p>
<ul>
<li>데이터베이스가 원래 갖고 있는 제약 조건과 트랜잭션은 일관되게 유지돼야 한다. </li>
<li>잔액이 음수가 될 수 없다는 제약 조건이 있다면, 잔고보다 많은 송금 요청이 들어온다면 그 트랜잭션은 무효 처리 돼야 할 것이다. </li>
</ul>
</li>
<li><p>I - Isolation(고립성)</p>
<ul>
<li>트랜잭션은 다른 트랜잭션에 종속적이거나 영향을 받으면 아니 된다. </li>
</ul>
</li>
<li><p>D - Durability(내구성)</p>
<ul>
<li>트랜잭션은 한 번 데이터베이스에 반영되면 그 내용이 손실되어서는 안 된다. </li>
</ul>
</li>
</ul>
<p>위 조건을 충족하는 건강한 트랜잭션이 시작됐다면 해당 트랜잭션은 <em>커밋되거나 롤백</em> 돼야 한다. </p>
<ul>
<li>COMMIT : 데이터베이스에 해당 트랜잭션을 반영함. </li>
<li>ROLLBACK: 반영하지 아니함. </li>
</ul>
<p><strong>고립 수준</strong> </p>
<p>thread-safe 문제와 비슷한 상황이 데이터베이스에서도 연출될 수 있다. 데이터베이스는 당연히 다중 접근 시나리오를 상정하고 설계해야 한다. 내가 만들어놓고 나만 쓰고 읽을 거라면 그냥 일기장에 쓰지 굳이 데이터베이스를 운영할 이유가 있을까? 데이터베이스는 많은 사용자가 한번에 쓰고 한번에 읽을 것을 계산에 넣고 만들었기 때문에 <strong>한 시점에 한 데이터를 읽거나 쓰는 동작에 대한 대처</strong> 가 당연히 설정돼있어야 한다. </p>
<p>트랜잭션이라는 개념이 생긴 것도 그런 까닭이다. 데이터베이스에 접근하는 시도가 모두 트랜잭션의 기준에 맞을 리도 없고, 또 데이터를 쓰는 중에 오류나 손실이 발생할 수도 있기 때문에 트랜잭션 커밋이라는 안전장치를 둬서 네가 반영한 변경 사항이 정말 의도와 맞는지를 체크하게 만들어 놨다. </p>
<p>문제는 <strong>트랜잭션이 커밋, 혹은 롤백 되기 이전에 같은 데이터를 읽는 동작에 대한 처리</strong> 일 것인데 이를 고립 수준 설정으로 해결하고 있다. </p>
<p>또 이 설정에 따라 세 가지의 현상이 발생할 수 있는데 이것을 dirty read, non-repeatable read, phantom read라고 칭한다. 이에 대한 각각의 설명은 후술하기로 하고 일단 이것들을 D, R, P로 칭하겠다. </p>
<ul>
<li><p>READ UNCOMMITTED - 커밋되지 않은 변경 읽음 </p>
<ul>
<li>커밋하지 않은 상태여도 변경사항을 읽어들일 수 있다. </li>
<li>언뜻 보면 투명하니 좋아보이지만 만약 상대가 트랜잭션을 롤백한다면 잘못된 데이터를 읽어들인 셈이 된다. </li>
<li>D, R, P</li>
</ul>
</li>
<li><p>READ COMMITTED - 커밋되면 읽음 </p>
<ul>
<li>커밋하지 않은 트랜잭션은 가리고, 커밋한 트랜잭션만 읽어들인다. </li>
<li>반영되지 않을 트랜잭션을 읽어들이지 않는다는 장점은 있지만, 데이터를 삭제하는 커밋이 발생할 경우, 처음 조회된 데이터를 영영 찾을 수 없을 것이다. </li>
<li>R, P</li>
</ul>
</li>
<li><p>Repeatable Read - 데이터 반복 조회 </p>
<ul>
<li>같은 트랜잭션 내에서 한번 더 조회가 발생해도 원래 있던 데이터를 읽어들인다. </li>
<li>P</li>
</ul>
</li>
<li><p>Serializable </p>
</li>
</ul>
<p><strong>Dirty Read, Non-Repeatable Read, Phantom Read</strong> </p>
<p>격리 수준과 그에 따른 현상들을 설명해본다. </p>
<ul>
<li>Dirty Read - 말 그대로다. 더러운 것을 읽는다. </li>
</ul>
<p>Read Uncommitted 상태에서만 발생한다. 커밋되지 않은 트랜잭션을 들여다볼 수 있기 때문에 <strong>반영되지 않을 데이터가 조회되는 문제점이 생기는 것이다.</strong> 데이터를 갖다 쓰는데 실제로 반영되지 않을 데이터였다면 문제가 발생할 것이다. </p>
<p>이를 방지하기 위해 대부분의 DBMS에서는 <strong>Read Committed를 기본값으로 둔다.</strong> </p>
<ul>
<li>Non-Repeatable Read - 돌아올 수 없는 다리 </li>
</ul>
<p>한 번 읽어들인 데이터가 다른 트랜잭션 세션에서의 DROP으로 인해 unreachable 상태로 접어드는 것을 말한다. </p>
<p>커밋된 트랜잭션만 읽어들인다 해도 데이터 자체가 날라가버리면 이 현상을 피할 길이 없다. </p>
<ul>
<li>Phantom Read - 데이터베이스의 유령</li>
</ul>
<p>트랜잭션이 끝나지 않은 상태에서 조회된 데이터에 대해, 다른 세션의 트랜잭션을 통해 데이터가 추가된다면, 다음 질의에서는 그 데이터가 나타나게 된다. </p>
<p>이 상황에서 작업을 잘 하다가 만약 다른 세션의 트랜잭션이 롤백된다면 데이터는 망한다. </p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/06/14/database-transaction/" data-id="ckk5ihpqm000bdg9o43v3s72p" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/06/14/database-transaction/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jpa-questions" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/jpa/">jpa</a>►<a class="article-category-link" href="/categories/java/jpa/tech-interview/">tech_interview</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/09/jpa-questions/">JPA에 관한 질문들</a>
    </h1>
  

        <a href="/2018/06/09/jpa-questions/" class="article-date">
  <time datetime="2018-06-09T10:31:55.000Z" itemprop="datePublished">2018-06-09</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="JPA에-관한-질문들"><a href="#JPA에-관한-질문들" class="headerlink" title="JPA에 관한 질문들"></a>JPA에 관한 질문들</h3><ul>
<li>프로젝트에 JPA를 사용하셨는데 다른 사람의 리포지토리를 보면 아시겠지만 MyBatis를 사용한 경우가 많았다. MyBatis를 사용하지 않은 이유는? JPA가 갖는 이점은?</li>
</ul>
<p>우선 저밖에 JPA를 사용하지 않은 것 같아 조금 당황스럽기도 했다. 그러나 주니어 개발자가 가장 많이 성장하고 많은 것을 배울 수 있는 건 JPA를 학습하는 일이라고 생각한다. </p>
<p>먼저 JPA를 통해 웹 애플리케이션을 설계하다보면 <strong>자연스레 객체지향적 설계에 대해 고민하게 된다.</strong> 어떻게 하면 JPA를 JPA답게 사용할까 고민하고 공부하는 그 자체가 <strong>객체지향 프로그래밍에 도움이 된다.</strong> </p>
<p>MyBatis는 ORM이 <strong>아니다.</strong> 물론 쿼리와 로직을 분리해낼 수 있는 템플릿 역할을 수행해주긴 하지만 도메인 객체의 설계가 바뀔 때마다 복잡한 설정의 변경 과정이 수반되어야 한다. 결국 쿼리를 미리 짜놓고 객체를 설계하는, 프로그램의 전체적인 개발 과정이 <strong>쿼리에 강하게 종속되는 문제를 절대 해결할 수 없다.</strong> JPA는 그런 부담감에서 개발자를 해결시켜주기 때문에 쿼리를 미리 생각해놓고 객체를 설계하는, 객체 지향이 아닌 쿼리 지향 프로그래밍을 해야하는 상황을 막아준다. </p>
<ul>
<li><p><em>꼬리질문: JPA가 객체지향적 사고에 도움이 된다고 했는데, JPA를 통한 객체지향적 설계를 가능케 해주는 기능들에 대해 설명해 보아라.</em></p>
<ul>
<li><strong>도메인 객체간에 상속관계를 설정할 수 있다.</strong> <code>@MappedSuperclass</code> 나 <code>@Inheritance</code> 애노테이션을 사용할 수 있고, 이런 상속 관계를 테이블에 매핑하는데 있어 TABLE_PER_CLASS나 JOINED 와 같은 전략을 설정할 수도 있다. </li>
<li>도메인 객체의 속성을 별도의 값 타입으로 분리해낼 수 있다. <code>@Embedded</code> 와 <code>@Embeddable</code> 을 통해 가능해지는 것이다. 이번에 핵데이를 참가하며 영속성 관리를 위해 마이바티스를 사용한 참가자들을 보니 대부분의 도메인 객체 필드들이 String 아니면 Integer였다. 그룹지어 객체 단위로 관리할 수 있는 속성들이 있음에도 마이바티스로 매핑해줘야 하는 부담이 있어 별도의 객체로 빼지 않은 것이다. </li>
<li><code>@Embeddable</code> 객체를 선언하면 JPA는 이를 별도의 테이블로 관리한다. PK는 없고, 자신을 갖고 있는 객체의 ID를 조인컬럼으로 관리하게 된다. </li>
</ul>
</li>
<li><p>JPA가 데이터를 저장하고 조회하는 과정을 논해 보세요. </p>
</li>
</ul>
<p>Spring Data JPA의 규약에 따라 개발자는 repository 인터페이스를 선언한다. 선언된 리포지토리 인터페이스는 런타임 시에 Spring 의 ApplicationContext에 의해서 프록시 객체로 구현되어 스프링 빈으로 관리되게 된다. </p>
<p>개발자는 <code>@Service</code> 나 <code>@Controller</code> 어디에서도 리포지토리를 호출할 수 있지만 베스트 프랙티스는 서비스 클래스에서 리포지토리를 호출하는 것이다. </p>
<p>repository bean에 정의된 메소드가 호출되면 영속성 콘텍스트가 만들어진다. 영속성 콘텍스트는 요청 1개(스레드 1개)에 하나씩 만들어지고 한번 쓰면 <strong>내다버린다.</strong> 1회용이다. </p>
<ul>
<li><em>꼬리질문: 한번 쓰고 내다버리면 오버헤드가 너무 큰 것 아닌가? 연산 비용이 너무 많이 소요될 거 같은데?</em><ul>
<li>그에 대한 고려를 해 Spring Data JPA에서는 EntityManagerFactory라는 객체를 두고 있다. </li>
<li>공장을 세우는 건 비용이 많이 들지만 공장에서 제품을 찍어내는 것은 비용이 그리 많이 들지 않는다. </li>
</ul>
</li>
</ul>
<p>영속성 콘텍스트가 요청을 접수한다. 영속성 콘텍스트는 영속성 콘텍스트 공장으로부터 전달받은 datasource를 통해 DB에 객체 정보를 질의하고, ResultSet이 돌아오면 갖고 있던 객체 정보를 통해 객체를 생성해 돌려준다. <strong>유념할 것은 이 객체는 새로 만들어진 객체라는 점이다.</strong> 이 때 객체의 상태는 detached 상태다. </p>
<ul>
<li><em>꼬리질문: 객체의 상태란 무슨 말인가? detached라면 어디서 떨어졌다는 말인지?</em><ul>
<li>영속성 콘텍스트의 세션에서 분리되었다는 말이다. </li>
<li>JPA에서 도메인 객체는 세 가지 상태를 갖는다 : MANAGED, DETACHED, TRANSIENT이다. </li>
<li>TRANSIENT는 아직 저장되지 않은 신삥 객체이므로 신경쓸게 별로 없지만 JPA를 처음 학습할 때 가장 구분하기 어려운 개념이 MANAGED와 DETACHED이다. </li>
<li>MANAGED 객체는 영속성 콘텍스트가 접수한 객체이며 <em>지금 관리중인 객체</em> 이다. 이 객체에 대해선 dirty check나 lazy fetch와 같은 영속성 콘텍스트가 제공해주는 편의 기능을 모두 사용할 수 있다. </li>
<li>DETACHED 객체는 영속성 콘텍스트가 <strong>접수한 적은 있지만 지금 관리하고 있지는 않은 객체</strong> 이다. 이 객체에 대해서는 JPA가 제공해주는 편의 기능을 하나도 사용할 수 없음에 유의해야 한다. 만약 이 객체가 관리하고 있는 field 중 lazy fetch하는 필드가 있다면 detached 상태에서는 어떠한 수를 써서도 이 필드를 가져올 수 없다. </li>
</ul>
</li>
</ul>
<p>조회에 대해서는 그렇게 혼동되는 개념이 없는데 저장은 조금 헷갈리는 개념 있을 수 있다. 가장 헷갈리는 개념은 <code>EntityManager.persist()</code> 가 호출된다고 해서 바로 데이터가 DB에 작성되는 것이 아니다. </p>
<p>JPA 환경에서 모든 쿼리는 쓰기 지연 저장소에 저장된다. 모든 쿼리를 저장해놨다가 <code>EntityManager.flush()</code> 가 호출되거나 모종의 사유로 엔티티 매니저 즉 영속성 콘텍스트가 문을 닫으면 그때 비로소 DB에 컨택해 트랜잭션을 시작하는 것이다. </p>
<ul>
<li><p><em>꼬리질문: 그러면 Spring Data JPA에서 영속성 콘텍스트는 언제 열리고 언제 닫히나?</em> </p>
<ul>
<li>기본적으로 Spring Data JPA에서는 트랜잭션을 repository bean 안으로 고립시켜놓고 사용한다. </li>
<li>이렇게 하면 영속성 콘텍스트에 대해 학습이 부족한 개발자들도 영속성 콘텍스트를 마치 JCF 다루듯이 편하게 쓸 수 있고, 쓰기 지연 등 JPA의 특성에 대한 이해가 없어도 쉽게 사용할 수 있을 것 같다.</li>
<li>그러나 JPA에 대한 이해를 갖춘 상태에서 이렇게 트랜잭션을 고립시키는 것은 옳지 않을 수도 있다. </li>
<li>가장 흔히 쓰이는 방법은 서비스 클래스에 repository를 주입받고 이 repository를 사용하는 메소드에 대해 <code>@Transactional</code> 애노테이션을 붙여주는 것이다. </li>
<li>이렇게 되면 서비스 빈이 Spring AOP에 의해 트랜잭션 부가 기능이 추가되어 트랜잭션의 범위가 리포지토리를 침범해 메소드 전역으로 확대되게 된다. </li>
<li>이 메소드 안에서 <code>repository.findById()</code> 등을 불러 객체를 조회하게 되면 이 객체는 DETACHED가 아닌 MANAGED 상태가 된다. </li>
<li>이 객체가 return되어 메소드의 실행이 종료되기 전까지 JPA가 제공하는 쓰기지연, dirty check와 같은 부가 기능들을 그대로 사용할 수 있고 lazy fetch의 이점도 누릴 수 있다. </li>
</ul>
</li>
<li><p><em>꼬리질문: Transaction이 지연되어 실행된다고 했는데 그러면 내부적으로 dirty read와 같은 현상이 재현되는 것 아닌가?</em></p>
<ul>
<li>그렇지 않다. 왜냐하면 JPA는 객체를 조회할때도 먼저 DB에 질의하는 것이 아니라 자신이 보관하고 있는 객체 스냅샷 저장소를 먼저 들여다보기 때문이다. </li>
<li>영속성 콘텍스트 공장에서는 JPA가 관리할 객체 (@Entity가 선언된 모든 객체)를 분석한 후 각 객체마다 하니씩 해시테이블의 형태로 객체를 보관할 수 있는 스냅샷 저장소를 만든다. </li>
<li>이 저장소에는 영속성 콘텍스트가 열려있는 동안 저장되거나 잘의된 모든 객체들이 들어있다. </li>
<li>따라서 특정 객체에 대한 요청이 들어오면 이 저장소에 만약 같은 PK나 @Id를 갖는 객체가 들어온다면, 이미 변경된 상태의 객체가 리턴되기 때문에 dirty read의 가능성은 없다. </li>
<li>그리고 한 메소드 안에서 수정과 조회를 같이 수행할 일이 거의 없다. 어차피 영속성 콘텍스트는 자신이 죽을 때 Transaction을 모두 수행하기 때문에 새롭게 메소드에 진입한다거나 하는 경우에는 전혀 해당사항이 없다. </li>
</ul>
</li>
</ul>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/06/09/jpa-questions/" data-id="ckk5ihpxc008rdg9o1hentnnl" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/06/09/jpa-questions/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-operating-systems-questions" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/operating-system/">operating_system</a>►<a class="article-category-link" href="/categories/operating-system/tech-interview/">tech_interview</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/09/operating-systems-questions/">운영체제에 관한 질문들</a>
    </h1>
  

        <a href="/2018/06/09/operating-systems-questions/" class="article-date">
  <time datetime="2018-06-09T08:50:36.000Z" itemprop="datePublished">2018-06-09</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="운영체제에-관한-질문들"><a href="#운영체제에-관한-질문들" class="headerlink" title="운영체제에 관한 질문들"></a>운영체제에 관한 질문들</h3><ul>
<li>동기와 비동기의 차이점에 대해 말해 보세요.</li>
</ul>
<p>synchronous와 asynchronous의 차이는 “반환값의 기대” 에서 발생한다고 생각합니다. system call이 발생했을 때 리턴값이 돌아올 때까지 기다리면 동기, 리턴값이 돌아올 때까지 기다리지 않고 리턴 값이 만들어졌을 때에 수행할 로직을 참조로써 전달(콜백) 하면 비동기이다. </p>
<p>동기와 비동기는 각각 blocking, non-blocking일 수도 있다. synchronous non-blocking일 수도 있다(event-driven). 대표적인 사례로 node.js를 꼽을 수 있겠다.</p>
<ul>
<li></li>
</ul>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/06/09/operating-systems-questions/" data-id="ckk5ihps3001wdg9odrp6yevy" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/06/09/operating-systems-questions/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-algorithm-ds-questions" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/data-structure/">data_structure</a>►<a class="article-category-link" href="/categories/data-structure/algorithm/">algorithm</a>►<a class="article-category-link" href="/categories/data-structure/algorithm/tech-interview/">tech_interview</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/08/algorithm-ds-questions/">자료구조와 알고리즘에 관한 질문들</a>
    </h1>
  

        <a href="/2018/06/08/algorithm-ds-questions/" class="article-date">
  <time datetime="2018-06-08T00:28:21.000Z" itemprop="datePublished">2018-06-08</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="자료구조와-알고리즘에-관한-질문들"><a href="#자료구조와-알고리즘에-관한-질문들" class="headerlink" title="자료구조와 알고리즘에 관한 질문들"></a>자료구조와 알고리즘에 관한 질문들</h3><ul>
<li>소트 종류 아는대로 설명하시고, 좋아하는 소트가 있습니까? 설명하고 손코딩 한번 해 봐라. </li>
</ul>
<p>선형 소트와 비선형 소트로 나눠서 설명드려야 할 것 같다. 선형 소트는 시간 복잡도가 O(n) 에서 O(n^2)에 이르는 소트로써 원소를 하나 하나 비교하거나 순회한 후 다시 정렬하는 과정이기 때문에, 발상 자체는 간단하지만 시간 복잡도에서 손해를 크게 본다. </p>
<p>흔한 예로 버블 소트와 선택 소트(selection sort)를 들 수 있을 것 같다. </p>
<p>버블 소트는 n번째 원소와 n + 1번째 원소를 비교한 후 작은 것을 앞으로 오게 자리를 바꾸는 것이다. 원소의 숫자만큼 작업을 수행해야 하기 때문에 O(n!)의 시간복잡도가 발생한다. </p>
<p>선택 소트는 리스트의 크기를 하나씩 줄여나가면서 해당 리스트 안에서 가장 작은 원소를 가장 앞으로 빼는 정렬이다. O(n^2)가 발생한다. </p>
<p>소트에서 시간복잡도를 줄이려면 비선형 소트를 사용하는 것밖에 방법이 없다. 이른바 3대 소트라고 공부하기도 하는데 퀵소트, 머지소트, 힙소트가 꼽힌다. 셋 다 O(log n)의 시간복잡도를 갖는다. </p>
<p>제가 가장 좋아하는 퀵소트부터 설명드리면 우선 리스트에서 pivot 값을 고른 후에 리스트의 원소들을 비교하며 계속 재귀호출해 값을 정렬하는 것이다. 다만 이 때 pivot 값이 비효율적으로 설정되면 시간복잡도는 N^2 까지 치솟을 수도 있다. </p>
<p>제가 제일 좋아하는 소트니까 간단하게 손코딩을 보여드리겠다. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick</span><span class="params">(array)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">    pivot = array[len(array) // <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    less = []</span><br><span class="line">    more = []</span><br><span class="line">    equal = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> array:</span><br><span class="line">        <span class="keyword">if</span> number &gt; pivot: </span><br><span class="line">            more.append(number)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> number &lt; pivot:</span><br><span class="line">            less.append(number)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        equal.append(number)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quick(less) + quick(equal) + quick(more)</span><br></pre></td></tr></table></figure>
<p><em>VS Code에서 짰으니까 손코딩이나 진배없다.</em> </p>
<ul>
<li>검색 종류 아는대로 말씀해 보시고, 좋아하는 검색이 있습니까? 설명하고 손코딩 한 번 해봐라. </li>
</ul>
<p>검색도 마찬가지로 선형과 비선형으로 나눌 수 있겠다. 선형 검색은 O(n)의 시간복잡도가 발생한다. </p>
<p>가장 단순하게 생각할 수 있는 방식은 이런 것일 것 같다. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(array, n)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range len(array):</span><br><span class="line">        <span class="keyword">if</span> array[i] == n:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>한번씩 다 순회하는 방법인데 그리 효율적이지는 않다. 제가 좋아하는 검색은 이진 검색이다. </p>
<p>이진 검색은 퀵소트와 메카니즘이 참 비슷한데 중위값을 정해놓은 다음 목표값이 중위값보다 크면 중위값의 오른쪽 원소들로 검색 범위를 한정해서 다시 재귀 호출하고, 만약 작으면 왼쪽 원소들로 한정해서 똑같이 하는 것이다. </p>
<p>눈치채셨겠지만 이진 검색의 가장 큰 전제조건은 <strong>리스트가 정렬돼있다</strong> 는 것이다. 정렬되지 않은 리스트에서는 이진 검색을 사용할 수 없다. </p>
<p>만약 운이 정말 좋아 타겟값과 중위값이 일치한다면 시간복잡도는 O(1) 로도 빠질 수 있다. 그러나 말 그대로 이건 운이 좋은 경우고 평균적으로 O(log N)의 복잡도가 발생한다. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary</span><span class="params">(array, target, start, end)</span>:</span></span><br><span class="line">    </span><br><span class="line">    middle_index = (start + end) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> middle_index &lt; start <span class="keyword">or</span> middle_index &gt; end:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> array[middle_index] == target:</span><br><span class="line">        <span class="keyword">return</span> middle_index</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> target &gt; array[middle_index]:</span><br><span class="line">        <span class="keyword">return</span> binary(array, target, middle_index, end)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> target &lt; array[middle_index]:</span><br><span class="line">        <span class="keyword">return</span> binary(array, target, start, middle_index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><em>당신은 자바 Backend 직무를 수행하게 될 것이다. Python으로 손코딩한 이유는?</em> </p>
<ul>
<li>저는 자바를 무척 좋아하고 사랑한다. 제가 개발을 시작한 언어이기도 하고 가장 자신있는 언어이기도 하다. </li>
<li>손코딩 중 다른 언어를 사용해 죄송합니다만 저는 그동안 자료구조 / 알고리즘 학습이나 예제 구현에 있어 Python 언어를 즐겨 사용해왔다. 가장 큰 이유는 <strong>Main 메소드가 없어도 되고</strong>, 두번째 이유는 <strong>클래스 바깥에서 함수를 선언할 수 있어 알고리즘 작성에 효율성이 좋았기 때문이다.</strong></li>
<li>제가 아는 만큼 정확하고 빠르게 보여드리기 위해 보일러플레이트를 최대한 소거시킨 Python 코드를 보여드린 것이다. 개념 이해가 중요하다고 생각했다. </li>
</ul>
</li>
<li><p><em>이진 탐색과 이진 탐색 트리가 이름이 비슷한 것 같은데 트리는 뭐가 달라요?</em> </p>
<ul>
<li>이진 탐색 트리란 이진 트리를 기반으로 구현한 것이다. </li>
<li>처음 입력되는 값을 부모로 하고, 작으면 왼쪽 크면 오른쪽 자식으로 놓는다. </li>
<li>이런 식으로 데이터를 정렬한 후, 트리를 중위 순회하면 값을 오름차순으로 정렬할 수 있다. </li>
</ul>
</li>
<li><p><em>중위 순회는 뭔가요? 순회가 뭐죠?</em> </p>
<ul>
<li>순회는 트리 자료 구조를 탐색하며 데이터를 조회하는 순서에 관한 방법론이다. </li>
<li>전위 순회: 부모부터 시작해 왼쪽 자식을 주욱 조회한 다음, 오른쪽 자식을 조회한다. </li>
<li>중위 순회: 왼쪽 - 부모 - 오른쪽 순서로 순회한다. </li>
<li>후위 순회: 왼쪽 - 오른쪽 - 부모 순으로 순회한다. </li>
</ul>
</li>
</ul>
<ul>
<li>해시의 개념에 대해 설명해 보세요.</li>
</ul>
<p>해시는 데이터를 정수 형태의 코드로 바꾸는 것이다. 데이터를 이렇게 바꿔주는 함수를 해시 함수라고 칭한다. </p>
<p>해시 함수는 나름의 알고리즘을 사용해서 데이터를 정수로 바꾸는데 모듈러(modulo) 연산이 가장 흔하고 간단한 예시일 것 같다. 데이터가 갖고 있는 필드 값 중 하나를 모듈러 연산 수행해서 그 나머지를 해시코드로 삼는 것이다. </p>
<p>같은 데이터가 같은 해시함수를 거친다면 항상 같은 결과가 보장돼야 하지만, 해시코드가 같다고 해서 해당 객체의 동등성까지 보장할 순 없다. 서로 다른 객체가 같은 해시코드를 갖게되는 것을 해시 충돌(hash collision) 이라고 부른다. 해시 코드를 인덱스로 삼아 객체를 저장하는 해시테이블에서 이와 같은 해시 충돌은 큰 제약 사항이 될 수도 있다.</p>
<p>해시 충돌을 해결하는 방법에는 크게 두 갈래가 있다. </p>
<ul>
<li>Open Addressing</li>
<li>Chaining</li>
</ul>
<p>먼저 오픈 어드레싱이란 원래 충돌이 발생했던 위치로부터 정해진 규칙에 따라 이동해서 새로운 인덱스에 객체를 보관하는 것이다. 여기엔 또 세 가지 기법이 있다. </p>
<ul>
<li>linear probing: 선형 프로빙. n 번째 인덱스에서 해시 충돌이 발생했다면 n + 1, n + 2 순서대로 계속 빈 자리를 찾아 헤매는 것이다. </li>
<li>quadratic probing: 지수함수의 형태로 인덱스를 탐색한다. </li>
<li>double hashing: 해시 충돌이 발생하면 다른 해시함수를 한번 더 돌린다. </li>
</ul>
<p>chaining이란 충돌이 발생한 인덱스에 링크드리스트와 같은 다른 자료구조를 적용해 같은 자리에 여러개의 값을 보관하는 것이다. </p>
<p>Open Addressing법의 단점은 최초 충돌이 발생한 위치의 데이터가 더이상 필요없게 되어도 계속 <strong>그 자리를 잡고 저장돼있어야 한다는 점</strong>이다. 만약 데이터가 필요없게 되었다고 그냥 메모리에서 해제하면 이 데이터를 기준으로 저장된 충돌이 발생한 다른 데이터들로 탐색을 수행할 수가 없다. entry point가 사라지는 것이다. </p>
<p>chaining법은 이런 문제는 없지만 해당 인덱스에 부가적인 자료구조가 더해지므로 공간 복잡도가 올라가는 단점이 있다. </p>
<p>오픈어드레싱, 체이닝 둘 다 시간복잡도는 O(n) 이다. </p>
<p><code>java.util.HashMap</code>은 체이닝을 사용한다.         </p>
<ul>
<li>링크드리스트와 배열의 차이에 대해 말씀해보세요. </li>
</ul>
<p>배열은 대표적인 선형 자료구조이다. 메모리에서 연속된 공간이 배열의 크기만큼 확보되어야 한다. 이는 데이터의 실제 존재 유무와는 무관하다. 때문에 인덱스를 알고 특정 데이터를 조회하는 작업의 시간 복잡도는 O(1)이다. 해당 인덱스에 바로 접근할 수 있기 때문이다. </p>
<p>그 대신 배열 요소의 삽입 / 삭제에는 큰 비용이 든다. 중간에 새로운 값이 들어왔다면 그 뒤의 원소들의 인덱스가 모두 수정돼야 한다. 삭제도 마찬가지다. 따라서 이런 작업들은 O(n) 의 복잡도가 소요된다. </p>
<p>한 번 값을 쓰고나면 크게 수정할 일이 없고, 인덱스값을 기준으로 객체를 조회할 일이 많을 때 적합한 자료구조이다. </p>
<p>링크드리스트는 원소가 다음 원소로 가는 참조를 보관한다. 뒤로만 보관하고 있으면 싱글 링크드리스트, 앞뒤로 다 보관하고 있으면 더블 링크드리스트이다. 더블 링크드리스트로는 뎈(deque)과 같은 원형 자료구조를 구현할 수 있다. </p>
<p>링크드리스트는 자료가 중간에 삽입되더라도 참조만 바꿔주면 되므로 O(1) 을 유지할 수 있다. 빈번한 삽입 삭제가 필요한 경우엔 링크드리스트를 사용해야 한다. </p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/06/08/algorithm-ds-questions/" data-id="ckk5ihpx2008idg9o46pg6vo5" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/06/08/algorithm-ds-questions/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-http-questions" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/tech-interview/">tech_interview</a>►<a class="article-category-link" href="/categories/tech-interview/http/">http</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/07/http-questions/">HTTP와 네트워크에 관한 질문들</a>
    </h1>
  

        <a href="/2018/06/07/http-questions/" class="article-date">
  <time datetime="2018-06-07T03:35:16.000Z" itemprop="datePublished">2018-06-07</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="HTTP에-관한-질문들"><a href="#HTTP에-관한-질문들" class="headerlink" title="HTTP에 관한 질문들"></a>HTTP에 관한 질문들</h3><ul>
<li>웹브라우저에 주소를 입력하고 화면이 뜨기까지의 과정을 설명해보세요. </li>
</ul>
<p>웹브라우저에 주소를 입력하면 우선 도메인 이름을 resolve해야 한다. </p>
<p>도메인 네임은 각 시스템마다 입력되어 있는 DNS 서버에 질의하는 방식으로 이뤄진다. 대부분의 경우 각 ISP가 제공해주는 DNS를 사용하고 있고 저 개인적으론 프라이버시에 관심이 많아 8.8.8.8 이라는 외국 사설 DNS를 사용하고 있다. 국내 DNS 서버들이 DPI 등 패킷 수준 감청에 활용되고 있다는 느낌을 받기 때문이다. </p>
<p>DNS는 자신이 갖고 있는 레코드와 질의 내용을 비교해본 후 자신이 갖고 있지 않은 정보라면 요청을 TLD 네임서버로 보낸다. TLD란 Top level Domain으로 <em>.ac.kr, </em>.com 과 같은 주소를 관리하는 서버들이다. </p>
<p>TLD로 질의가 올라간다고 해서 바로 답변을 얻을 수 있는 것은 아니고, 해당 도메인 대역에 대한 정보를 얻을 수 있는 NS로 다시 연결시켜준다. NS에서 마지막으로 도메인 이름을 IP주소로 바꿔주거나, CNAME 레코드인 경우 다시 도메인을 찾을 수 있도록 요청을 바꿔준다. </p>
<ul>
<li><em>CNAME이 뭔가? 도메인에도 종류가 있는 건가?</em><ul>
<li>도메인의 레코드에도 몇 가지 종류가 있다. </li>
<li>가장 기본적인 것은 A Record로 해당 도메인과 서버의 IP 주소가 바로 매치되는 것이다. </li>
<li>이외에도 CNAME이 있다. CNAME은 Canonical Name으로 원본 레코드 주소의 별칭 같은 것이다. 이때 원본 레코드는 IP주소이면 안되고 스킴 부분을 제외한 URL, 즉 순수 도메인 네임의 형태여야 한다.</li>
<li>MX 레코드는 메일 서버의 메일 주소 등록을 위해 사용한다. </li>
</ul>
</li>
</ul>
<p>일단 도메인 네임을 리졸브하고 나서 얻은 호스트 주소로 TCP 커넥션을 오픈하면(L4) 본격적인 데이터 교환이 시작된다. 브라우저가 보낸 GET 요청은 먼저 호스트측의 웹 서버에 닿을 것이다. </p>
<p>웹 서버는 GET 요청의 헤더를 차근차근 살펴본다. Host 헤더를 기준으로 요청을 역방향 프록시하는 경우가 많다. </p>
<ul>
<li><em>Host 헤더란 어떤 것인가? 역방향 프록시는 또 뭔 소린가?</em> <ul>
<li>Host 헤더는 HTTP 1.1의 표준으로 채택된 <strong>요청 측 헤더</strong> 의 한 종류다. </li>
<li>HTTP 1.0 까지는 Host 헤더가 부재했고, 일단 DNS를 통해 호스트의 주소를 밝혀내고 나면 이 요청이 어떤 주소를 향하고 있었는지를 알 방법이 없었다. referer 등의 헤더로 우회 구현할 수는 있었지만 부족한 경우가 많았다. </li>
<li>이 경우 req header의 URI 부분밖에 알 수가 없다(e.g. /home/user). HTTP 1.0 시대에는 이런 부족함이 문제가 안 됐을 수도 있다. </li>
<li>그러나 한 서버에서 여러 웹 서비스를 호스팅하는 <strong>가상 호스팅</strong> 이 보편화되면서 이 부족함은 큰 불편함이 됐고 따라서 다음 표준에서 Host 헤더가 도입된 것이다. </li>
<li>Nginx를 기준으로 말씀드리면 server block을 정의할 때 명시하는 <code>server_name</code> 값이 이 Host 헤더의 내용과 비교되는 것이다. </li>
<li>역방향 프록시란 이렇게 요청이 웹 서버까지 다 도달한 다음에야 다음 행선지로 요청이 넘어가는 방식을 말하는 것이다. 원래 네트워크에서 프록시란 클라이언트 측이 모든 요청을 특정한 행선지를 한 번 거쳐서 처리하게 설정하는 것을 말한다. 즉 지금 나가는 요청이 어디를 거쳐야하는지 클라이언트측에서 설정해야 하는 것이다. 이를 <strong>정방향 프록시</strong> 혹은 그냥 프록시라고 말한다. 그냥 프록시라고 많이 말하는 것 같다. </li>
<li>그러나 이런 구현을 클라이언트 측에서는 모르게 하고 호스트의 웹 서버에 도달해서야 호스트 웹 서버가 프록시처럼 작동하는 일을 역방향 프록시라고 칭한다. </li>
</ul>
</li>
</ul>
<p>요청이 이제 웹 서버의 역방향 프록시를 거쳐 웹 애플리케이션 서버에 도달했다. 만약 요청이 정적 자원이라면 웹 서버가 해당 자원을 리스폰스하고 요청이 종료될 것이다. </p>
<ul>
<li><em>정적 자원이란?</em><ul>
<li>말 그대로 바뀌지 않는 자원, 즉 파일을 말한다. 첨부파일이나 그림 파일, 간단한 텍스트 등등…. </li>
<li>제 프로젝트에서도 Nginx의 정적 호스팅 기능을 사용하였다. 단순한 첨부파일 조회, 이미지 파일 조회 등의 기능을 WAS로 넘기지 않고 Nginx단에서 처리함으로써 서비스의 부하를 줄이고 응답 속도를 빠르게 하고자 했다. </li>
<li>정적 자원 외에 동적 페이지, dynamic page가 있을 수 있다. 요청에 따라 응답 내용이 계속 바뀌어야 하는 경우엔 정적 호스팅으로 불충분하며 웹 애플리케이션 서버가 처리해줘야 한다. </li>
</ul>
</li>
</ul>
<p>만약 요청이 동적 응답을 요구한다면 앞서 말씀드린 역방향 프록시를 통해 웹 애플리케이션으로 요청을 전달해야 한다(L7). 애플리케이션은 요청을 열어보고 필요한 작업을 수행한 뒤 응답한다. 응답은 요청의 역순이다. </p>
<p>웹 브라우저는 돌려받은 HTML, CSS 등 파일을 한 줄 한 줄 열어보고 Gecko와 같은 레이아웃 엔진을 통해 화면을 그려낸다. </p>
<ul>
<li>HTTP method 아는대로 설명해보세요. </li>
</ul>
<p>GET, POST, PUT, PATCH, OPTIONS, DELETE….. </p>
<p>요청 헤더의 첫 줄, 가장 앞 칸에 HTTP 메소드가 명시된다. (GET /user/info)</p>
<p>중요한 것은 HTTP message의 형태차이는 GET과 POST 계열 두 가지만 있을 뿐이다. GET에서는 HTTP request body를 사용하지 않는다. POST 등 나머지에서는 본문이 존재한다. OPTIONS는 존재하지 않는다. </p>
<ul>
<li>상태 코드 아는대로 설명해보시오. </li>
</ul>
<p>100번대 : 단순 정보 </p>
<p>200번대: 요청 성공 코드. 200 OK </p>
<p>300번대: 변경 코드, 301 Moved Temporarily <em>(Permanently)</em>, 302 Found, 304 Unchanged…. </p>
<p>400번대: 요청측 오류 코드, 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found</p>
<p>500번대: 서버측 오류 코드, 500 Internal Server Error, 503 Bad Gateway </p>
<ul>
<li>TCP와 UDP의 차이점에 대해 서술하시오. </li>
</ul>
<p>TCP는 <strong>느리고</strong> UDP는 <strong>빠르다.</strong></p>
<p>왜 이런 차이가 나는지 설명하겠다. TCP는 아시는 것처럼 핸드셰이크도 수행하고 패리티 비트도 있다. </p>
<p>커넥션이 열리기 전 3-way handshake를 수행해야 한다. 연결이 닫힐 때는 4-way다. 이런 식으로 연결 상태를 확인하며 받는 쪽이 받을 준비가 됐는지, 보내는 쪽이 정보를 다 보내고 연결이 끊어진건지를 확인하는 것이다. </p>
<p>정합성이 중요한 데이터를 주고받을때는 커다란 장점이지만 정합성보다 속도가 요구되는 상황에서는 치명적인 약점이다. 예를 들면 온라인 게임같은 상황이다. 한 두개의 패킷 로스가 발생하더라도 속도를 높게 유지하는 것이 이런 상황에선 더 도움이 된다. 이럴때는 UDP를 써야 한다. </p>
<p>온라인 게임에서는 UDP를 사용해 RTT를 최대한 낮추려고 노력한다. 그래도 충분하지 않아 소프트웨어적으로 보간 지연(interpolation delay)을 둬서 클라이언트-서버 양측의 시간차이를 보정하기도 한다. </p>
<ul>
<li><p>OSI 7계층? </p>
<ul>
<li>1계층 : 물리 계층, RJ-45, RS-232 같은 규격들</li>
<li>2계층 : 데이터 링크 계층 </li>
<li>3계층 : 네트워크 계층</li>
<li>4계층 : 전송 계층</li>
<li>5계층 : 세션 계층</li>
<li>6계층 : 표현 계층 </li>
<li>7계층 : 응용 계층 </li>
</ul>
</li>
<li><p>HTTP 2.0의 특징에 대해 간단히 서술해 보시오.</p>
</li>
</ul>
<p>HTTP2.0은 빠르다. 그리고 안전하다. </p>
<p>우선 안전한 이유부터 설명드리면 2.0부터는 TLS의 적용이 의무화된다. L6 ~ L7을 아우르는 표준이 됐기 때문에 L6에서의 TLS를 의무화시킬 수 있었다. </p>
<p>그리고 빠르다. 빠른 이유는 두가지가 있는데 스트림과 서버 푸시다. </p>
<p>하나의 요청이 끝나고 4방향 악수가 끝난 다음에야 통신이 종료되고 다음 통신으로 넘어가는 기존 규격과는 다르게 2.0은 스트림을 열어놓고 필요한 정보를 계속 요청하거나 수신할 수 있다. 이 과정에서 헤더는 압축되어 표현된다. 연결을 새로 수립하고 끊는 오버헤드를 절감할 수 있다. </p>
<p>그리고 서버 푸시도 중요한 기술이다. 클라이언트가 특정 경로로 요청을 보냈을 때 부가적으로 요청해야 할 것들(웹페이지를 예로 들면 CSS나 .js 파일들)을 서버가 미리 알아차리고 푸시해줄 수 있다. 이 과정에서도 오버헤드가 절감된다. </p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/06/07/http-questions/" data-id="ckk5ihpxa008pdg9oizd4ylbk" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/06/07/http-questions/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-questions" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/tech-interview/">tech_interview</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/06/java-questions/">자바에 관한 질문들</a>
    </h1>
  

        <a href="/2018/06/06/java-questions/" class="article-date">
  <time datetime="2018-06-06T01:15:55.000Z" itemprop="datePublished">2018-06-06</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="자바에-관한-질문들"><a href="#자바에-관한-질문들" class="headerlink" title="자바에 관한 질문들"></a>자바에 관한 질문들</h3><ul>
<li>객체지향의 5대 원칙에 대해 있는대로 설명해 보시오. </li>
</ul>
<p>5대 원칙이라고 말씀하시면 SOLID 말씀이실 것이다. 메탈기어 솔리드가 참 재밌었는데…. </p>
<p>S : SRP, Single Responsibility Principle로써 객체와 메소드가 각각 하나씩의 책임을 갖게 하는 원칙이다. 하나의 책임을 수행하도록 객체와 메소드의 분리를 수행해야 하고 필요하다면 접근 제어자를 통해 책임을 강제시키는 것도 필요하다.</p>
<ul>
<li>꼬리질문: 접근 제어자를 통해 책임을 강제시킨다는 말씀은 무슨 소린가? <ul>
<li>객체 내부의 정보에 다른 클래스의 메소드에서 맘대로 접근해 정보를 수정할 수 없게 하고 객체가 스스로 자신의 값을 바꾸는 등의 작업을 수행케 하는 것이다. 이는 객체지향의 다른 원칙들 중 하나인 캡슐화(encapsulation)에도 해당하는 사항이다. </li>
<li>예를 들어 몸무게 값을 갖고 있는 필드를 public으로 선언한다면 해당 필드에는 int 범위 내의 어떠한 숫자라도 위치할 수 있을 것이다. 이런 상황은 개발자가 의도하지 않은 상황으로, 이런 필드는 마땅히 수정자(setter) 메소드를 통해 접근해 값을 바꾸게 하고 데이터에 대한 유효성 검사를 시행하는 것이 옳다. </li>
<li>public 필드는 일단 API가 공개되면 개발자의 의도대로 값을 전혀 통제할 수 없기 때문에 위험하다. 이는 나중에 또 설명… </li>
</ul>
</li>
</ul>
<p>O: OCP, Open Close Principle로써 객체는 확장에는 열려있고(open) 변경/수정에는 닫혀있어야(close) 한다. 쉽게 말해 값이나 성질 등을 하드코딩하기보다는 다형성(polymorphism)과 상속을 활용해 새로운 클래스로 확장시켜나가는 작업이 필요하다. </p>
<p>L: Liskov Substitution Principle 즉 리스코프 치환 법칙이다. 변수의 타입이 선언됐을 때 하위 타입은 상위 타입의 기능을 문제없이 모두 수행할 수 있어야 한다. 하위 타입에만 존재하는 값이나 성질을 가지고 상위 타입의 메소드를 오버라이드하는 경우 이 원칙이 깨지는 경우를 많이 본다. </p>
<p>I: 인터페이스 </p>
<p><em>인터페이스 분리의 원칙이다. 타입에서 제공하는 메소드를 모두 사용할 필요가 없다면 더 작은 타입으로 분리해 내서 인터페이스를 다시 구현해야 한다.</em></p>
<p>D: Dependency Inversion Principle 의존성 역전의 원칙이다. 객체는 자신이 의존하고 있는 다른 객체의 세부 구현을 몰라도 된다는 원칙이다. 즉 “타입” 에 의존하고 “클래스” 에는 의존 관계를 갖지 말라는 얘기다. </p>
<p>저의 개인적인 생각입니다만 SRP와 OCP를 지키다보면 DIP는 자동으로 지켜지는 경우가 많았다. 객체가 하나씩 책임을 갖고 서로 의존관계를 갖다 보면 DIP는 자동으로 만족된다. 하나의 책임을 가진 객체들이 모여서 큰 기능을 이루게 되면 클래스나 메소드 내부의 하드 코딩된 값들이나 동작들이 모두 소거되고 확장성있고 유지보수하기 쉬운 코드를 작성하게 되는 것 같다. </p>
<p><em>더 좋은 답변: 더 안정적인 클래스/타입에 의존해야 한다는 원칙이다.</em></p>
<ul>
<li>추상클래스와 인터페이스의 차이는? 뭘 써야 옳은가? </li>
</ul>
<p>결론부터 말씀드리면 이펙티브 자바에서는 “인터페이스를 사용하라” 고 말한다. 제 생각도 같다. </p>
<p>인터페이스에도 디폴드 메소드가 도입됨에 따라 추상 클래스를 사용할 이유는 점점 없어지고 있다. 다만 추상 클래스를 사용하면 클래스가 사용하는 자료구조 등을 통일하도록 “권장” 할 수 있다는 점이 그나마의 이점이지만 어차피 서브클래스를 작성할 때 필드를 새로 정의하면 깨질 장점이므로 솔직히 말씀드리면 제 눈에 보이는 추상클래스의 장점이 별로 없다. </p>
<p>뿐만 아니라 추상클래스가 인터페이스에 비해 뒤떨어지는 가장 치명적인 단점은 <strong>다중 상속이 안 된다</strong> 는 점이다. 한번에 하나의 추상클래스만 상속받을 수 있으므로 여러 기능을 가지려면 여러 기능을 가진 슈퍼클래스를 갖던지 아니면 타입을 분리해내야 한다. </p>
<p>인터페이스는 다중 구현이 가능하므로 이런 단점을 극복할 수 있다. “믹스인(mix-in) 클래스를 만들기 쉽다” 고도 말한다. 예를 들어 Serializable도 갖고 Comparable도 가지면서 원래 구현하고자 하는 타입도 가지고 하는 식의 구현이 가능하다. </p>
<ul>
<li>JCF에 대해 있는대로 설명해보세요. </li>
</ul>
<p>JCF는 크게 세 가지 계열로 나눠볼 수 있을 것 같은데 List, Map, Set이 그것이다. 먼저 각 계열별 특징을 간략히 설명드리면 List는 순차 저장이 보장되는 배열같은 자료구조이고 값의 중복이 허용된다. Set은 값의 중복이 허용되지 않으며 순차 저장이 보장되지 않는다. Map은 Key-Value 쌍으로 이뤄진 자료구조이다. </p>
<p><strong>List</strong></p>
<p>List에서 흔히 사용하는 것을 ArrayList를 들 수 있다. ArrayList는 말 그대로 array를 사용한 리스트로 내부적으로 고정된 크기의 배열을 갖고 있다가 <strong>값이 가득 차면 두 배 늘어난 크기의 배열을 새로 만들고 거기에 데이터를 옮겨쓰는 작업을 반복</strong> 한다. </p>
<p>배열에 담긴 모든 데이터를 복사하고 옮기고 또 원 데이터를 말소시키는 작업은 오버헤드가 발생할 수 있기 때문에 처음부터 리스트가 꽤 많은 요소를 담을 것 같다 싶으면 애초에 좀 큰 배열을 사용하도록 명시적으로 선언해주는 것도 방법일 것이다. <code>java.util.ArrayList</code>의 생성자에는 int값으로 내부 배열의 초기 크기를 명시해줄 수 있다. 참고로 빈 생성자로 어레이리스트 객체를 선언했다면 내부에 만들어지는 배열의 크기는 16이다. </p>
<p>자바에서 가장 흔히 사용되는 선형 자료구조이고 연속된 배열을 사용하기때문에 인덱스를 아는 상태에서 값을 조회하는 작업은 O(1), 데이터의 삽입 / 삭제는 O(n)의 시간 복잡도가 발생한다. </p>
<p>자바에서도 Linkedlist를 사용할 수 있다. 똑같은 List 인터페이스의 구현체이기 때문에 사용법은 어레이리스트와 같고 단순히 앞 원소가 다음 원소의 주소값을 참조로 갖는 Single linkedlist로 구현되어 있다. 이 경우 데이터의 삽입 삭제도 O(1)로 수행할 수 있게 된다. </p>
<p>thread-safe가 보장돼야 하는 경우 synchronized 메소드와 자료구조가 적용된 <code>java.util.Vector</code>를 사용할 수 있지만 성능이 떨어지게 되기 때문에 필요한 상황에만 제한적으로 사용해야 하고 concurrent 패키지에 있는 CopyOnWriteArrayList의 사용을 고려해보는 것이 좋다. </p>
<p><strong>Map</strong></p>
<p>맵은 키 - 밸류 저장소 방식의 자료구조이다. 키는 <strong>중복될 수 없다</strong>. </p>
<p>Map 인터페이스의 잘 알려진 구현체로는 HashMap과 TreeMap이 존재한다. </p>
<p>우선 HashMap부터 살펴보면 이 자료구조는 해시테이블을 통해 키를 관리하고 값을 저장할 수 있는 자료구조이다. 해시테이블 구조이므로 키는 중복될 수 없다. Key는 또한 원시형 데이터 타입을 <strong>사용할 수 없다.</strong> java.lang.Object의 서브클래스만이 해시맵의 키가 될 수 있으며 hashCode()와 equals() 가 오버라이드되어 있는 객체여야 한다는 <strong>강제조건은 없지만 구현하는 것이 필수적이다.</strong> </p>
<ul>
<li><em>꼬리질문: 두 메소드가 오버라이드되어야 하는 이유는? 해시테이블의 동작 원리는?</em><ul>
<li>해시테이블의 작동 원리부터 살펴드리면 해시테이블은 객체를 해시 함수에 넣고 한번 돌린 후 산출된 해시값을 인덱스로 삼아 값을 저장하는 방식이다. </li>
<li>java.lang.Object의 hashCode() 메소드는 객체를 해시코드로 바꿔주는 메소드로써 아무런 오버라이드가 되어있지 않다면 native 메소드가 호출되어 <strong>사용중인 JVM의 전략에 따라 해시코드를 만들어주게 된다.</strong></li>
<li>참고로 말씀드리면 OpenJDK의 경우 해시 코드 생성 전략이 6개가 있는데 기본 전략은 2번, 메모리 주소 기반 생성법이다. </li>
<li>여튼 해시함수는 정의역이 치역보다 크기 때문에 <strong>생성된 해시코드의 중복은 필연적으로 발생하기 마련이다.</strong> 중복이 발생한 상황을 hash collision이라고 하며 이를 resolve하기 위해 open addressing, chaining 등의 방법이 사용되는데 java.util.HashMap은 chaining 법을 사용하고 있다. 이는 동일한 hashcode를 갖는 key에 엮인 값들은 몽땅 한 테이블에 링크드리스트의 형태로 몰아넣은 것이다. </li>
<li>이 때 중복이 발생한 인덱스까지 찾아가는 데에는 .hashCode()가, 일단 찾아간 후 실제 개발자가 원하는 값을 찾아 링크드리스트를 탐색하는 데에는 .equals() 를 통한 <strong>객체의 동등성 비교</strong>가 사용되기 때문에 두 메소드가 반드시 동시에 구현돼야 하는 것이다. </li>
</ul>
</li>
</ul>
<p>HashMap의 성능을 최적화하기 위해서는 좋은 전략으로 구현된 .hashCode()가 중요하고, 해시테이블의 적합한 사이즈도 중요하다. 비둘기집의 원리라는 것이 있다. 잠시 설명드리면 n개의 새장에 n + 1 마리의 새를 집어넣으면 적어도 하나의 새장에는 반드시 두 마리 이상의 새가 들어가게 되는 간단한 정리를 말하는 것이다. </p>
<p>아무리 고품질의 hash function도 충돌 현상을 피하기 어려운데 저장해야 할 객체의 숫자에 맞는 해시테이블의 크기마저 갖지 못했다면 해시 테이블의 성능은 떨어질 수밖에 없다. HashMap도 이를 충분히 고려한 후 구현되었기 때문에 0.75라는 <strong>load factor</strong> 상수값을 갖고 전체 사이즈의 75% 이상 객체가 차게 되면 자동으로 크기를 <strong>두 배 늘린다.</strong> </p>
<p>TreeMap은 Red-Black Tree 기반의 자료구조이다. 사용법은 해시맵과 같다. 키의 값을 기준으로 정렬이 필요할 때 더 우수한 성능을 보여준다. </p>
<p>thread-safe함을 보장하기 위해서 HashTable을 사용할 수 있는데 성능을 위해서라면 concurrent 패키지에 있는 ConcurrentHashMap을 사용하는 것이 더 좋겠다.</p>
<p><strong>Set</strong></p>
<p>Set은 값이 중복될 수 없고 순차적 저장이 보장되지 않는 자료구조이다. 자바책들에서는 보따리로 많이 비유하곤 한다. </p>
<p>HashSet은 HashMap을 기반으로 한 Set 인터페이스의 구현체이다. 내부적으로 HashMap의 키 값에 입력받은 객체를 다 넣고 구현한다. 이때 value 칸에 넣을 더미 오브젝트를 객체가 생성될 시점에 하나 만들어서 들고있는 것이 재밌는 점이다. </p>
<p>이외의 동작원리는 해시맵과 아예 같다. </p>
<p>TreeSet은 TreeMap을 기반으로 했다. </p>
<ul>
<li>접근 제어자에 대해 설명해보세요. </li>
</ul>
<p>네 종류가 있다. </p>
<ul>
<li>public: 암데서나 접근 가능함.</li>
<li>private: 아무데서도 접근이 불가능함. 자기 자신만 접근할 수 있음</li>
<li>(default): <strong>아무런 접근 제어자를 달지 않으면</strong> 디폴트 상태. 같은 패키지 내에서만 접근가능</li>
<li>protected: 같은 패키지 내와 <strong>자신을 상속한 서브클래스</strong> 에서 접근가능</li>
</ul>
<p>interface에서는 모든 메소드가 퍼블릭이다. </p>
<ul>
<li>Overload / Override 차이가 뭐에요? </li>
</ul>
<p>오버로드는 저그의 인구수를 늘려주는데 하이브에서 연구하면 수송선으로도 쓸 수 있다. 디텍터이기도 하다. </p>
<p>같은 이름을 갖는 메소드의 파라메터만 달리 해서 다른 기능을 수행시키는 것이다. 생성자 오버로딩이 즐겨쓰인다. 너무 남용하면 안되고 명확한 문서화를 통해 구현하는 것이 좋겠다. </p>
<p>무작정 생성자 오버로딩만 할 게 아니라 생성자 파라메터의 숫자가 많다면 <strong>builder 패턴의 도입을 고려</strong>해야 한다. </p>
<p>오버라이드는 상위 타입 / 클래스에 정의되어 있는 메소드를 자식 클래스에서 재정의하는 것이다. 대표적으로 <code>java.lang.Object</code> 에 구현되어 있는 메소드들을 오버라이드해서 쓰는 경우가 많다. </p>
<ul>
<li><p><em>꼬리질문: java.lang.Object에 있는 메소드들에 대해서 설명해보세요.</em></p>
<ul>
<li>hashCode(): 객체를 해시코드로 바꿔주는 메소드. </li>
<li>equals(): 객체의 동등성(equality)을 판별하는 메소드. </li>
<li>toString(): 객체를 문자열로 바꿔주는 메소드.</li>
<li>finalize(): 객체룰 소멸시키는 메소드…. 인데 이걸 부른다고 해서 바로 gc가 도는 건 아닙니다. </li>
<li>clone(): 객체를 복사하는 메소드. <strong>딥 카피가 필요한지 섈로우 카피가 필요한지 오버라이드 당시에 결단해야 합니다.</strong> </li>
</ul>
</li>
<li><p>static에 대해 설명해보세요. </p>
</li>
</ul>
<p>static은 정적 변수, 혹은 메소드로 주로 상수값을 저장하거나 유틸 클래스 등을 작성할때 즐겨 쓴다. </p>
<p>기술적인 설명을 해 보자면 이 static 변수는 클래스로더가 돌 때 객체가 만들어지지 않아도 무조건 heap에 변수가 저장되고 class area에 그 참조가 올라가게 된다. 따라서 new를 통해 객체를 만들지 않아도 원래의 기능을 다 수행할 수 있다. </p>
<ul>
<li>String에 대해 아는대로 설명해보세요. </li>
</ul>
<p>String은 재밌는 클래스인데 가장 흔히 쓰이지만 가장 오해도 많이 받기도 하고 JVM 내부적인 최적화도 많이 돼있는 클래스이다. </p>
<p>우선 String 객체를 만들때부터의 과정부터 설명드리고 싶다. 우리는 <code>String a = &quot;a&quot;;</code> 이런 식의 구현을 많이하고 <code>new String(&quot;a&quot;);</code> 와 같은 구현은 잘 하지 않는다. </p>
<p>문자열을 스트링 변수에 바로 할당하면 컴파일 타임에 최적화가 발생하는데, 이 최적화 과정 중에는 interning이라는 과정이 포함되어있다. 같은 값을 갖는 스트링 객체를 String pool에 보관하고 <strong>다음번에도 같은 문자열이 선언되면 새 객체를 만들지 않고 풀에서 갖다 쓰는</strong> 방식의 구조를 가지게 된다. </p>
<p>String pool이 어디에 위치하냐면…. JDK 1.6까지는 PermGen에 있었으나 1.7부터 PermGen을 deprecate시키기 위한 설계 변경을 하기 시작하면서 Tenured로 이동했다. 그 말인즉슨 gc의 대상이 된다는 말이다. </p>
<p>그래서 String은 객체이지만 <strong>동일성 비교</strong> 가 먹히는 경우도 있다. 풀에서 반환된 값의 경우 메모리 번지수까지 같을 가능성이 왕왕 있기 때문이다. 하지만 <strong>객체의 동일성으로 그 내용을 비교하는 것은 정석이 아니다.</strong> 어떠한 경우에도 String 클래스가 제공하는 <code>.equalsIgnoreCase()</code> 와 같은 메소드를 통해 객체의 동등성을 비교해야 할 것이다. </p>
<p>이유는 String에 관련한 유틸 클래스 중 interning 과정을 거치지 않고 문자열 객체를 만드는 경우가 종종 있기 때문이다. 예를 들어 <code>.substring()</code> 같은 메소드는 스트링을 몇 번째 자리부터 몇 번째 자리까지 잘라 새 객체를 만들어주는데 이 때는 인터닝 안하고 바로 <code>new String()</code>으로 객체를 만들어서 갖다준다. 이런 경우 어떠한 상황에도 <strong>동일성 비교가 먹히지 않는다.</strong></p>
<p>또 하나 우리가 기억해야 할 점은 String은 <strong>불변 객체</strong> 라는 점이다. 한번 선언되면 그 내용을 바꿀 수 없다. <strong>그렇기 때문에 interning과 같은 최적화가 가능한 것이다.</strong> 문제는 문자열의 내용을 바꿔야 할 일이 있을때 내용을 복제하고, 내용을 바꾼 다음 <strong>새로운 객체를 생성해 그 내용을 덮어써야 한다는 점</strong> 이다. 적지않은 오버헤드가 발생할 여지가 있다. </p>
<p>문자열의 덧셈 연산을 할 수 있다. <code>&quot;a&quot; + &quot;b&quot; = &quot;ab&quot;</code> 가 된다. 이런 덧셈 연산을 할 경우 .concat() 메소드도 있지만…. 이 메소드는 앞서 설명드린 내용을 그대로 코드로 바꾼 것에 불과하다. </p>
<p>문자열의 덧셈연산을 할 경우 JDK1.8 까지는 StringBuilder를 이용한 형태로 최적화된다. JDK1.9 부터는 <code>StringConcatFactory</code> 라는 객체의 도움을 받는 것으로 최적화 전략이 변경되었다. </p>
<ul>
<li><p><em>꼬리질문: 그러면 개발자가 StringBuilder를 선언해서 쓸 필요는 없겠다.</em></p>
<ul>
<li>그렇지 않다. 덧셈 연산 한 번당 빌더 객체 하나가 새로 만들어진다는 점에 주목하자. </li>
<li>같은 문자열 덧셈 연산을 100번, 1000번 수행했다면 글자 하나 더하고 객체를 버리고, 새로 만들고 하는 작업을 반복하게 된다. </li>
<li>이런 경우 처음부터 빌더를 만들어서 <code>.append()</code>로 최적화하는 방향이 맞다. </li>
</ul>
</li>
<li><p><em>꼬리질문: StringBuilder와 StringBuffer의 차이점에 대해 논하시오.</em> </p>
<ul>
<li>둘 다 슈퍼클래스는 AbstractStringBuilder로써 구현한 abstract method는 같다. </li>
<li>그러나 StringBuffer는 메소드와 변수에 synchronized 예약어를 붙여놓았다. <strong>thread-safe를 보장해야 할 상황에만 제한적으로 사용해야 퍼포먼스를 보장할 수 있다.</strong></li>
<li>개인적인 실험을 해 본 기억이 난다. StringBuilder와 StringBuffer의 .append() 작업을 각각 1억 번 수행했는데 3초(3000ms) 정도의 실행시간 차이가 발생했다. 적지 않은 차이라고 생각한다. </li>
</ul>
</li>
</ul>
<p><em>디자인 패턴 정리</em> </p>
<p><strong>Spring Framework</strong></p>
<p><strong>스프링에서 사용되는 디자인 패턴을 나열하고 설명해 보시오.</strong></p>
<ul>
<li><p>Builder 패턴: Security에서의 config method, 개발자가 정의한 모델 클래스의 생성에도 많이 쓰인다. </p>
</li>
<li><p>Adapter 패턴: Controller의 RequestMapping에 사용됨. </p>
</li>
<li><p>Factory 패턴: 특정 타입의 서브클래스들의 인스턴스를 만들어주는 패턴. JDBC 연동 등에 사용됨.</p>
</li>
<li><p>Decorator 패턴: 특정 타입의 구현체가 실제 구현체를 갖고 있으면서, 자신은 부가기능만을 구현하고 전달받은 실제 구현체에게 실제 기능을 위임하는 방식.<br>인터페이스의 수정 없이 부가기능을 구현할 수 있다. </p>
</li>
</ul>
<p>JDK Dynamic Proxy가 이 방식을 따른다. </p>
<ul>
<li>React.js 에서의 활용: 자바스크립트에서 decorator 패턴을 구현하는 좋은 사례는 고계함수(high-order functions)이다. 리액트에서도 고계 함수가 사용된다. 고계함수를 통해 routing, state management등의 부가 기능이 구현되며 고계함수에서는 부가기능만 구현하고 render()등 원래 기능의 구현은 고계함수의 생성자로 전달된 원래 컴포넌트에서 수행되는 것이다. </li>
</ul>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/06/06/java-questions/" data-id="ckk5ihpyf009xdg9os898fow4" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/06/06/java-questions/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring-questions" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/04/spring-questions/">스프링에 관한 질문들</a>
    </h1>
  

        <a href="/2018/06/04/spring-questions/" class="article-date">
  <time datetime="2018-06-04T09:58:04.000Z" itemprop="datePublished">2018-06-04</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="스프링에-관한-질문들"><a href="#스프링에-관한-질문들" class="headerlink" title="스프링에 관한 질문들"></a>스프링에 관한 질문들</h3><p><em>기술 면접을 2주 앞두고 면접에 필요한 내용들을 정리하며 “…질문들” 시리즈를 연재해본다.</em></p>
<p><strong>스프링의 구조, 요청 / 응답</strong></p>
<ul>
<li>스프링은 어떻게 요청을 처리하는가? 요청을 처리하는 순서대로 설명해 보아라. </li>
</ul>
<p>면접관님 우선 이렇게 어려운 질문을 해주신 것에 대해 제 자신을 뒤돌아보게 됩니다. 혹시나 제가 채용 과정중 맘 상하게 해드린 부분이 있다면 용서를….</p>
<p>Spring MVC의 관점에서 설명하겠다. Spring MVC는 <strong>Front Controller 패턴</strong>을 채택하고 있다. </p>
<p>Front Controller란 웹 애플리케이션의 가장 앞단에 <strong>모든 요청을 받는 서블릿</strong>을 두고 일단 들어온 요청을 개발자가 명시한 바에 따라 분기처리해나가며 요청을 처리하는 방식이다. Spring MVC에서 Front Controller의 역할을 하는 서블릿을 <strong>DispatcherServlet</strong> 이라 칭한다. </p>
<p>DispatcherServlet은 한개일 수도 있고 <strong>복수개일 수도 있다.</strong> 단 DispatcherServlet을 분할하여 관리할 수 있게 한 것은 Legacy JSP와의 호환을 위해 그렇게 남겨둔 것으로 <strong>한개의 DispatcherServlet이 모든 요청을 받아들인 후 IoC Container에 진입해 분기처리할 수 있는데 굳이 복수개의 서블릿을 운용할 필요는 없다.</strong> </p>
<p>DispatcherServlet 앞에 Filter라는 것이 있다. Filter는 요청을 말그대로 필터링하면서 HTTP request header 등 정보를 읽어들여 DispatcherServlet에 진입하기 전 필요한 처리를 한다. </p>
<ul>
<li><em>꼬리질문: Filter와 Interceptor의 차이는?</em> <ul>
<li>Filter는 IoC Container에서 관리되는 콩이 아니다. Filter는 DispatcherServlet보다도 앞단에 위치하는 객체로 Spring이 관리하지 않는 객체이므로 Dependency Injection 등의 구현을 할 수 없다. </li>
<li>그대신 Filter를 Spring Config class에서 등록시키고, 이 때 Autowired된 객체의 참조를 생성자로 전달할 수는 있다. 실제로 이런 구현을 많이 한다. 예를 들어 SecurityConfig.java에서 인증에 필요한 객체들을 bean으로 받아놓은 후 filter에 참조를 넘겨줄 수 있다. </li>
<li>Interceptor는 스프링이 관리하는 콩이다. </li>
</ul>
</li>
</ul>
<p>일단 DispatcherServlet에 진입하고 나면 적합한 컨트롤러를 찾아 매핑시켜줘야 한다. 최근의 Spring MVC에서는 AnnotationMethodHandlerAdapter가 사용된다. @RestController나 @Controller로 애노테이션 된 클래스 아래에 있는 @GetMapping, @PostMapping 등 메소드들이 스캔의 대상이 된다. </p>
<p>HandlerAdapter는 간단한 인터페이스로 handle() 메소드 하나가 전부다. 적합한 컨트롤러를 찾아 HttpServletRequest를 전달하고 응답을 돌려주는 역할을 한다. </p>
<p>Spring MVC에서 사용할 수 있는 컨트롤러의 타입에는 제한이 없다. 개발자가 마음껏 정의해서 쓸 수 있다. 이를 가능하게 해주는 것이 HandlerAdapter이다. 컨트롤러의 메소드에서 파라메터를 전달받을 수 있다. 이 파라메터를 전달해주는 역할은 ArgumentResolver가 수행한다. </p>
<p>기본 등록되어있는 ArgumentResolver 이외의 다른 객체를 파라메터로 사용하고 싶다면 custom으로 구현해주면 되겠다. </p>
<p>HandlerAdapter의 handle() 메소드가 갖는 리턴 타입은 ModelAndView다. HTTP Body에 직접 접근해 응답을 기록하는 @ResponseBody 애노테이션이 붙어있지 않는 이상 모든 컨트롤러는 ModelAndView로 응답을 전달해야 하고, ViewResolver가 그 역할을 수행해준다. 이때 property에 기록된 template suffix 등이 적용된다. </p>
<p>@ResponseBody나 @RestController의 경우 ModelAndView 타입을 리턴하는 ViewResolver 대신 MessageConverter가 작동한다. MessageConverter는 컨트롤러의 메소드가 리턴한 객체를 전략에 따라 적절한 message로 변환하여 HTTP body에 직접 내용을 기록한다. </p>
<p>대표적인 것으로 Jackson2HttpMessageConverter.java 가 있다. 이 객체는 컨트롤러가 리턴한 객체를 com.fasterxml.jackson.objectMapper() 의 writeValueAsString() 메소드에 넣고 스트링으로 객체를 변환한 후 해당 스트링을 http body에 기록하게 된다. </p>
<p>ModelAndView 타입이건 ResponseBody에 대한 응답이건 응답이 기록되게 되면 Spring MVC의 요청 처리 사이클이 완료된 것이다. </p>
<ul>
<li><p>*꼬리질문: DispatcherServlet은 IoC Container에 바로 접근해서 Spring bean을 사용할 수 있는가? </p>
<ul>
<li>반은 맞고 반은 틀림. IoC Container의 구현체인 Web application context는 root application context와 servlet application context로 구분됨. Servlet Web ApplicationContext는 controller 등 handleradapter와 requesthandler를 위한 Spring Bean만 갖고 있음. Servlet Web ApplicationContext는 복수개일 수 있음. </li>
<li>Root Web ApplicationContext는 하나의 프로젝트 당 하나임. 복수개로 등록된 Servlet Web ApplicationContext가 하나의 Root Web ApplicationContext를 바라보며 DAO, service 계층의 스프링 빈 등 의존성을 이용해 요청을 처리하는 것임</li>
<li>DispatcherServlet 한개당 Servlet Web ApplicationContext는 하나여야 함. </li>
</ul>
</li>
</ul>
<p><strong>Spring IoC Container</strong></p>
<ul>
<li>IoC Container라는 언급을 자주 하셨는데 이는 무엇인가? </li>
</ul>
<p>IoC Container는 스프링 그 자체다. </p>
<p>DI Container라고도 하고 이걸 그냥 스프링이라고 부르는 개발자들도 있다. 혹은 Singleton Container라고 불리기도 한다. </p>
<p>핵심은 <strong>싱글톤 보일러플레이트 없이</strong> 객체들의 싱글톤 상태를 유지시켜주는 것이다. 이를 위해 스프링은 객체들을 직접 생성해 컨테이너 안에서 그 생명주기를 관리하며 싱글톤 상태를 깨지 않는 관리를 하게 된다. </p>
<p>다른 객체에 대한 의존성 주입이 필요하다면 IoC Container가 직접 주입해준다. 여기서 제어권의 역전이 발생한다. 객체는 특정 객체가 아닌 타입에 의존하면서 실제 구현체에 대해서는 모르는 상태를 유지하는 것이다. </p>
<p>스프링의 ApplicationContext는 간단한 인터페이스로써 BeanFactory를 상속하고 있다. .getBean() 을 통해 Bean 객체를 요청받으며 만약 싱글톤 레지스트리에서 보관하고 있지 않는 객체인 경우에는 BeanFactory를 통해 새로운 객체를 만들어서 돌려준다. 이 때도 객체는 싱글톤 레지스트리에 등록시키며 앞으로 다른 요청이 있을 경우 싱글톤 레지스트리에서 빼서 갖다준다. 새로운 객체를 두 번 만들지 않는다. </p>
<ul>
<li><em>꼬리질문: Spring이 이런 구현을 가져가는 이유는 뭐라고 생각하는가?</em><ul>
<li>아무리 JVM이 현대화되고 최적화됐지만 객체의 생성은 약간의 오버헤드를 가져오는 일임에는 틀림이 없다. </li>
<li>접속이 새로 들어와 스레드가 생길 때마다 새로운 서비스 객체, 각종 컴포넌트 객체가 새로 생긴다면 JVM의 객체 생성과 GC 메카니즘에는 상당한 부하가 걸릴 것이다. </li>
<li>멤버 변수를 가질 필요가 없고 비즈니스 로직을 수행하는 객체라면 Bean으로 관리하는 것을 고려해야 한다. </li>
</ul>
</li>
</ul>
<p>스프링은 ApplicationContext로 객체를 관리하면서 다양한 부가기능을 구현할 수 있게 도와준다. Spring AOP가 대표적인 사례로 애노테이션을 통해 객체에 부가기능을 추가할 수 있는 것은 결국 Spring의 ApplicationContext가 런타임 시에 객체를 만들어 싱글톤 레지스트리에 등록하는 과정 중에서 프록시 객체의 생성과 같은 객체 내용/역할의 변조가 가능하기 때문이다. </p>
<ul>
<li><p><em>꼬리질문: Spring AOP의 작동 원리에 대해 설명해 보아라.</em></p>
<ul>
<li>Spring AOP를 가능케 해주는 두 가지 방법, 그리고 크게 세 가지의 Framework support가 있다. </li>
<li>먼저 Runtime Weaving 부터 살펴보면 JDK Dynamic Proxy와 CGLib이 있다. </li>
<li>JDK Dynamic Proxy는 decorator 패턴을 따르는 것으로 proxy 객체를 형성해 부가 기능의 구현을 전담시킨 후, 원래 기능의 수행은 원 객체에 위임시키는 구현 방식이다. </li>
<li>JDK Dynamic Proxy의 proxy 객체에는 .invoke() 메소드가 존재한다. .invoke() 메소드는 InvocationHandler의 구현체에 존재하는 메소드이다. </li>
<li>JDK Dynamic Proxy는 인터페이스에 대해서만 weaving할 수 있다.</li>
<li>concrete class에 대한 weaving은 CGLib을 사용한다. CGLib은 원 객체를 상속해 새로운 객체를 구현하는 방법으로 weaving을 실시하고, class와 method에 대한 overriding이 수반되는 방식이다. 따라서 코틀린과 함께 이용할때는 open 예약어를 통해 상속을 오픈시켜줘야 한다. </li>
<li>AspectJ를 응용한 Compile Time Weaving도 가능하다. AspectJ를 사용하는 경우 Load Time Weaving도 가능하다. </li>
<li>AspectJ는 실제 바이트 코드에 대한 변조이므로 제약조건이 가장 적고 성능도 가장 좋게 나온다. </li>
<li>주의해야 할 점: Spring AOP에서 @AspectJ 애노테이션을 사용하는 것은 AspectJ를 통한 compile time weaving을 수행하는 것이 아니다. JDK Dynamic Proxy / CGLib 기반 Runtime weaving 하에서 AspectJ의 <strong>문법만을 갖다 쓰는 것</strong> 에 불과하다. </li>
</ul>
</li>
<li><p><em>꼬리질문2: AOP 기반 Transaction 관리에 대해 설명해 보아라.</em> </p>
<ul>
<li>javax.persistence.Transactional 을 붙이면 트랜잭션 부가 기능 프록시 객체가 서비스 클래스에 붙게 된다. </li>
<li>Transaction을 시작하고 소멸시키는 생명주기가 프록시 객체 안에서 이뤄지게 된다. </li>
<li>클래스 레벨로 설정할 수도 있고, 메소드 레벨로 설정할 수도 있지만 중요한 사실은 <strong>클래스 내부 호출에 대해서는 의도대로 작동하지 않는다</strong> 는 점이다. </li>
<li>프록시 객체가 받은 요청에 대해서만 transaction이 사용될 것이다. 즉, public 하게 선언된 메소드를 통해 <strong>작업이 직접 호출되어</strong> 수행된 경우만 프록시 객체가 transaction 관리를 해줄 수 있다. 내부 호출에 대해서는 이미 동작이 원래 객체에 위임된 시점 이후의 일이기 때문에 프록시가 트랜잭션 관리를 해줄 수 없다. </li>
</ul>
</li>
<li><p>ApplicationContext가 객체를 만들고 보관하는 과정에 대해 자세히 설명해보아라. </p>
</li>
</ul>
<p>먼저 ComponentScan 애노테이션에서부터 모든 과정이 시작된다. 부트 환경에서라면 @SpringBootApplication이 그 시작이 되기도 한다. </p>
<p>스프링은 처음 구동될 때 @Bean, @Component, @Service 등의 애노테이션이 붙어있는, 즉 자기가 관리해야 할 클래스를 모두 스캔한다. 이 때 스캔의 범위는 개발자가 적절하게 부여해줄 수 있다. </p>
<p>만약 instantiate되어 관리돼야 할 클래스가 다른 빈에 다시 의존하고 있다면 재귀적으로 해당 빈에 대한 instantiation도 수행한다. 이런 식으로 전체 패키지(혹은 개발자가 스캔하라고 지시한 패키지)에 대한 스캔을 수행하며 아무런 의존성도 업는 객체를 발견할때까지 재귀호출을 계속한다. </p>
<ul>
<li><p><em>꼬리질문: Spring은 어떻게 자신이 관리할 빈인지 알아보는 것인가?</em></p>
<ul>
<li>애노테이션으로 관리된다. 혹은 .xml등 외부 설정 파일을 통해 관리해줄 수도 있다. 중요한 사실은 스프링은 이런 설정 관리를 위해 <strong>특정한 파일 형식이나 표현방법을 강제하진 않는다</strong> 는 점이다. </li>
<li>클래스에 붙은 애노테이션을 검색하고 해석하기 위해 Reflection를 사용한다. reflection 작업에 대한 최적화를 위해 스프링 개발자는 JVM 튜닝 등 다양한 전략의 도입을 고려할 필요도 있다. </li>
</ul>
</li>
<li><p><em>꼬리질문2: 어떻게 하면 리플렉션을 최적화할 수 있을까?</em></p>
<ul>
<li>Reflection이 들여다보는 메모리 영역에 대한 최적화일 것이다. 리플렉션이 들여다보는 정보는 class area에 저장된다. </li>
<li>JDK 1.7까지 이 영역은 Permanent Generation(이른바 PermGen)에 위치했다. JDK1.8 환경부터 이 영역은 metaspace로 이동했다. </li>
<li>솔직히 저도 잘 모르겠는데 입사하면 열심히 배우겠다. </li>
</ul>
</li>
<li><p><em>꼬리질문3: 애플리케이션 콘텍스트가 초기화되는 과정 중 일어날 수 있는 문제들은 어떤 게 있는가?</em></p>
<ul>
<li>가장 흔한 것으로는 의존해야 할 객체가 없는 경우, 즉 @Autowired를 통해 주입받고자 하는 객체나 설정 정보가 주입되지 않는 경우다. </li>
<li>properties 파일에 있어야 할 설정 정보가 부재하거나 interface만 선언해 놓고 타입에 의존한 다음 실제 구현체를 만들어주지 않은 경우가 여기에 해당한다. </li>
<li>두 번째로 흔한 오류는 circular reference 즉 순환 참조의 오류다. 같은 클래스에서 의존하고 있는 두 가지 이상의 객체가 서로에 대해 의존하고 있는 경우 발생한다. </li>
<li>이 경우 @Bean 이 선언되어 있는 설정 클래스를 분리해주거나 @Primary 애노테이션 등을 통해 instantiation의 우선순위를 바꿔주면 잘 해결된다. </li>
<li>정말 드문 경우가 있는데 Servlet Web ApplicationContext에 있는 객체에 대해 RootApplicationContext가 관리하는 객체에서 의존하는 경우다. 정말 드문 경우고 최악의 경우라고 볼 수 있다. </li>
<li>의존성은 위에서 아래로 흐르는 것이 가장 좋다. 의존성 체인의 가장 밑단에 있어야 할 컨트롤러 등 프레젠테이션 레이어의 클래스들은 주입받으면 안된다. </li>
<li>서비스는 컨트롤러를 주입받을 수 없다. </li>
</ul>
</li>
</ul>
<p><strong>Spring Security</strong></p>
<ul>
<li>핵데이 프로젝트에서 스프링 시큐리티를 사용하셨는데 어떤 흐름으로 인증이 처리되는지 간단히 설명해 보아라. </li>
</ul>
<p>인증이 처리되는 과정은 크게 세 파트로 나눌 수 있겠다. 요청 - 인증 - 인가 가 그것이다. </p>
<p>먼저 요청이 들어오면 DispatcherServlet 앞단에 위치하고 있는 javax.servlet.Filter 구현체들이 요청을 반갑게 맞아줄 것이다. </p>
<p>RequestMatcher 등을 통해 이 요청이 인증받아야할 요청인지, 혹은 로그인을 위한 요청인지를 판별하게 된다. 이때 필터 객체는 이미 구현되어 있는 스프링 시큐리티 관련 객체들에 대한 참조를 갖고 있는 상황이다. </p>
<p>일단 필터가 요청에 대한 인증이 필요하다고 판단하면 AuthenticationManager를 호출하여 인증 절차를 시작한다. 이 때 요청을 그대로 매니저로 넘기는 것은 아니고 요청에 필요한 정보만 쏙 빼서 Authentication 클래스의 서브클래스들 (대표적인 것으로, UsernamePasswordAuthenticationToken)에 정보를 담아 매니저로 보내야 한다. </p>
<p>AuthenticationManager는 별거 아니고 거대한 주머니에 불과하다. AuthenticationProvider를 들고 있는 주머니이다. .authenticate() 메소드를 통해 인증 요청이 접수되면 AuthenticationManager는 자기의 주머니에 담겨있는 AuthenticationProvider를 하나 하나 훑어보며 어떤 공급자가 이 요청을 잘 처리해줄 수 있을지를 고민한다. </p>
<p>이제 역할을 AuthenticationProvider에게 넘어왔다. 매니저가 문을 두드리며 “이 요청 네 것 맞니?” 라고 물어볼때 자신의 요청이다싶으면 true를 반환하고, 인증을 수행하기 시작한다. </p>
<p>모든 인증정보가 명확해 인증해줘도 되겠다는 판단이 들면 AuthenticationProvider는 마찬가지로 Authentication의 서브클래스인 인증 객체를 리턴한다.</p>
<p>리턴할 인증 정보는 Authentication의 서브클래스라면 무엇이든 좋지만 UserDetails 인터페이스의 구현체들이 애용된다. Spring Security는 기본 구현체로 org.springframework.security.core.User 클래스를 제공한다. 이 때 User 정보를 만들기 위해 UserDetailsService 인터페이스를 구현하는 경우도 있다. </p>
<p>모든 인증 절차가 성공적이었다면 filter가 그 결과를 돌려받는다. .successfulAuthentication() 메소드가 호출되는데 이 때 인증 정보를 기억시켜줘야 같은 스레드 내에서 요청 정보가 공유될 수 있다. 새로운 SecurityContext를 만들고 SecurityContextHolder에 집어넣어 보관한다. S..Holder는 ThreadLocal 객체를 통해 인증 정보를 관리하기때문에 같은 요청에 대해서는 계속 인증 정보가 보관된다. </p>
<ul>
<li><p>하나의 요청이 두 개 이상의 스레드를 만드는 경우 애노테이션을 통해 인증정보 관리 전략을 갈아끼울 수 있다. </p>
<ul>
<li><p><em>꼬리질문: 왜 스프링은 프로바이더를 통해 인증 과정을 관리하는가?</em></p>
<ul>
<li>스프링이 지향하는 핵심 가치 중 하나는 <strong>확장성</strong> 과 <strong>customizable 함(?)</strong> 이라고 생각한다. </li>
<li>개발자의 의도에 따라 얼마든지 인증 과정을 추가할 수도, 혹은 변경할 수도 있어야 한다. </li>
<li>같은 웹 애플리케이션 콘텍스트 안에서 여러가지의 인증방법을 가져가야 할 수도 있다. 예를 들어 단순한 로그인 창을 통한 로그인 요청이라면 UsernamePasswordAuthenticationToken 을 사용하고 UserDetailsService에 의존하는 인증 프로바이더로 충분하지만, 저의 프로젝트와 같이 JWT라도 도입할라 치면 만약 이렇게 확장성없는 구조로 구현됐다면 일일이 하드 코딩을 통해 변경 내용을 도입했어야 할 것이다. </li>
</ul>
</li>
<li><p><em>꼬리질문: 인증 전, 후 를 가르는 기준은?</em></p>
<ul>
<li>스프링은 “완전한 정보를 갖고 있는 인증 객체(fully-populated authentication principal)”라면 인증 절차가 끝난 객체로 본다. </li>
<li>완전한 정보를 가르는 기준은 대부분의 경우에 권한을 들고 있는지, 아닌지로 구분된다. </li>
<li>일테면 UsernamePasswordAuthenticationToken의 경우 두 가지의 생성자를 갖고 있다. 하나는 유저네임과 비번만을 파람으로 받지만 두 번째의 경우 GrantedAuthority의 서브클래스를 가진 컬렉션을 추가로 전달해야 한다. </li>
<li><code>Collection&lt;? extends GrantedAuthority&gt;</code>를 들고 있는 인증 객체는 .isAuthenticated() 메소드에서 true를 리턴할 것이다. </li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>PreAuthorize, PostAuthorize는 뭔가? global method security 라는 놈도 붙어있던데…. <ul>
<li>AOP기반 인증 처리기다. </li>
<li>Controller의 메소드에 이 애노테이션이 달려있으면 AOP를 통한 부가기능 추가 메카니즘으로 인증 로직을 스프링이 자동으로 구현해준다. </li>
<li>PreAuthorize는 <strong>메소드 진입 전</strong> 인증 정보를 평가하고 진입을 통제한다, PostAuthorize는 그 반대다. </li>
<li>SecurityContextHolder가 관리하는 SecurityContext, 그 속의 Authentication Principal을 통해 권한 정보를 fetch 하고 이 메소드에 접근 인가된 사용자인지를 알아본다. </li>
</ul>
</li>
</ul>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/06/04/spring-questions/" data-id="ckk5ihpyh009zdg9ohxxovgxj" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/06/04/spring-questions/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-threadlocal" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/thread/">thread</a>►<a class="article-category-link" href="/categories/java/thread/concurrent/">concurrent</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/04/java-threadlocal/">ThreadLocal에 대한 짧은 정리</a>
    </h1>
  

        <a href="/2018/06/04/java-threadlocal/" class="article-date">
  <time datetime="2018-06-04T03:05:21.000Z" itemprop="datePublished">2018-06-04</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="Threadlocal에-대한-짧은-정리"><a href="#Threadlocal에-대한-짧은-정리" class="headerlink" title="Threadlocal에 대한 짧은 정리"></a>Threadlocal에 대한 짧은 정리</h3><p><em>(진짜 짧음 주의)</em></p>
<p><strong>Thread-safe하다?</strong></p>
<p>동시성 프로그래밍을 하다 보면 thread-safe, thread-unsafe에 대한 얘기를 하게 된다. </p>
<p>흔히 멤버 변수가 있는 객체를 thread-unsafe, 멤버 변수가 없는 객체를 thread-safe하다고도 하기도 하고, 혹은 synchronized나 volatile과 같은 키워드를 선언해서 thread-safe함을 보장해 주기도 한다. </p>
<p>같은 메모리 영역에 보관되어 있는 하나의 객체가 두 개 이상의 스레드에서 한번에 요청될 때, 한 쪽에서 읽기/쓰기 작업이 끝나지도 않았는데 다른 스레드가 객체의 정보를 요청하는 경우가 바로 <strong>thread-unsafe</strong> 한 상황이다. </p>
<p><strong>Java가 thread-safe를 보장하는 방법</strong></p>
<p>두 가지 방법이 있다. </p>
<ul>
<li><p>Synchronized: 가장 단순한 방법이다. 단순 명쾌하다. <strong>한 스레드의 작업이 끝날때까지 다른 스레드의 진입을 막아주는 것이다.</strong> 메소드, 혹은 변수에 선언할 수 있다. </p>
</li>
<li><p>Volatile: 생소한 개념일 수 있다. 조금 복잡하다. <strong>변수의 CPU Cache 복사를 금지하는 키워드다.</strong> 모든 작업은 RAM(혹은 어떤 형태이든지 주기억장치)에서 이뤄져야 한다. Java는 Heap 영역에 객체가 보관되기 때문에 이 경우 객체의 원자성이 보장된다. </p>
</li>
</ul>
<p><img src="http://thswave.github.io/assets/media/0308.jpg" alt="volatile"></p>
<p>이런 volatile의 작동 방식을 <strong>변수의 가시성을 보장한다</strong> 고도 말할 수 있다. </p>
<p>말 그대로다. CPU에 꽁쳐놓지 않고 모든 작업을 주기억장치에서 처리하니 어떤 스레드에서도 작업 내용을 투명하게 열람할 수 있는 것이다. </p>
<p><strong>ThreadLocal의 역할</strong></p>
<p>다만 inter-thread operability를 보장해주는 위의 두 키워드와는 다르게 만들어진 하나의 스레드 전역에서 공유되어야 할 정보가 있다. </p>
<p>이런 정보들을 thread-safe하게 구현하려면 복잡성이 수반되는데, 단순히 heap 영역에 보관해 공유하자니 thread-safe함이 무너지고, 그렇다고 매 stack마다 선언하고 해당 stack에서 쓰고 버릴 수도 없는 경우가 있기 때문이다. </p>
<p>ThreadLocal을 통해 이런 문제점을 해겷할 수 있다. </p>
<p><img src="http://cfs14.tistory.com/image/36/tistory/2009/02/13/15/44/499516b885314" alt="threadlocal"></p>
<p>말하자면 로컬 변수를 로컬처럼 쓰지 않게 도와주는 방법이라고 볼 수도 있겠다. </p>
<p><em>쓰임새?</em></p>
<p>하나의 스레드가 열린 상태에서 다양한 요청을 처리하고, 또 그에 따른 정보들을 공유해야 하는 상황에 대해 생각해보면 좋을 것 같다. </p>
<p>가장 쉽게 생각하자면 Spring Security의 <strong>SecurityContextHolder</strong>가 떠오른다. 처음 DispatcherServlet이 (혹은 그 앞의 filter가) 요청을 받았을 때 새로운 스레드가 생성되고, 이때 삽입된 인증 정보는 스레드 내에서 계속 공유되며 AOP 기반 인증 처리, 유저 정보 요청 등의 작동을 수행해야 하기 때문이다. </p>
<p><em>주의점?</em></p>
<p>Thread Pool을 통해 thread를 재사용할 경우 한번 쓴 ThreadLocal 객체는 .clear() 를 통해 비워줘야 한다. <strong>그러지 않으면 다음번 해당 스레드가 사용될 때 의도한 작동을 보장할 수 없다.</strong></p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/06/04/java-threadlocal/" data-id="ckk5ihpr5000tdg9o0q1cwhy6" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/06/04/java-threadlocal/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-string" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>►<a class="article-category-link" href="/categories/Java/String/">String</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/21/java-string/">java.lang.String을 파 보았다</a>
    </h1>
  

        <a href="/2018/05/21/java-string/" class="article-date">
  <time datetime="2018-05-21T00:15:39.000Z" itemprop="datePublished">2018-05-21</time>
</a>
      </header>
    
    <div class="article-entry-abstract" itemprop="articleBody">
      
        <!--<h3 id="자바의-문자열에-대해-제대로-공부해보자"><a href="#자바의-문자열에-대해-제대로-공부해보자" class="headerlink" title="자바의 문자열에 대해 제대로 공부해보자."></a>자바의 문자열에 대해 제대로 공부해보자.</h3><p>아마 어떤 언어를 배우든 그 시작은 “문자열 다루기” 일 것이다. “다룬다” 는 표현이 거창한가? 그렇지만 프로그래밍의 시작을 하려거든 어떤 식으로든 문자열과 만나는 경우가 많다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helloWorld</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello world!"</span>)</span><br></pre></td></tr></table></figure>
<p>쌍따옴표 안에 감싸진 것은 분명히 <strong>문자열이다.</strong> </p>
<p>자바는 뭐가 다를까? </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"hello world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>문자열 없이는 첫 발짝도 <strong>뗼 수 없다.</strong> 우리는 프로그래밍을 학습할 때 문자열을 가장 먼저 배운다. </p>
<p>어쩌면 문자열은 프로그래밍 언어에서 등장하는 유일한 “인간의 언어” 일지도 모르겠다는 생각이 든다. </p>
<hr>
<h4 id="오해"><a href="#오해" class="headerlink" title="오해"></a>오해</h4><p>문자열, 특히 Java에서의 문자열은 처음 배우는 개념인만큼 오개념이 생기기도 쉽고, 오개념이 잡혀도 오개념인 줄도 모르기때문에 나중에 바로잡기도 쉽지 않다. </p>
<p>뭐 완전 뉴비 시절에는 이런 실수도 종종 하긴 한다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = <span class="string">"안녕하세요"</span> == <span class="string">"안녕하세요"</span>;</span><br></pre></td></tr></table></figure>
<p>문자열을 ==으로 비교한다던지,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String hi = <span class="keyword">new</span> String(<span class="string">"Hellow"</span>);</span><br></pre></td></tr></table></figure>
<p>문자열에 생성자를 사용한다던지 하는 실수들 말이다. </p>
<p>이런 실수야 각자 해결하고 이 자리까지 왔을테니 굳이 언급하진 않겠다. 이번 글에서는 Java의 j 자 정도에 대한 이해가 생긴 프로그래머들조차도 흔히 갖는 오해, 그리고 흔히 하는 실수들에 대해 생각해보고자 한다. </p>
<hr>
<p><strong>java.lang.String은 어떻게 생성자 없이도 객체가 생성되나?</strong></p>
<p>궁금증 하나로 출발해보고 싶다. 우리는 Java에서 문자열은 <em>객체</em> 라고 배웠다. </p>
<p>그러나 생성자는 쓰지 말라고 한다. 어디서 이런 미스매치가 발생한 걸까? </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"hello"</span></span><br></pre></td></tr></table></figure>
<p>라는 짤막한 문자열 선언이, 컴파일러를 통해 아래와 같이 바뀐다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>&#125;).intern();</span><br></pre></td></tr></table></figure>
<p>.intern() 이 뭐냐면…. 일단 java.lang.String 에는 이렇게 돼 있다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>native 코드를 호출하는 것 같다. </p>
<p>이 짤막한 메소드의 기능은 문자열 풀링(pooling)을 담당하는 것이다. 즉, 우리가 문자열을 만들면 우리는 우리가 만든 객체를 그대로 사용하는 게 아닌, JVM 내부에 형성된 literal pool의 객체를 가져다 쓰게 된다. </p>
<p>처음 문자열이 선언됐을 때 .intern()이 호출되고, 이 메소드는 JVM의 문자열 풀에 해당 객체와 같은 내용의 문자열이 기 존재하는지를 질의한다. 이때 .equals()를 사용한다. </p>
<p>만약 이미 객체가 있다면 문자열 풀은 해당 객체를 리턴하고, <strong>없다면 만들어진 문자열 객체를 문자열 풀에 집어넣은 후, 그 객체로 가는 참조를 리턴해준다.</strong> 즉 어떠한 경우에도 우리가 문자열 객체의 생명주기를 직접 통제할 수는 없다. </p>
<p>그래서 이런 결과가 발생하는 것이다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"a"</span> == <span class="string">"a"</span>);</span><br><span class="line"><span class="comment">//true가 출력된다.</span></span><br></pre></td></tr></table></figure>
<p>그러나 모든 문자열 생성이 다 .intern()을 타는 것은 아니다. <strong>동적으로 문자열을 만들어주는 대부분의 메소드에서 만들어진 문자열은 new String() 을 쓴다.</strong> .intern() 안 탄다. </p>
<p>위와 같이 비교할 수 있다고 해서 .equals()를 안 써도 되는 게 아니란 얘기다. </p>
<p>말장난 아니냐고 하면 할 말은 없는데 어쨌든 <strong>객체가 풀링되고 있다는 사실이 중요한거다.</strong> 비슷한 원리를 따르는 JVM의 신비가 또 하나 있는데 바로 wrapper class interning이다. </p>
<p>아래 코드는 true일까, false일까? </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">1</span>;</span><br><span class="line">Integer i2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">i1 == i2;</span><br></pre></td></tr></table></figure>
<p>이거 true. <strong>객체는 equals로 비교하라며?</strong></p>
<p>자, 그럼 아래 코드는 true일까 false일까? </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer big1 = <span class="number">1024</span>;</span><br><span class="line">Integer big2 = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">big1 == big2</span><br></pre></td></tr></table></figure>
<p>이거 false다. <em>ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ</em></p>
<p><strong>왜 그럴까?</strong></p>
<p>퍼포먼스 튜닝 목적으로 Integer라는 wrapper class에 대해 -127 ~ 128 사이의 값을 <strong>미리 보관해서 별도의 배열에 보관하고 있기 때문이다.</strong></p>
<p>java.lang.Integer를 까보면 아래와 같은 구현이 나온다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">         <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[] = <span class="keyword">new</span> Integer[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">static</span> &#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">                 cache[i] = <span class="keyword">new</span> Integer(i - <span class="number">128</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>Integer 클래스가 최초로 사용됐을 때 무조건 한 번 돌게 돼 있다. </p>
<p>Integer도 문자열과 같은 원리의 interning을 수행하고 있는 모습이다. </p>
<hr>
<p><strong>문자열은 객체인데 어떻게 + 연산자가 먹나?</strong></p>
<p>String 객체 어딘가에 해당 연산을 수행해주는 메소드가 있고, 그 메소드를 호출하는 것으로 컴파일 타임에 바꿔치기되기 때문은 아닐까?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"a"</span> + <span class="string">"b"</span></span><br></pre></td></tr></table></figure>
<p>의 연산은, </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> StringBuilder(<span class="string">"s"</span>).append(<span class="string">"b"</span>).toString();</span><br></pre></td></tr></table></figure>
<p>으로 실행된다. </p>
<p><em>어, 그러면 StringBuilder 안 써도 되겠네요?</em></p>
<p><strong>아뇨.</strong> </p>
<p>개발자의 판단과 책임으로, 문자열 더하기 연산이 지나치게 많이 반복되는 경우 처음부터 깔끔하게 StringBuilder를 사용하는 것이 좋다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String hello = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    hello += <span class="string">"hi"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>당신은 조금 전 10개의 스트링 빌더 객체를 생성해, 고작 “hi” 두 글자 더하고 내다 버렸다. </p>
<p>동양 컴퓨터공학에서는 이렇게 쉽게 객체를 버리는 경우 컴퓨터의 균형이 깨진다고 본다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder hello = <span class="keyword">new</span> StringBuilder(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String hi: hiList) &#123;</span><br><span class="line">    hello.append(hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hello.toString();</span><br></pre></td></tr></table></figure>
<p>이게 훨씬 좋은 구현이다. </p>
<p><strong>추가</strong></p>
<p>정상혁(<a href="https://www.facebook.com/benelog" target="_blank" rel="noopener">Sanghyuck Jung</a>)님이 아래와 같은 내용을 보충해 주셨다. </p>
<p><em>Java 9에서의 String concat 최적화</em> - StringConcatFactory 로 연결된다. (JDK 9 이상에서만 존재)</p>
<p><a href="http://openjdk.java.net/jeps/280" target="_blank" rel="noopener">http://openjdk.java.net/jeps/280</a></p>
<p><strong>.concat()이란 것도 있다면서요?</strong></p>
<p>있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[count + otherLen];</span><br><span class="line">    getChars(<span class="number">0</span>, count, buf, <span class="number">0</span>);</span><br><span class="line">    str.getChars(<span class="number">0</span>, otherLen, buf, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(<span class="number">0</span>, count + otherLen, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이렇게 생겼다. 그러나 <strong>일부러 이걸 쓸 일은 없을 것이다.</strong></p>
<p>보면 알겠지만 합칠 문자열을 받고, 그 문자열의 길이를 파악한 후, 그 문자열 길이 + 원 문자열 길이 만큼의 배열을 선언하고, 거기다가 원래 문자열의 CharArray를 덮고, 거기다가 합칠 문자열으 내용을 덮고, 그걸 또 새로운 String 객체의 생성자 파라메터로 넘겨서 객체를 만들어서 돌려주는 것이다. </p>
<p>이렇게 만들어지는 객체는 오버헤드를 엄청나게 유발할 뿐만 아니라 앞서 설명한 interning도 안 되어있는 것이다. </p>
<p>위의 내용 중에 오타가 있는 건 나도 알지만 그냥 쓰다보니 빡쳐서 바로잡지 않은 것이다. </p>
<p><strong>쓰지 마세요.</strong></p>
<hr>
<p><em>StringBuilder도 있고, StringBuffer도 있잖아요?</em></p>
<p>맞다. <strong>두 클래스의 차이에 대해 인지한 후 정확한 상황판단 하에 사용해라.</strong></p>
<p>단순 취향 차이가 아닌 실제 퍼포먼스에서의 차이가 상당 부분 발생한다. </p>
<p>코드를 보자. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span>  <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>,<span class="title">CharSequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">AbstractStringBuilder() &#123;&#125;</span><br><span class="line"></span><br><span class="line">AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line"></span><br><span class="line">          value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>StringBuilder의 super class인 AbstractStringBuilder인데 char[] 로 문자열에 대한 관리를 하고 있음을 알 수 있다. </p>
<p>그럼 StringBuffer는? AbstractStringBuilder를 extend하는 것은 같지만….</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">char</span>[] toStringCache;</span><br></pre></td></tr></table></figure>
<p>문제의 코드다. char[] 를 transient로 관리하고 있는 모습이다. </p>
<p>뿐만 아니다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">char</span> More ...charAt(<span class="keyword">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= count))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">    <span class="keyword">return</span> value[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer More ...append(CharSequence s) &#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>모든 메소드에 synchronized 예약어가 달려있다. 느려질 수밖에 없는 구조다. </p>
<p><a href="https://stackoverflow.com/questions/1671089/why-are-synchronize-expensive-in-java" target="_blank" rel="noopener">synchronized가 왜 느릴까요?</a></p>
<p>JavaDoc에서 충분히 밝히고 있는 것처럼 StringBuffer는 thread-safe함이 요구되는 상황에서만 <strong>제한적으로</strong> 사용하는 것이 맞다. 남발할 경우 실행 속도가 느려질 수밖에 없을 것이다. </p>
<p>개인적인 실험을 해본 적이 있었는데 StringBuilder와 StringBuffer의 .append()를 1억번 정도 콜한 경우 대략 3초 내외의 퍼포먼스 차이가 났던 것으로 기억한다. </p>
<p>3초면 3000ms. 꽤 큰 차이다.</p>
<hr>
<h4 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h4><p>사실 우리 모두가 프로그래밍 좀 하다보면 문자열에 대한 이해가 출중할 거라 자부하지만 의외로 오개념을 갖고있을 수도 있다. </p>
<p>나도 이번 포스팅을 준비하며 찾아본 자료들에서 신선한 충격을 받은 경험이 꽤 있었다.</p>
<p>어쨌든, 기초가 참 중요한 것 같다. 익숙한 것부터 바로, 잘 알자!</p>
-->
      
    </div>
    <footer class="article-footer">
      <!--<a data-url="https://tech.wheejuni.com/2018/05/21/java-string/" data-id="ckk5ihpxe008tdg9o4n2nhl0o" class="article-share-link">공유</a>-->
      
        <a href="https://tech.wheejuni.com/2018/05/21/java-string/#disqus_thread" class="article-comment-link">댓글</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 이전</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/">다음 &raquo;</a>
  </nav>

</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 정휘준<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> with 
      theme_by <a href="http://hexo.io/" target="_blank">mango</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives/" class="mobile-nav-link">Archives</a>
  
    <a href="/about/" class="mobile-nav-link">about</a>
  
</nav>
    
<script>
  var disqus_shortname = 'bomee';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>