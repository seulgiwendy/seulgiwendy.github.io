<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>봄이네집 개발 블로그</title>
  
  <subtitle>봄이네집에 오신 것을 환영합니다.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tech.wheejuni.com/"/>
  <updated>2021-01-31T03:32:11.467Z</updated>
  <id>https://tech.wheejuni.com/</id>
  
  <author>
    <name>정휘준</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FastAPI로 간단한 API 개발을 시도해 본다 - (3) 데이터소스 연동하기</title>
    <link href="https://tech.wheejuni.com/2021/01/30/python-fastapi-3/"/>
    <id>https://tech.wheejuni.com/2021/01/30/python-fastapi-3/</id>
    <published>2021-01-30T14:22:00.000Z</published>
    <updated>2021-01-31T03:32:11.467Z</updated>
    
    <content type="html"><![CDATA[<h3 id="FastAPI를-이용한-간단한-API-개발-데이터소스-연동하기"><a href="#FastAPI를-이용한-간단한-API-개발-데이터소스-연동하기" class="headerlink" title="FastAPI를 이용한 간단한 API 개발 - 데이터소스 연동하기"></a>FastAPI를 이용한 간단한 API 개발 - 데이터소스 연동하기</h3><p>이번 포스팅에서는 실제 데이터소스를 연동하여 FastAPI를 통해 CRUD 작업을 진행할 수 있도록 개발해 본다. </p><p>지난 포스팅까지 살펴본 과정은 FastAPI가 제공하는 기능에 강한 종속성이 걸리는 과정이었다면, 지금부터는 그렇지 않다. 만약 이미 익숙해진 Python의 데이터소스 관련 기술이 있다면, 그것을 활용하면 된다. 또한 이 포스팅에선 MySQL 기반의 개발을 진행하겠지만, 경우에 따라 NoSQL이나 기타 다른 데이터소스의 연동을 진행할 필요가 얼마든지 생길 것이다. 그렇다면 그에 맞춰 유연히 프로젝트를 진행하면 된다. </p><p>FastAPI가 공식 문서에서 권장하는 <a href="https://fastapi.tiangolo.com/tutorial/sql-databases/" target="_blank" rel="noopener">관계형 데이터베이스 연동 방법</a> 은 SQLAlchemy를 이용한 연동이다. SQLAlchemy는 Python 진영에서 널리 쓰이는 ORM 프레임워크(라고 알고있)다. </p><p>이 포스팅에서도 관계형 데이터베이스를 SQLAlchemy를 통해 연동하는 방법에 대해 살펴보도록 한다. </p><h4 id="필요-종속성-추가"><a href="#필요-종속성-추가" class="headerlink" title="필요 종속성 추가"></a>필요 종속성 추가</h4><p>아래 명령을 수행해 필요한 종속성을 추가해준다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install SQLAlchemy</span><br><span class="line">pip install mysql</span><br></pre></td></tr></table></figure><h4 id="설정-클래스-작성"><a href="#설정-클래스-작성" class="headerlink" title="설정 클래스 작성"></a>설정 클래스 작성</h4><p>여느 ORM 프레임워크가 그렇듯이 설정 클래스의 작성부터 시작해야 한다. </p><p>SQLAlchemy를 통해 DB 커넥션이 추상화되어 있고, 추상화된 커넥션을 주입받아 앞으로의 요청을 처리하게 될 것이다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"></span><br><span class="line">DB_URL = &#123;DB_HOST&#125;</span><br><span class="line"></span><br><span class="line">engine = create_engine(DB_URL, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">SessionLocal = sessionmaker(autocommit=<span class="literal">False</span>, autoflush=<span class="literal">False</span>, bind=engine)</span><br><span class="line"></span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_db</span><span class="params">()</span>:</span></span><br><span class="line">    db = SessionLocal()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> db</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        db.close()</span><br></pre></td></tr></table></figure><p><code>Base</code> 객체는 앞으로 모델 클래스를 작성할 때 상속받을 베이스 모델이 된다. 또한, <code>get_db()</code> 는 요청을 처리하는 곳에서 주입받아 DB와의 커넥션을 획득하는 메소드가 될 것이다. </p><h4 id="모델-클래스-작성"><a href="#모델-클래스-작성" class="headerlink" title="모델 클래스 작성"></a>모델 클래스 작성</h4><p>설정이 완료되었다면, 모델 클래스의 작성을 시작한다. 보통의 ORM 프레임워크처럼 DB에 기술된 칼럼 정보를 사용하고 있는 언어의 객체로 옮겨오는 작업이다. </p><p>칼럼 타입과 매핑 정보를 ORM 프레임워크의 문법에 맞게 작성해주면 된다. 이때, 좀전의 설정 클래스에서 선언했던 <code>Base</code> 클래스를 불러와 상속받는다는 개념을 잊으면 안 된다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, Integer, String, Float, Boolean</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> database</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(database.Base)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">"user"</span></span><br><span class="line"></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>, index=<span class="literal">True</span>)</span><br><span class="line">    username = Column(String, nullable=<span class="literal">False</span>)</span><br><span class="line">    password = Column(String, nullable=<span class="literal">False</span>)</span><br><span class="line">    nickname = Column(String, nullable=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><code>Base</code> 를 상속받아 간단한 유저 클래스를 만들어 보았다. 앞서 언급했던 것처럼 DB에 기술된 칼럼 타입과, 클래스가 가질 속성을 매핑해주는 작업이라고 보면 된다. </p><p><strong>놀랍게도 여기까지 진행했다면, 실제 요청의 처리에서 DB를 연동할 준비는 사실상 모두 끝난 것이다.</strong> </p><h4 id="FastAPI와의-연동"><a href="#FastAPI와의-연동" class="headerlink" title="FastAPI와의 연동"></a>FastAPI와의 연동</h4><p>여기까지 잘 진행했다면, FastAPI의 요청 처리부와 데이터베이스 관련 클래스들을 잘 연동시켜주면 된다. </p><p>데이터베이스 설정 클래스를 작성할때, <code>get_db()</code> 함수를 이용해 데이터베이스 커넥션이 수립될 것이라고 언급했다. FastAPI가 제공하는 <code>Depends</code> 를 이용해 이 함수의 결과값을 종속성 주입으로 주입받고, 요청이 들어올 때마다 데이터베이스를 연결하면 된다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Depends, Path, HTTPException</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> Session</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> models, database</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(path="/api/v1/users/&#123;user_id&#125;")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_place</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        place_id: int,</span></span></span><br><span class="line"><span class="function"><span class="params">        db: Session = Depends<span class="params">(database.get_db)</span>)</span>:</span></span><br><span class="line">    result = db.query(models.User).filter(models.User.id == user_id).first()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">404</span>, detail=<span class="string">"ID에 해당하는 User가 없습니다."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">"status"</span>: <span class="string">"OK"</span>,</span><br><span class="line">        <span class="string">"data"</span>: result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>SQLAlchemy가 제공하는 <code>filter</code> 를 이용해, request parameter로 받은 ID에 해당하는 사용자를 검색했고, 이를 리스폰스로 리턴하는 간단한 코드를 작성해 보았다. </p><h4 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h4><p>이 포스팅을 통해 간단한 SQLAlchemy 모델 클래스를 구현하여 FastAPI 앱과 연동하고, 쿼리 결과를 API로 노출하는 구현을 진행해 보았다. </p><p>이 단계까지 진행했다면 앞으로 FastAPI를 통해 간단한 웹 애플리케이션을 구현하는 것에는 아무런 문제가 없을 것이다. 간단한 코드를 통해 데이터베이스 연동까지 마칠 수 있으므로 PoC 단계의 API 애플리케이션이나 개발 속도가 중요한 API 프로젝트 개발 진행에는 주요한 옵션으로 FastAPI가 채택될 수 있을 것 같다. </p><p>물론 uvicorn이라는 생소한 ASGI 프레임워크를 사용해야 하고, 개인적으론 Python 기반 웹 애플리케이션의 디버깅이나 다양한 이슈 해결에 관한 경험이 부족하므로 현업 개발에서 이 프레임워크를 통해 API를 서브하기에는 큰 부담감을 느낄 것 같기는 하다. </p><p>이미 Python 기반 웹 애플리케이션 서빙에 익숙해져있거나, Flask나 DRF 일변도의 API 개발에 지루함을 느끼는 개발자들이 FastAPI를 많이 택해 주시고, 현업에서의 운영 후기도 많이 남겨주셨으면 하는 바램을 가져본다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;FastAPI를-이용한-간단한-API-개발-데이터소스-연동하기&quot;&gt;&lt;a href=&quot;#FastAPI를-이용한-간단한-API-개발-데이터소스-연동하기&quot; class=&quot;headerlink&quot; title=&quot;FastAPI를 이용한 간단한 API 개발 
      
    
    </summary>
    
      <category term="python" scheme="https://tech.wheejuni.com/categories/python/"/>
    
      <category term="fastapi" scheme="https://tech.wheejuni.com/categories/python/fastapi/"/>
    
      <category term="backend_development" scheme="https://tech.wheejuni.com/categories/python/fastapi/backend-development/"/>
    
    
  </entry>
  
  <entry>
    <title>FastAPI로 간단한 API 개발을 시도해 본다 - (2) 요청 처리하기</title>
    <link href="https://tech.wheejuni.com/2021/01/22/python-fastapi-2/"/>
    <id>https://tech.wheejuni.com/2021/01/22/python-fastapi-2/</id>
    <published>2021-01-22T14:22:00.000Z</published>
    <updated>2021-01-23T00:41:13.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="FastAPI를-이용한-간단한-API-개발-HTTP-Request-처리하기"><a href="#FastAPI를-이용한-간단한-API-개발-HTTP-Request-처리하기" class="headerlink" title="FastAPI를 이용한 간단한 API 개발 - HTTP Request 처리하기"></a>FastAPI를 이용한 간단한 API 개발 - HTTP Request 처리하기</h3><p>이전 포스팅을 통해 FastAPI 기반의 API 개발 환경을 만들고, 간단한 <code>Hello World</code> 를 노출하는 GET API를 구현해 보았다. </p><p>이번에는 HTTP API라면 당연히 수행해야 할, 몇가지 형태의 HTTP Request 처리를 해보고자 한다. </p><h4 id="Pydantic"><a href="#Pydantic" class="headerlink" title="Pydantic"></a>Pydantic</h4><p>FastAPI에서는 모델 클래스의 type safety 및 요청 주입을 위해 <a href="https://pydantic-docs.helpmanual.io/" target="_blank" rel="noopener">Pydantic</a> 의존성을 사용한다. </p><p>어떻게 보면 TypeScript를 도입했던 JS 진영처럼 Python도 점점 타입 안전성에 대한 고려와 이를 위한 유틸리티들이 늘어간다고도 볼 수 있을 것 같다. </p><p>Pydantic이 제공하는 <code>BaseModel</code> 을 상속받아 Python 클래스를 작성하고, 이 클래스를 사용하면서 타입에 관한 IDE의 힌트를 얻을 수도 있고, 필드에 의도했던 데이터 타입이 들어갔는지도 검증할 수 있다. Java로 치면 POJO + JSR-303(380) 과 같은 느낌이다. </p><p>본격적인 개발 진행을 위해 아래 명령어를 수행해 Pydantic을 추가해 준다.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pydantic</span><br></pre></td></tr></table></figure><h4 id="Endpoint-작성"><a href="#Endpoint-작성" class="headerlink" title="Endpoint 작성"></a>Endpoint 작성</h4><p><code>hello world</code> API 구현에서 봤던 것처럼 FastAPI도 애노테이션 기반 엔드포인트 작성을 지원한다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(path="/")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world"</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(path="/hello/&#123;name&#125;)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello_with_name</span><span class="params">(name: str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello with name. your name is "</span> + name</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(path="/hello/query/)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello_with_querystring</span><span class="params">(name: str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello with name. your name is "</span> + name</span><br></pre></td></tr></table></figure><p>이전에 구현해뒀던 <code>hello world</code> API에 더불어서, 경로 변수를 사용할 수 있는 API를 하나 추가하였다. </p><p>경로 변수의 사용은 Spring MVC가 지원하는 argument resolution 기반의 경로 변수 매핑과 아주 흡사하다. <code>path</code> 에 중괄호를 이용해 경로변수의 위치 및 이름을 선언한 후, 함수의 파라메터로 같은 이름을 갖는 변수를 받아오면 경로 변수로 넘어온 값이 매핑된다. </p><p>아래 <code>hello_with_querystring</code> 은 FastAPI가 쿼리스트링 기반의 요청을 처리하는 방법을 보여주는 것이다. 함수의 파라메터로 선언된 변수의 이름에 해당하는 쿼리 스트링 파라미터를 FastAPI가 자동으로 매핑해준다. 즉, 이 요청 처리 함수가 처리할 수 있는 HTTP GET 요청의 주소는 아래와 같은 모습을 띄게 된다. </p><p><code>{HOSTNAME}/hello/query?name=봄이네집</code></p><h4 id="POST-요청-매핑-Pydantic-Model-작성"><a href="#POST-요청-매핑-Pydantic-Model-작성" class="headerlink" title="POST 요청 매핑 - Pydantic Model 작성"></a>POST 요청 매핑 - Pydantic Model 작성</h4><p>POST 요청 매핑을 위해 우선 아까 추가했던 종속성인 Pydantic 기반의 모델 클래스를 작성해 준다. </p><p>Kotlin의 <code>data class</code> 와 유사한 문법으로, 필드명과 타입을 작성해주면 빠르고 편하게 모델 클래스의 작성이 끝난다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pydantic.main <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorldRequest</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    name: str</span><br><span class="line">    age: int</span><br></pre></td></tr></table></figure><h4 id="POST-요청-매핑-요청-처리-함수-작성"><a href="#POST-요청-매핑-요청-처리-함수-작성" class="headerlink" title="POST 요청 매핑 - 요청 처리 함수 작성"></a>POST 요청 매핑 - 요청 처리 함수 작성</h4><p>앞서서 작성한 모델 클래스를 기반으로, 요청 처리 함수를 추가한다. </p><p>그동안 했던 것처럼, 모델 클래스를 함수의 파라메터로 받아주면 요청을 처리할 준비가 끝난다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic.main <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorldRequest</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    name: str</span><br><span class="line">    age: int</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(path="/")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world"</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(path="/hello/&#123;name&#125;)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello_with_name</span><span class="params">(name: str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello with name. your name is "</span> + name</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(path="/hello/query/)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello_with_querystring</span><span class="params">(name: str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello with name. your name is "</span> + name</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(path="/hello/post)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello_post</span><span class="params">(request: HelloWorldRequest)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello with post. your name: &#123;&#125;, your age: &#123;&#125;"</span></span><br><span class="line">            .format(request.name, request.age)</span><br></pre></td></tr></table></figure><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>간단하게 FastAPI를 이용해 HTTP 요청을 처리하는 방법을 알아봤다. </p><p>이 단계만 되어도 FastAPI의 고유 기능을 이용해 HTTP Request를 처리할 모든 준비는 끝난 것 같다. 물론 전통적인 3-tier web application의 구조를 보면, 우리는 아직 DB 통신을 할 준비를 하지 못했고, 상용 서버에 애플리케이션을 노출할 구현도 하지 않았다. </p><p>그러나 request/response mapping이라는 웹 API Framework의 본질로 본다면 이후 단계는 개발자의 선택에 따라 얼마든지 다른 모듈을 채택할 수도 있고, 커스터마이즈하는 것도 가능하다. </p><p>예를 들어, <del>잠시 스포하자면</del> 다음 포스팅에선 SQLAlchemy를 이용해 MySQL DBMS에 질의해 요청을 처리하는 과정을 살펴볼 것인데, FastAPI 공식 문서가 추천하는 바 대로 SQLAlchemy를 사용할 뿐이고 실제 개발 상에서는 여타 다른 Python 진영의 데이터베이스 프레임워크를 사용해도 아무 문제가 없다. </p><p>즉, 여기까지만 읽어도 숙달된 Python 개발자라면 이미 FastAPI를 이용해 마이크로서비스 하나 정도는 개발할 수 있는 준비가 되었다고 판단된다. </p><p>감사하게도 여기까지 제 포스팅을 흥미있게 읽어 주셨다면, FastAPI를 이용해 간단한 서비스 하나를 직접 구현해보는 것을 강력히 추천한다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;FastAPI를-이용한-간단한-API-개발-HTTP-Request-처리하기&quot;&gt;&lt;a href=&quot;#FastAPI를-이용한-간단한-API-개발-HTTP-Request-처리하기&quot; class=&quot;headerlink&quot; title=&quot;FastAPI를 이
      
    
    </summary>
    
      <category term="python" scheme="https://tech.wheejuni.com/categories/python/"/>
    
      <category term="fastapi" scheme="https://tech.wheejuni.com/categories/python/fastapi/"/>
    
      <category term="backend_development" scheme="https://tech.wheejuni.com/categories/python/fastapi/backend-development/"/>
    
    
  </entry>
  
  <entry>
    <title>FastAPI로 간단한 API 개발을 시도해 본다 - (1) 프로젝트 시작하기</title>
    <link href="https://tech.wheejuni.com/2021/01/20/python-fastapi-1/"/>
    <id>https://tech.wheejuni.com/2021/01/20/python-fastapi-1/</id>
    <published>2021-01-20T14:22:00.000Z</published>
    <updated>2021-01-21T00:54:47.072Z</updated>
    
    <content type="html"><![CDATA[<h3 id="FastAPI를-사용해-간단한-API-개발을-해-본다"><a href="#FastAPI를-사용해-간단한-API-개발을-해-본다" class="headerlink" title="FastAPI를 사용해 간단한 API 개발을 해 본다."></a>FastAPI를 사용해 간단한 API 개발을 해 본다.</h3><p>한참 Python의 간결함(?) 에 매료되어 있을 때, Python을 이용해 Web API 개발을 시도해본 적이 있다. </p><p>당시 사용했던 프레임워크로는 <a href="https://flask.palletsprojects.com/en/1.1.x/" target="_blank" rel="noopener">Flask</a> 와 <a href="https://www.django-rest-framework.org/" target="_blank" rel="noopener">Django REST Framework</a> 였던 것으로 기억한다. 둘 다 훌륭한 프레임워크였지만 지금은 기억나지도 않는 석연찮은 이유 <del><em>아마도 취업의 압박</em></del> 으로 인해 Python 자체를 멀리하게 되면서 이들 프레임워크를 사용하는 일도 자연스레 줄어들게 되었다. </p><p>당시 Django를 이용해 프로젝트를 진행했던 흔적은 <a href="https://github.com/wheejuni/hey-django" target="_blank" rel="noopener">여기</a> 에 남아있다. </p><p>몇주 전부터 미디엄(medium.com)의 뉴스레터가 계속 Python 기반의 웹 API 프로젝트 진행 사례에 대해 글을 모아 보내주는 걸 보면서, 다시 한 번 Python에 대한 호기심이 생기기 시작했다. 최근 서비스들이 개인화/추천 피쳐 없이 출시되는 경우가 드문데, 대다수의 데이터 과학자들/머신러닝 엔지니어들에게 사랑받는 언어, 그리고 ML 분야로 엔지니어 포지션을 갖고자 할때 <a href="*https://www.springboard.com/blog/best-programming-language-for-ai/">배워야 할 언어</a> 로 꼽히는 언어가 Python임을 생각해본다면, 아무래도 데이터 인그레스 - 데이터 가공 - 모델링 - API를 통한 서브까지 모든 생명주기를 하나의 언어로 구현할 수 있는 방법을 찾다보니 Python 기반의 웹 API 개발이 다시 한 번 각광받는 듯하다. 관련한 자료는 아래의 링크들에서 참고해볼 수 있다. </p><p><a href="https://testdriven.io/blog/fastapi-machine-learning/" target="_blank" rel="noopener">https://testdriven.io/blog/fastapi-machine-learning/</a></p><p><a href="https://medium.com/@8B_EC/tutorial-serving-machine-learning-models-with-fastapi-in-python-c1a27319c459" target="_blank" rel="noopener">https://medium.com/@8B_EC/tutorial-serving-machine-learning-models-with-fastapi-in-python-c1a27319c459</a></p><p>기존의 Django, Flask가 쉽게 말로 표현할 수 없는 사용상의 불편함과 컨벤션의 장황함(…) 으로 인해 그렇게 애정이 가지 않았었는데, 이번에 시도해 볼 FastAPI는 그런 어려움을 많이 해소했기를 바라면서 프로젝트를 시작해 보았다.</p><h3 id="준비작업"><a href="#준비작업" class="headerlink" title="준비작업"></a>준비작업</h3><p>보통의 Python 프로젝트가 늘 그렇듯, 가상환경을 통해 의존성을 격리시키는 작업이 먼저 이뤄져야 할 것 같다. </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m venv &#123;VENV_DIR_NAME&#125;</span><br></pre></td></tr></table></figure><p>이후에는 FastAPI 프로젝트의 생성 및 구동에 필요한 필수 의존성들을 추가해 준다. 참고로 FastAPI의 깃허브 저장소는 <a href="https://github.com/tiangolo/fastapi" target="_blank" rel="noopener">이 링크</a> 에서 살펴볼 수 있고, 공식 문서는 <a href="https://fastapi.tiangolo.com/" target="_blank" rel="noopener">여기</a> 에서 확인하면 된다. </p><h4 id="필요한-의존성"><a href="#필요한-의존성" class="headerlink" title="필요한 의존성"></a>필요한 의존성</h4><p>Python 기반 웹 API의 개발이므로 WSGI 구현체가 우선 필요하고, 물론 FastAPI 의존성도 추가되어야 <code>hello world</code> 를 띄울 수 있다. </p><p>Django에선 WSGI 구현체로 <a href="https://uwsgi-docs.readthedocs.io/en/latest/" target="_blank" rel="noopener">uwsgi</a>를 권장했던 것 같지만, FastAPI에서는 <a href="https://www.uvicorn.org/" target="_blank" rel="noopener">uvicorn</a>을 권장한다. 권장하는 이유는 uvicorn이 비동기 애플리케이션을 위한 <a href="https://asgi.readthedocs.io/en/latest/" target="_blank" rel="noopener">ASGI</a> 규격을 지원하기 때문이다. </p><p>따라서, 빠르게 프로젝트를 시작하기 위해서는 아래 명령어를 수행해 두 의존성을 추가해 주는 것으로 출발하면 된다. </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install uvicorn</span><br><span class="line">pip install fastapi</span><br></pre></td></tr></table></figure><h4 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world!"></a>hello world!</h4><p>간단한 <code>hello world</code> 스타터를 위해서는 아래의 코드를 작성해주면 된다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(path="/")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure><p>애플리케이션을 구동하기 위해서는 ASGI 구현체인 uvicorn의 도움을 받아야 한다. 우선 상기한 코드를 작성한 디렉터리로 이동한 이후, 아래 명령을 수행하면 된다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uvicorn &#123;APP_FILE_NAME&#125;:&#123;FASTAPI_INSTANCE_VAR_NAME&#125; --reload</span><br></pre></td></tr></table></figure><p>실행한 옵션과 파라메터에 대해 간단히 정리하자면…</p><ul><li><em>APP_FILE_NAME</em> : 실제 코드가 작성된 파일의 이름(위치).</li><li><em>FASTAPI_INSTANCE_VAR_NAME</em> : 코드 상에 FastAPI 인스턴스가 할당된 변수명을 입력한다. 예시 코드에선 <code>app</code> 이다. </li><li><code>--reload</code> : 핫 릴로드를 지원하도록 설정한다. </li></ul><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>간단하게 FastAPI를 이용해 <code>hello world</code> 를 찍어봤다. </p><p>Java/Spring 을 즐겨 <del>(먹고살기 위해)</del> 사용하는 개발자의 눈으로 보면, Python 기반 웹 프레임워크들의 프로젝트 부트스트래핑 속도나, hello world를 띄울 때까지의 코드 작성량은 정말 부럽다. </p><p>다음 포스팅을 통해 Web API 개발에 필수적인 파라미터 바인딩과 데이터소스 접근에 대해서도 정리해 보려고 한다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;FastAPI를-사용해-간단한-API-개발을-해-본다&quot;&gt;&lt;a href=&quot;#FastAPI를-사용해-간단한-API-개발을-해-본다&quot; class=&quot;headerlink&quot; title=&quot;FastAPI를 사용해 간단한 API 개발을 해 본다.&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="python" scheme="https://tech.wheejuni.com/categories/python/"/>
    
      <category term="fastapi" scheme="https://tech.wheejuni.com/categories/python/fastapi/"/>
    
      <category term="backend_development" scheme="https://tech.wheejuni.com/categories/python/fastapi/backend-development/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift 맛보기(1) - Java와 Swift의 열거형을 비교해보다.</title>
    <link href="https://tech.wheejuni.com/2019/06/10/swift-java-enumeration/"/>
    <id>https://tech.wheejuni.com/2019/06/10/swift-java-enumeration/</id>
    <published>2019-06-09T23:40:00.000Z</published>
    <updated>2021-01-20T14:13:54.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Swift로-조금씩-뭔가-만들어보고-있다"><a href="#Swift로-조금씩-뭔가-만들어보고-있다" class="headerlink" title="Swift로 조금씩 뭔가 만들어보고 있다."></a>Swift로 조금씩 뭔가 만들어보고 있다.</h2><p>무료하고 때론 우울하기까지 한 개발자 생활에 약간의 변화가 필요한 시점인 것 같아, 완전히 다른 언어를 배우고 있다. </p><p>JVM 바깥 세상으로 길을 나서는 것이 두렵게 느껴지기까지 했지만 새로 학습할 언어로 <a href="https://swift.org/" target="_blank" rel="noopener">Swift</a> 를 선택하였다. </p><p>개발 공부를 시작한 이래로 줄곧 서버측 개발에 즐겨 사용되는 언어와 프레임워크만을 학습하였다. Python으로 처음 개발에 입문했고, 이후 Java, Ruby, Scala, Kotlin(이 언어들을 다 잘한다는 건 아니다)을 학습하며 주로 서버 구축, 서버 사이드 앱 개발에만 집중해왔다. </p><p>나의 경쟁력(?) 을 늘리는 측면도 있지만 앞으로 1인 개발자로서 나만의 비즈니스를 하게될 때, 혹은 정말 재미로 이것저것 만들어보게 될 때 클라이언트 사이드 개발이 꼭 필요하게 될 것 같아 큰 맘 먹고 Swift와 Swift를 이용한 iOS 앱 프로그래밍까지 학습해보려고 한다. <em>서버사이드 개발자들보다 클라이언트 개발자들이 더 재밌게 사는 것 같기도 하다.</em></p><p>학습 방법은 내가 기존에 경험했던 그대로, 두꺼운 책을 보며 시작하지 않고 일단 뭐라도 만들어보며 배우려고 한다. 코드스쿼드 시절 부여받았던 다양한 도전과제들을 Swift로 구현해보는 것이 좋은 출발이 될 것이다. </p><h2 id="그래서-로또게임을-구현해보고-있다"><a href="#그래서-로또게임을-구현해보고-있다" class="headerlink" title="그래서 로또게임을 구현해보고 있다."></a>그래서 로또게임을 구현해보고 있다.</h2><p>내가 생각하기에 간단한 콘솔 기반 로또게임은 새로운 언어를 배우기에 정말 좋은 프로젝트다. 우선, 적당한 수준의 분기처리가 존재하고, 적당한 수준의 stdin-stdout 함수를 활용할 수 있으며, 적당한 수준의 문자열 포맷팅을 경험할 수 있다. </p><p>맘먹기에 따라 날코딩으로 700줄짜리 통짜 클래스로 구현할 수도 있고 객체지향의 묘를 살려 관심사의 분리, 역할의 위임, 느슨한 결합 등을 구현해보는 것도 얼마든지 가능하다(자바로 이 짓을 하다가 결국 포비로부터 머지받지 못하였다). </p><p>오늘 살펴볼 부분은 로또게임의 당첨 등수를 열거형(enum)으로 표현하며 느낀, Java와 Swift 사이의 열거형의 차이점이다. </p><h3 id="enum은-간단한-개념이다"><a href="#enum은-간단한-개념이다" class="headerlink" title="enum은 간단한 개념이다."></a>enum은 간단한 개념이다.</h3><p>말 그대로 열거해주면 된다. “열거” 라는 표현법 그 자체는 두 언어가 크게 다르지 않다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PortalSites &#123;</span><br><span class="line">    NAVER,</span><br><span class="line">    GODKAO,</span><br><span class="line">    GODGLE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PortalSites</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> naver, godkao, godgle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>case라는 키워드가 앞에 붙는다는 점 빼곤 크게 다를 바가 없어 보인다. </p><p><strong>enum의 호출</strong></p><p>변수에 할당하는 방법도 양 언어가 거의 같다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PortalSites naver = PortalSites.NAVER;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> naver = <span class="type">PortalSites</span>.naver</span><br></pre></td></tr></table></figure><p><strong>enum에 행위 추가하기</strong></p><p>차이점은 여기서 발생하는 것 같다. </p><p>열거형에 행위를 추가하려면 Swift의 경우 <code>protocol</code>, Java의 경우 <code>interface</code>를 구현시켜야 하는 점은 비슷하다. </p><p>아까 구현한 <code>PortalSites</code> enum에 홈페이지 주소를 리턴하는 행위를 추가하는 상황을 가정해 보자. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PortalSiteAction</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getHomepageUrl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PortalSiteHomepage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> homepageUrl: <span class="type">String</span> &#123;<span class="keyword">get</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기까진 비슷한 것 같다. 사실 여기까지만 보고 Swift에서의 구현도 Java와 별 다를게 없다고 생각했었다. </p><p>그러나 <a href="https://github.com/code-squad/swift-cardgame/blob/youth27/CardGame/CardGame/CardDeck.swift" target="_blank" rel="noopener">다른 분들의 코드</a>를 참고하다보니 아래와 같이 <code>switch</code> 문으로 행위를 분기처리하는것이 인상적이었다. </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Denomination</span>: <span class="title">Int</span>, <span class="title">CustomStringConvertible</span>, <span class="title">EnumCollection</span>, <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> two = <span class="number">2</span>, three, four, five, six, seven, eight, nine, ten, eleven, twelve, thirteen, ace</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .ace: <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">            <span class="keyword">case</span> .eleven: <span class="keyword">return</span> <span class="string">"J"</span></span><br><span class="line">            <span class="keyword">case</span> .twelve: <span class="keyword">return</span> <span class="string">"Q"</span></span><br><span class="line">            <span class="keyword">case</span> .thirteen: <span class="keyword">return</span> <span class="string">"K"</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="type">String</span>(<span class="keyword">self</span>.rawValue)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    (...)</span><br></pre></td></tr></table></figure><p>상기한 사례를 참고해 <code>PortalSites</code> enum을 완성시키면 아래와 같이 될 것이다. </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PortalSites</span>: <span class="title">PortalSiteHomepage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> naver, godkao, godgle</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> homepageUrl: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .naver: <span class="keyword">return</span> <span class="string">"https://www.naver.com"</span></span><br><span class="line">            <span class="keyword">case</span> .godkao: <span class="keyword">return</span> <span class="string">"https://www.daum.net"</span></span><br><span class="line">            <span class="keyword">case</span> .godgle: <span class="keyword">return</span> <span class="string">"https://www.google.com"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>인상적인 문법이라고 생각됐다. </p><p><strong>인상적으로 느껴진 이유</strong> </p><ul><li><p>Java의 <code>interface</code>에 상응하는 개념인 <code>protocol</code>이 메소드와 리턴 타입에 집중하지 않고, 변수 그 자체를 공통으로 선언할 수 있게 해준 점이 인상적이었다. </p></li><li><p>각각의 enum이 가져야 할 공통 변수를 선언하고, <code>switch</code> 문을 적극적으로 사용하여 코드량을 줄인 것이 인상적이었다. </p></li><li><p>같은 분량의 확장을 할 때에, Java보다 작성해야 할 코드가 훨씬 줄어들 것 같다. </p></li></ul><p><strong>Java에 적용해볼 수는 없을까?</strong></p><p>Java의 enum도 인터페이스를 구현할 때에, 공통 메소드로서 구현하는 것이 가능하기 때문에, 아래와 같은 구현도 가능해진다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PortalSites implements PortalSiteAction &#123;</span><br><span class="line">    NAVER,</span><br><span class="line">    GODKAO,</span><br><span class="line">    GODGLE</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHomepageUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> NAVER:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"https://www.naver.com"</span>;</span><br><span class="line">            <span class="keyword">case</span> GODKAO:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"https://www.daum.net"</span>;</span><br><span class="line">            <span class="keyword">case</span> GODGLE:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"https://www.google.com"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사실 이런 식의 구현은 지금까지 코딩하며 시도해본 적도 없고 이렇게 구현한 사례를 본 기억도 잘 없다. </p><p>그러나 enum을 추가할 때마다 로직이 바뀌어야만 하는 부분이 있다면, 이런 종류의 분기처리를 시도해보는 것도 괜찮을 것 같다. </p><p>특히 functional interface와 결합한다면 클린 코드를 만드는 데에 더 큰 도움이 될 것 같다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Swift로-조금씩-뭔가-만들어보고-있다&quot;&gt;&lt;a href=&quot;#Swift로-조금씩-뭔가-만들어보고-있다&quot; class=&quot;headerlink&quot; title=&quot;Swift로 조금씩 뭔가 만들어보고 있다.&quot;&gt;&lt;/a&gt;Swift로 조금씩 뭔가 만들어보고
      
    
    </summary>
    
      <category term="java" scheme="https://tech.wheejuni.com/categories/java/"/>
    
      <category term="swift" scheme="https://tech.wheejuni.com/categories/java/swift/"/>
    
    
  </entry>
  
  <entry>
    <title>TDD 흉내 내며 즐겁게 리팩토링하기.</title>
    <link href="https://tech.wheejuni.com/2019/03/25/tdd-refactoring-2019/"/>
    <id>https://tech.wheejuni.com/2019/03/25/tdd-refactoring-2019/</id>
    <published>2019-03-24T23:40:00.000Z</published>
    <updated>2021-01-20T14:13:54.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TDD를-하는-척-하며-즐겁게-리팩토링해보자"><a href="#TDD를-하는-척-하며-즐겁게-리팩토링해보자" class="headerlink" title="TDD를 하는 척 하며 즐겁게 리팩토링해보자."></a>TDD를 하는 척 하며 즐겁게 리팩토링해보자.</h2><p>TDD처럼 논란의 한 복판에 서 있는 개발 방법론도 흔치 않을 것이다. </p><blockquote><p>TDD 그거 완전 시간 낭비다. 하지마라. 번거롭다. <em>유닛 테스트도 커버리지에 집착할 필욘 없다.</em></p></blockquote><blockquote><p>TDD 좋기는 한데 실무 개발자들이 적용하기엔 분명한 한계가 있다. <em>그러나 테스트 커버리지는 높여나가자.</em></p></blockquote><blockquote><p>나는 모든 개발자가 모든 실무 개발을 TDD base로 해야 한다고 생각한다. <em>지금 당장은 못하더라도 이상향을 거기로 잡자.</em></p></blockquote><p>모두 다 개발자로 취업한 후 들었던 말들이다. </p><h3 id="TDD가-멀게-느껴지는-이유"><a href="#TDD가-멀게-느껴지는-이유" class="headerlink" title="TDD가 멀게 느껴지는 이유"></a>TDD가 멀게 느껴지는 이유</h3><p>학생때 <a href="https://www.slideshare.net/OKJSP/okky-tdd" target="_blank" rel="noopener">TDD를 너무나 좋아하는 나머지 삶의 방식 또한 TDD 기반으로 리팩토링 하고 계신 사부님</a> 께 Java를 배웠다. 그땐 실무 개발자들이 TDD를 하지 않는 것이 일종의 나태함의 징표는 아닐까 생각하기도 했었다. 정말 오만한 생각이었지만…. </p><p>월급 받고 코드를 짠 지 1년 갓 넘긴 지금 시점, 실무 개발자들이 TDD를 하지 못하는 이유가 내 눈에도 명확히 보이기 시작했다. </p><ul><li><p>비즈니스 로직은 <strong>하루에도 몇 번씩 바뀐다.</strong> </p><ul><li>학생 개발자 시절엔, 내가 (프로젝트를) 설계하고 내가 구현했으니 알 수 없는 어려움이었다.</li><li>대다수의 조직과 기업에서 개발자는 비즈니스 로직에 대한 통제권을 갖지 못한다.</li></ul></li><li><p>애플리케이션 자체가 <strong>방대하다.</strong></p><ul><li>통합 테스트가 사실상 불가능하다. </li><li>테스트 환경을 완전히 독립시킬 수가 없다(데이터의 부재, 데이터소스의 병립 불가)</li></ul></li><li><p><strong>시간이 없다.</strong></p></li><li>팀 전체의 합의를 이루기가 어렵다.</li></ul><h3 id="TDD-흉내를-내보기-위한-몸부림"><a href="#TDD-흉내를-내보기-위한-몸부림" class="headerlink" title="TDD 흉내를 내보기 위한 몸부림"></a>TDD 흉내를 내보기 위한 몸부림</h3><p>업무 중 완전한 형태의 TDD까지 실천하진 못하더라도, 흉내라도 내보고 싶던 차에 그런 시도를 해볼 만한 개발과제가 잘 주어지지 않아 답답함을 느끼고 있었다. </p><p><strong>그러다 기회가 왔다.</strong></p><h4 id="이-개발과제가-TDD-흉내내기에-적합했던-이유"><a href="#이-개발과제가-TDD-흉내내기에-적합했던-이유" class="headerlink" title="이 개발과제가 TDD 흉내내기에 적합했던 이유"></a>이 개발과제가 TDD 흉내내기에 적합했던 이유</h4><p>상세한 내용은 업무상 기밀이라 밝히지 못하지만 과제는 아래와 같은 조건을 충족하고 있었다.</p><ul><li>값 기반의 테스트가 가능하다. <ul><li>로직의 멱등성이 보장된다. </li><li>임의의 값으로 테스트가 용이하다.</li></ul></li><li>외부 종속성을 끊어낸 채로 모델 클래스만의 테스트와 개발이 가능하다. </li><li>레거시 코드의 복잡도가 높지 않다.</li></ul><p><em>그래서 시작했는데….</em></p><h3 id="과제의-요구사항"><a href="#과제의-요구사항" class="headerlink" title="과제의 요구사항"></a>과제의 요구사항</h3><p>과제의 요구사항은 다음과 같다. </p><ul><li>DB에 담겨 있는 특정 문자열을 변환하라.</li><li>로그인한 사용자의 권한에 따라, 때로는 변환 전 문자열을 노출하고, 때로는 변환된 문자열을 노출해야 한다. </li></ul><h3 id="작업-과정"><a href="#작업-과정" class="headerlink" title="작업 과정"></a>작업 과정</h3><p>요구사항과 레거시 코드와 그 로직, 데이터베이스에 담겨있는 데이터의 개략적인 모습(?) 을 확인한 후 <strong>테스트 코드 작성(요구사항 정의)</strong> 을 시작하였다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringModificationTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    String originalString;</span><br><span class="line">    BusinessModel model;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.originalString = <span class="comment">//DB에 원래 담겨있어야 할 문자열</span></span><br><span class="line">        <span class="keyword">this</span>.model = <span class="keyword">new</span> BusinessModel(<span class="keyword">this</span>.originalString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//비즈니스 로직 노출의 우려가 있어 메소드 이름이 모호한 것은 이해해주시길 바란다.</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_string_modified_correctly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String expected = <span class="string">"expected_string"</span>;</span><br><span class="line">        <span class="keyword">this</span>.model.processString();</span><br><span class="line"></span><br><span class="line">        assertThat(<span class="keyword">this</span>.model.getString, is(expected));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="문자열-변환-로직의-작성"><a href="#문자열-변환-로직의-작성" class="headerlink" title="문자열 변환 로직의 작성"></a>문자열 변환 로직의 작성</h4><p>문자열 변환 로직을 모델 클래스에 작성한다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessModel</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String newString = <span class="keyword">this</span>.modelString.....</span><br><span class="line">        <span class="comment">//문자열 처리 로직 작성</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.modelString = newString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="다시-테스트"><a href="#다시-테스트" class="headerlink" title="다시 테스트"></a>다시 테스트</h4><p>테스트를 다시 돌린다.</p><p><img src="https://s3.amazonaws.com/mokacoding/2018-09-18-red-green-refactor.jpg" alt="TDD phase"></p><h4 id="성공"><a href="#성공" class="headerlink" title="성공?"></a>성공?</h4><p>로직 작성 -&gt; 테스트 간에는 일단 <strong>테스트의 성공</strong> 에 집중한다. 테스트의 성공을 위해 수단과 방법을 가리지 않는다. <em>리팩토링/클린코드는 지금 단계에선 관심이 없다.</em></p><p>극단적으로 보면 아래와 같은 구현을 하는 것도 의미가 없진 않다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//테스트에서 기대했던 값을 그대로 넣어버리는 것이다. </span></span><br><span class="line">        <span class="keyword">this</span>.modelString = <span class="string">"expected_string"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이게 무슨 의미냐 하겠지만 나는 이 과정에서 몇 가지 의미를 본다. </p><ul><li>test suite가 초록색으로 빛나는 것을 보는 거 자체가 성취감을 준다. <ul><li>개발은 어차피 사람이 하는 것이기때문에 이런 성취감을 얻는 것 자체가 의미가 있다.</li><li><a href="https://www.youtube.com/watch?v=OFN9mQVjPdU" target="_blank" rel="noopener">작은 성공에 대한 영상</a></li></ul></li><li><strong>테스트 케이스에 대한 검증이 이뤄진다.</strong> <ul><li>모델 클래스의 수정으로 테스트가 성공할 수 있다는 보증을 받을 수 있다. </li><li>테스트 대상을 확실히하고 있음을 알 수 있다. </li></ul></li></ul><h4 id="두-번째-성공을-향해"><a href="#두-번째-성공을-향해" class="headerlink" title="두 번째 성공을 향해"></a>두 번째 성공을 향해</h4><p>초록색으로 빛나는 test suite를 확인했다면 <strong>이제는 일반화에 집중한다.</strong> </p><p>아까 첫 green light를 보기 위해 수단과 방법을 가리지 않았다면, 이제는 <strong>최대한 많은 edge case에 대해 테스트가 성공하도록 로직을 정교화한다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//당연히 다른 값에 대해서는 테스트가 실패할 것이다. </span></span><br><span class="line">        <span class="keyword">this</span>.modelString = <span class="string">"expected_string"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>지금 단계에서부터는 <strong>최대한 많은 값에 대한 테스트</strong>를 확보하는 것이 중요하다.</p><p>테스트 코드를 수정한다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_string_modified_correctly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String expected = <span class="string">"expected_string"</span>;</span><br><span class="line">        <span class="keyword">this</span>.model.processString();</span><br><span class="line"></span><br><span class="line">        assertThat(<span class="keyword">this</span>.model.getString(), is(expected));</span><br><span class="line"></span><br><span class="line">        String originalString2 = <span class="string">"original_string_2"</span>;</span><br><span class="line">        String expected2 = <span class="string">"expected_string_2"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.model.setString(originalString2);</span><br><span class="line">        <span class="keyword">this</span>.model.processString();</span><br><span class="line"></span><br><span class="line">        assertThat(<span class="keyword">this</span>.model.getString(), is(expected2));</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>사람이 하면 삽질이다. 값 기반 테스트를 도와주는 프레임워크의 적용을 검토해 본다.</p><p>아래 프레임워크가 유명해 보이지만 이번 작업에선 워낙 레거시 데이터베이스 내용들이 다사다난해서 적용해보지 못했다. </p><ul><li><a href="https://jqwik.net/" target="_blank" rel="noopener">jQwik</a></li></ul><h4 id="두-번째-성공-이후"><a href="#두-번째-성공-이후" class="headerlink" title="두 번째 성공 이후"></a>두 번째 성공 이후</h4><p>API의 멱등성이 충분히 확보되었다고 느낀다면 <strong>리팩토링을 통한 클린 코드의 구현에 집중한다.</strong> </p><p>우리는 이미 스펙에 대해 충분한 테스트 케이스를 갖고 있기 때문에 리팩토링의 사이드이펙트를 두려워할 이유가 없다. <strong>테스트 케이스에 빨간 불이 들어온다면 다시 되돌아가거나 문제를 찾아 수정하면 그만이다</strong>. </p><p>비즈니스 로직 노출의 우려로…. 리팩토링 과정을 상세히 담지 못하는 점은 아쉽다. </p><h3 id="작업-회고"><a href="#작업-회고" class="headerlink" title="작업 회고"></a>작업 회고</h3><p>오랜만에 초록불이 짠 뜨는 경험을 하며 사무실에서 즐겁게 코딩을 했다. 굳이 유럽 여행중인 지금 기억을 되살려서 블로그 글을 쓰고싶을 정도로… </p><p>그러나 결국 다음과 같은 문제는 예방하지 못했다. </p><ul><li>이미 데이터베이스에 입력되어 있는 값들의 edge case에 대해 충분히 검증하지 못했다. <ul><li>기대하던 포맷에 어긋나는 데이터가 DB에 입력되어 있었고, 이에 따라 <code>ArrayIndexOutOfBoundsException</code> 이 발생함. </li></ul></li></ul><p>어차피 애플리케이션 단에서 잡아낼 수 없는 문제였으므로 TDD 그 자체가 문제는 아니었다고 본다. </p><p>그리고 소소한 문제로는…</p><ul><li>작업 시간이 오래 걸리는 것은 어쩔 수 없다. <ul><li>그러나 평소에 그만큼 막코딩을 하고 있었다는 반증일 수도 있다.</li><li>평소보다 많이 오래걸리지는 않았다. 평소 작업 시간의 120% 정도가 소요되었다. </li></ul></li><li>개발 진척과정을 다른 팀원들과 활발히 공유하지 못했다. </li></ul><p>이와 같은 아쉬움을 경험했다. </p><h3 id="앞으로는"><a href="#앞으로는" class="headerlink" title="앞으로는?"></a>앞으로는?</h3><p>앞으로도 지금과 같은 시나리오에 적합한 개발과제가 주어진다면, 적극적으로 TDD를 흉내내며 개발해볼 생각이다. </p><p>완전한 형태의 TDD를 행했는지는 잘 모르겠지만 흉내라도 내야 언젠가는 그 정점에 갈 수 있으리라 믿는다. </p><p>또한 조금 더 활발한 커뮤니케이션으로 팀에 이런 개발문화를 전파시켜보려고 노력해보고 싶다. 물론 내 노력만으로는 이뤄지지 않을 일이란 것을 안다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TDD를-하는-척-하며-즐겁게-리팩토링해보자&quot;&gt;&lt;a href=&quot;#TDD를-하는-척-하며-즐겁게-리팩토링해보자&quot; class=&quot;headerlink&quot; title=&quot;TDD를 하는 척 하며 즐겁게 리팩토링해보자.&quot;&gt;&lt;/a&gt;TDD를 하는 척 하며 
      
    
    </summary>
    
      <category term="java" scheme="https://tech.wheejuni.com/categories/java/"/>
    
      <category term="tdd" scheme="https://tech.wheejuni.com/categories/java/tdd/"/>
    
      <category term="refactoring" scheme="https://tech.wheejuni.com/categories/java/tdd/refactoring/"/>
    
    
  </entry>
  
  <entry>
    <title>지금까지 받아본 코드 리뷰를 정리해본다(1).</title>
    <link href="https://tech.wheejuni.com/2019/03/25/codereview-retrospect/"/>
    <id>https://tech.wheejuni.com/2019/03/25/codereview-retrospect/</id>
    <published>2019-03-24T23:40:00.000Z</published>
    <updated>2021-01-20T14:13:54.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="지금까지-받아본-코드리뷰를-정리해본다"><a href="#지금까지-받아본-코드리뷰를-정리해본다" class="headerlink" title="지금까지 받아본 코드리뷰를 정리해본다."></a>지금까지 받아본 코드리뷰를 정리해본다.</h2><p>흔히 주니어 개발자가 성장할 수 있는 가장 좋은 방법은 코드리뷰를 충실히 받는 것이라고 이야기한다. </p><p>성장 안하고 가만히 있어도 잘 먹고 잘 살 수 있는 직업을 갖게 되길 소망하지만(혹은 노동하지 않아도 잘 먹고 잘 살 수 있는 사회경제적 자본을 갖고 태어나기를 소망했지만) 당장 상황이 여의치 않으므로 일단 일을 더 잘 할 필요는 있다. </p><p>성장하지 않고 가만히 있어도 되는 직업을 찾을 때까지는 힘 닿는대로 실력을 키울 필요가 있겠다. </p><h3 id="우리-조직의-코드리뷰-방향성"><a href="#우리-조직의-코드리뷰-방향성" class="headerlink" title="우리 조직의 코드리뷰 방향성"></a>우리 조직의 코드리뷰 방향성</h3><p>내가 몸담고 있는 네이버 쇼핑데이터플랫폼은 솔직히 말하면 그간 코드리뷰 문화가 그렇게 활성화되어 있던 조직은 아니다. </p><p>업무에 비해 인력이 부족했고 특히 허리급 개발자가 부족한 것은 지금까지도 해결이 안 되고 있다. </p><p>(우리 조직의 문은 <a href="https://recruit.navercorp.com/naver/job/detail/developer?annoId=20001611&amp;classId=170&amp;jobId=3809&amp;entTypeCd=&amp;searchTxt=%EC%87%BC%ED%95%91&amp;searchSysComCd=" target="_blank" rel="noopener">늘 열려있다.</a>)</p><p>최근 신입사원이 꽤 많이 충원되고 외부에서도 시니어급 개발자 분들이 몇몇 합류하셔서 상황이 조금씩 나아지고 있다. 특히 리더급 개발자들이 코드리뷰에 대한 강한 의지를 갖고있는 것은 꽤 고무적인 일이다(가끔 부담스러울 때도 있다).</p><p>개인적으로 감사함을 느끼는 선배님은 <a href="http://blog.leekyoungil.com" target="_blank" rel="noopener">이경일님</a> 으로 적극적으로 코드리뷰를 해주시는 것은 물론이고, 가끔은 리뷰를 해주시다 답답함을(!) 느끼시는지 직접 내 자리 옆으로 오셔서 즉석에서 페어 프로그래밍을 진행해주시기도 한다. 항상 꼰머로 비치지 않을까 조심하시지만 애초에 나와 년차가 10년 가까이 차이나는 시니어 개발자분이 그렇게 시간을 들여 코드리뷰를 해주시는 것 자체가 감사한 일이고, 또한 꼰머로 비칠까 걱정하며 조심해주시는 것은 감동적인 일이다. </p><p>이경일님의 세심한 코드리뷰를 받고싶은 신입 개발자 준비생 분들은 다음 주제로 2019 네이버 캠퍼스 핵데이에 지원하시면 좋겠다.</p><p>Github issue: <a href="https://github.com/NAVER-CAMPUS-HACKDAY/common/issues/6" target="_blank" rel="noopener">쇼핑 실시간 상품 경매 플랫폼</a></p><p>핵데이 원서접수 페이지 <a href="https://recruit.navercorp.com/naver/job/detail/developer?annoId=20002666&amp;classId=&amp;jobId=&amp;entTypeCd=004&amp;searchTxt=&amp;searchSysComCd=" target="_blank" rel="noopener">바로가기</a></p><h3 id="내가-받은-코드리뷰-유형별-요약"><a href="#내가-받은-코드리뷰-유형별-요약" class="headerlink" title="내가 받은 코드리뷰 유형별 요약"></a>내가 받은 코드리뷰 유형별 요약</h3><p>코드리뷰를 받다보니 주로 <strong>걸리는 쪽에서 계속 걸리는</strong> 모습이 관측되었다. </p><p>사람인 이상 어쩔 수 없는 부분이기도 하고, 앞으로 고쳐나가야 할 부분이기도 하다. </p><p>가장 좋은 것은 안 고쳐도 잘 먹고살 수 있는 직업을 갖는 것이다. 하지만 당장 상황이 여의치 않으므로 일단은 고쳐나가면서 실력을 키울 필요가 있다. </p><p>다음은 코드리뷰를 개략적으로, 유형별로 분류해 본 것이다. </p><hr><h4 id="immutable해야-할-객체를-명확히-구분하자"><a href="#immutable해야-할-객체를-명확히-구분하자" class="headerlink" title="immutable해야 할 객체를 명확히 구분하자"></a>immutable해야 할 객체를 명확히 구분하자</h4><p>Java를 사용할 때 아무 생각없이 객체를 만들고 주고받지만, 내부의 element가 바뀌면 안 될 상황에서 immutability를 고려하지 않는 경우가 많다.</p><p>특히 java.util.Collection의 하위 클래스들을 사용하는 경우 이 점을 충분히 고려하여 불변해야 할 객체를 확정짓는 것이 좋다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//아래의 shitUrls는 dumbSites 객체로부터 URL을 가져온다.</span></span><br><span class="line"><span class="comment">//언뜻 생각해보면 의도한 URL만 가져왔으므로 올바른 객체라고 생각하겠지만, 중간에 다른 String이 들어와도 아무도 모르게 된다. </span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; shitUrls = dumbSites.getUrls();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Collections.unmodifiableList(Collections c); 을 사용하여 컬렉션 객체의 불변성을 확보한다. </span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; shitUrls = Collections.unmodifiableList(dumbSites.getUrls());</span><br></pre></td></tr></table></figure><p>또한 parameter로 받을 객체, 지역 변수들에 대해서도, 최초 할당 이후 재할당이 필요없는 변수라면 final 예약어를 사용하여 최소한 객체 자체가 뒤바뀌는 일은 없도록 확실히 해 주자. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHelloToYou</span><span class="params">(String yourName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//아래와 같이 지역 변수를 자유롭게 풀어주면 불변성을 확보하기 어렵게 된다. </span></span><br><span class="line">    String concatenatedName = yourName + <span class="string">"hi"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//이와 같이 final을 붙여준다.</span></span><br><span class="line">    <span class="keyword">final</span> String concatenatedName = yourName + <span class="string">"hi"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>당연한 얘기지만 <strong>composed type</strong>인 경우 setter를 통한 값의 변경은 피할 수 없을 것이다. </p><p>그러나 그것은 객체 설계단의 문제이므로 여기서는 패스한다. </p><hr><h4 id="항상-null을-의식하라"><a href="#항상-null을-의식하라" class="headerlink" title="항상 null을 의식하라"></a>항상 null을 의식하라</h4><p>사실 이건 내가 Kotlin을 선호하는 이유이기도 하다. </p><p>Kotlin이 null을 다루는 방식, 그리고 null-safety를 보장해주는 방식은 정말 우아하며 gorgeous 하고 phenomenal하다. </p><p>그러나 당장 Kotlin을 사용하지 못하므로 Java에서 null을 안전하게 다룰 방법을 고민하고 연습하는 수밖에 없다. </p><hr><p><em>Java에서 null의 그지같음(개인적 견해)</em></p><p>null이 그지같은 이유는 NPE를 발생시키기 때문이다. </p><p>사실 NPE만 아니라면, 혹은 NPE의 수퍼클래스가 RuntimeException이 아니라면 Java에서 null을 다루는 것이 그렇게 스트레스받는 일이 아닐 수도 있다. </p><p>어차피 대부분의 상황에서 NPE는 에러로써 애플리케이션이 뻗어버릴 수밖에 없는데 차라리 try - catch로 잡아내는 것이 낫지 않겠는가? 개인적인 생각이다.</p><hr><p>사실 <strong>외부 API를 사용할 때</strong> 랄지 <strong>타인이 짜 놓은 코드에서 객체를 받아올 때</strong> null 발생 가능성에 대한 의심을 별로 안한 채로 코드를 작성하게 되는 경우가 많다. </p><p>그리고 종종 이는 대형 참사로 이어진다. </p><p>코드리뷰에서는 사소한 null의 가능성도 주의깊게 살피라는 지적을 수 차례 받은 바 있다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//iBATIS의 row handler 구현체를 작성한 코드다.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRow</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Shit shit = (Shit)o;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//NPE가 발생할 포텐셜을 갖고 있는 코드다.</span></span><br><span class="line">    shit.getToiletName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>상기한 사례의 경우, iBATIS는 Result Row가 존재하지 않으면 아예 Row Handler 객체를 호출하지 않으므로 null의 가능성은 없다(zero).</p><p>그러나 외부 API를 호출할 때, 결과물에 대한 확신이 없는 경우에는 늘 null에 대한 대비를 하는 것이 좋겠다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SewageConnector connector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processShit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shit shit = connector.getFirstShit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//shit이 null 인 경우 진입하여 객체를 필요로 하는 로직을 건너뛰고 메소드를 끝내버린다.</span></span><br><span class="line">    <span class="keyword">if</span>(shit == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"no shit available! clean!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>어찌보면 참 사소한 것인데 실무에선 까먹기 십상이다.</p><hr><h4 id="try-with-resources-를-적극-활용하라"><a href="#try-with-resources-를-적극-활용하라" class="headerlink" title="try-with-resources 를 적극 활용하라"></a>try-with-resources 를 적극 활용하라</h4><p>Closeable한 자원을 사용하는 경우 제때 닫아주지 않으면 성능에 악영향을 미친다. </p><p>그동안 우리는 try - catch - finally 패턴을 많이 사용해왔다. 그러나 Java 1.7 이상만 되어도 훨씬 간결한 syntax의 try - with - resources를 활용할 수 있으므로 이를 적극 활용하자. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">"~/Documents/resume"</span>)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String line = in.readLine();</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    e.printStackTrace()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//예외 발생 여부에 상관없이 리더를 닫아야 하기 때문에 finally 절이 발생한다.</span></span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>finally를 없애고 가독성 높은 코드를 만들기 위해 아래와 같이 리팩토링한다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(BufferedReader in = <span class="keyword">new</span> BufferedReader(...)) &#123;</span><br><span class="line">    <span class="comment">//여기에 로직이 담긴다.</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="굳이-Spring-Bean일-필요가-있는지-고려하라"><a href="#굳이-Spring-Bean일-필요가-있는지-고려하라" class="headerlink" title="굳이 Spring Bean일 필요가 있는지 고려하라"></a>굳이 Spring Bean일 필요가 있는지 고려하라</h4><p>Spring Bean은 verbose한 싱글턴 패턴 코드 없이 싱글턴을 보장할 수 있는 좋은 방법이고, </p><p><strong>특히 AOP, IoC, transaction propagation 등</strong> 을 쉽게 구현할 수 있게 해 주는 좋은 도구이다. </p><p>그러나 아래의 고려사항을 충분히 생각해볼 필요가 있다.</p><ul><li>굳이 Singleton 상태일 이유가 있을까?<ul><li>static method 사용하면 안되는가? </li><li>Singleton 상태에서, 부가 기능이 추가될 이유가 있는가? </li></ul></li><li>모든 Spring Bean에서 이 객체를 주입받을 필요가 있는가?<ul><li>scope를 고려하라<ul><li>만약 특정 환경(특히, Spring Batch에서)에서만 사용할 bean이 전체 scope로 구현될 경우, 불필요한 객체를 생산하는 비용만 초래될 뿐이다.</li><li>Bean의 갯수, 혹은 initializing logic이 Spring의 Application Context의 초기 기동 시간에 직접적인 영향을 끼친다는 점을 고려하라.</li></ul></li><li>실행 환경에 따라 사용되는 Bean이 다르진 않는가?<ul><li>XML config의 경우 설정 파일을 분리하여 환경에 따른 bean instantiation이 가능하도록 설계하라. </li><li>Java config, 특히 Spring Boot의 경우, @ActiveProfiles, @Profile을 적극적으로 활용하라. </li></ul></li></ul></li></ul><p><strong>DEV 프로필에서만 사용될 컴포넌트의 예시</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@ActiveProfiles</span>(<span class="string">"dev"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetardService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>코드리뷰 받은 내용을 옮겨본다.</strong></p><p><em>아래의 코드는 실무에서 사용한 코드가 아니다.</em></p><p><strong>코드 리뷰 커멘트</strong> </p><blockquote><p>(…) spring component 보다는 static class 로 만드는게 어떨까 싶네요~ (spring bean 으로 만들 필요가 없는 class 인거 같다는 소리 ㅎㅎㅎ)</p></blockquote><p><em>리뷰 이전 코오드</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Component로 annotate 함으로써 모든 상황에서 객체화(instantiate)해야만 하는 클래스가 되어버렸다.</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoopService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//타 Spring Bean을 주입받거나, AOP적인 요소가 없으므로 굳이 Spring Bean으로 선언할 필요가 없는 클래스였다. </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pumpPoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"poop!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>개선</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoopService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//기본 생성자를 private으로 막아버림으로써, 객체화를 방지한다. </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PoopService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//static method이므로 객체를 만들지 않고 사용이 가능하다.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pumpPoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"poop!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="랜덤-코드-생성에-UUID를-사용하라"><a href="#랜덤-코드-생성에-UUID를-사용하라" class="headerlink" title="랜덤 코드 생성에 UUID를 사용하라"></a>랜덤 코드 생성에 UUID를 사용하라</h4><p>처음 구현한 코드는 아래와 같았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomGenerator</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RandomCache cache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RandomStringGenerator stringGenerator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateRandomCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String newString = stringGenerator.generate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//재귀 호출한다. base case는 cache.hasString(newString) == false</span></span><br><span class="line">        <span class="keyword">return</span> !cache.hasString(newString) ? newString : generateRandomCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>리뷰어께서 지적하신 문제점은 다음과 같다. </p><ul><li>재귀호출이 몇 번 일어날지 보장할 수 없다. <ul><li>만약 cache에 1억건의 엔트리가 이미 들어있는 상황이라면?</li><li>만약 RandomStringGenerator의 로직에 문제가 있어, 랜덤값이 보장이 안 되고 있는 상황이라면? </li></ul></li><li>문자열을 요청할때마다 내부적으로 일일이 비교연산이 일어날 텐데, 그 비용이 너무 커 보인다. </li><li><strong>UUID</strong>를 활용하여 리팩토링한다.</li></ul><p><em>리팩토링 완료한 코드</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomGenerator</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateRandomCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder accessCode = <span class="keyword">new</span> StringBuilder(UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//후처리 로직을 삽입하고...</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> accessCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="1부-끝"><a href="#1부-끝" class="headerlink" title="1부 끝"></a>1부 끝</h3><p>사실 앞으로도 정리해나갈 내용은 많을 것이다. </p><p>하나의 포스팅으로 정리하기엔 내용이 방대한 것 같으니, 오늘은 여기서 글을 마쳐야겠다. 내가 특별히 지적 능력이 지진하거나 주니어 개발자로서의 소양이 부족한 것이 아니라면, 내가 받은 코드리뷰는 다른 주니어들도 마찬가지로 많이 받고 있거나, 혹은 받아야할 내용을 포함하고 있을 거라 본다. </p><p>가장 좋은 것은 성장하지 않아도 먹고살 수 있는 직업을 갖는 것이겠지만, 일단은 그럴 수 없으므로 매일 매일 조금씩이라도 실력이 늘어야 할 것이다. </p><h4 id="백기선님의-동영상-더-좋은-개발자가-되는-법"><a href="#백기선님의-동영상-더-좋은-개발자가-되는-법" class="headerlink" title="백기선님의 동영상 - 더 좋은 개발자가 되는 법"></a>백기선님의 동영상 - 더 좋은 개발자가 되는 법</h4><p><a href="https://www.youtube.com/watch?v=yEcCQZlFmaM" target="_blank" rel="noopener"><img src="https://img.youtube.com/vi/yEcCQZlFmaM/0.jpg" alt="&quot;나는 정말 이걸 좋아 하나?&quot;"></a></p><p>좋아하면 잘하게 된다. 좋아하기는 어려운 일인 것 같긴 하다. </p><p>개발을 좋아해서 이 업을 시작했지만 취미/관심분야로써 즐긴 것과 직업인으로서 이 업을 즐기는 것은 전혀 다른 차원의 문제라는 것을 요즘 새삼 깨닫고 있다. </p><p>나는 어디로 가야하나? 일단 열심히 달리는 수밖에 없을 것이다. </p><h4 id="“지금까지-받아본-코드-리뷰를-정리해본다-”-시리즈는-앞으로-틈나는-대로-계속-정리할-생각이다"><a href="#“지금까지-받아본-코드-리뷰를-정리해본다-”-시리즈는-앞으로-틈나는-대로-계속-정리할-생각이다" class="headerlink" title="“지금까지 받아본 코드 리뷰를 정리해본다.” 시리즈는 앞으로 틈나는 대로 계속 정리할 생각이다."></a>“지금까지 받아본 코드 리뷰를 정리해본다.” 시리즈는 앞으로 틈나는 대로 계속 정리할 생각이다.</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;지금까지-받아본-코드리뷰를-정리해본다&quot;&gt;&lt;a href=&quot;#지금까지-받아본-코드리뷰를-정리해본다&quot; class=&quot;headerlink&quot; title=&quot;지금까지 받아본 코드리뷰를 정리해본다.&quot;&gt;&lt;/a&gt;지금까지 받아본 코드리뷰를 정리해본다.&lt;/h2
      
    
    </summary>
    
      <category term="java" scheme="https://tech.wheejuni.com/categories/java/"/>
    
      <category term="codereview" scheme="https://tech.wheejuni.com/categories/java/codereview/"/>
    
    
  </entry>
  
  <entry>
    <title>2019 블로그 부활</title>
    <link href="https://tech.wheejuni.com/2019/01/25/2019-blog-revival/"/>
    <id>https://tech.wheejuni.com/2019/01/25/2019-blog-revival/</id>
    <published>2019-01-24T23:40:48.000Z</published>
    <updated>2021-01-20T14:13:54.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="블로그를-부활시킨다"><a href="#블로그를-부활시킨다" class="headerlink" title="블로그를 부활시킨다."></a>블로그를 부활시킨다.</h2><p>블로그 부활.</p><p>사실 그동안 블로깅을 쉬었던 것에는 이유가 몇 가지 있다:</p><ul><li>물리적인 시간의 부족. 대부분의 시간을 직장에서 enterprise github로 작업하다보니 개인 깃허브 관리의 여력이 없었다. </li><li>삽질하는 느낌. <em>이걸 정리해봐야 누가 보나….</em></li><li><strong>(결정적)</strong> hexo의 고장. 왜 안됐는지는 모르겠는데 그동안 잘 안됐다. </li></ul><p>오늘 우연한 계기로 방치된 블로그나 관리해볼까 하고 <code>git clone</code> 을 하고 <code>hexo generate</code> 을 돌렸는데 고장나서 안 돌아갔던 이전과는 달리 갑자기 잘 돌아갔다.</p><p>바뀐 건 아무것도 없는데 말이다. </p><p>잘 돌아간 기념으로 블로깅을 다시 시작해볼까 한다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;블로그를-부활시킨다&quot;&gt;&lt;a href=&quot;#블로그를-부활시킨다&quot; class=&quot;headerlink&quot; title=&quot;블로그를 부활시킨다.&quot;&gt;&lt;/a&gt;블로그를 부활시킨다.&lt;/h2&gt;&lt;p&gt;블로그 부활.&lt;/p&gt;
&lt;p&gt;사실 그동안 블로깅을 쉬었던 것에는 이
      
    
    </summary>
    
      <category term="daily" scheme="https://tech.wheejuni.com/categories/daily/"/>
    
      <category term="thoughts" scheme="https://tech.wheejuni.com/categories/daily/thoughts/"/>
    
    
  </entry>
  
  <entry>
    <title>네이버에서의 세 번째 일주일</title>
    <link href="https://tech.wheejuni.com/2018/07/22/naver-3rd/"/>
    <id>https://tech.wheejuni.com/2018/07/22/naver-3rd/</id>
    <published>2018-07-22T09:34:45.000Z</published>
    <updated>2021-01-20T14:13:54.926Z</updated>
    
    <content type="html"><![CDATA[<h3 id="네이버-3주차-회고-및-반성"><a href="#네이버-3주차-회고-및-반성" class="headerlink" title="네이버 3주차 회고 및 반성"></a>네이버 3주차 회고 및 반성</h3><p>다음주말이면 벌써 입사 한달차라니 시간 참 빠르다(…)</p><p>이제 통근도 익숙해졌고 특히 퇴근시간을 많이 단축했다. 같은 경로로 계속 다녔는데 어떻게 많이 다닐수록 소요시간이 짧아지는지 신기할 따름이다. 음….</p><h4 id="프로젝트-진행-상황"><a href="#프로젝트-진행-상황" class="headerlink" title="프로젝트 진행 상황"></a>프로젝트 진행 상황</h4><p><em>전반적으로 계획대로, 그렇지만 살짝 아쉬운 점이….</em></p><p>생각한 대로 프로젝트가 잘 진행되고 있다. 검색 최적화 / WAS에서의 검색 요청 이제 모두 잘 된다. 특히 형태소 분석기를 arirang으로 확정하고 적용해 잘 돌아가는 것까지 확인했다. </p><p>그러나 JS 수정시 즉각 빌드 파일에 반영되지 않는 문제는 아직도 해결하지 못했다. 3주차까지 해결하지 못하면 선배님들께 도움을 요청하기로 생각했던 문제이므로 4주차 월요일 오전까지 고민해보고 잘 안되면 여쭤봐야겠다. </p><p>발표자료를 제작하기 시작했다. 화려하게 꾸밀 필요는 없을 것 같고 그냥 내가 진행한 것을 잘 정리해서 보여드리기만 하면 될 것 같다. </p><p>추가과제 구현 방향을 정하긴 했는데 공유드리진 못했다. 아마 이 부분은 수요일쯤에 공유드리고 목요일 중간발표 시간에 함께 고민해보는 시간을 가지면 될 것 같다. </p><h4 id="더-잘해보고-싶은-점"><a href="#더-잘해보고-싶은-점" class="headerlink" title="더 잘해보고 싶은 점"></a>더 잘해보고 싶은 점</h4><ul><li>일단 중간발표 기간까지 자체 프론트 제작은 미루기로 했다. 중간발표때까지는 이미 만들어진 JSP를 수정하는 방향으로 진행을 하고, 이후 리액트 등 적용 방향을 고민해보기로. </li><li>화요일까지는 기능 시현이 가능할 정도의 구현을 마치고 계속 실험하는 시간을 가져야할 것 같다.</li><li>JS Deploy 제때 안 되는 문제 해결해야한다.</li></ul><h4 id="4주차-계획"><a href="#4주차-계획" class="headerlink" title="4주차 계획"></a>4주차 계획</h4><ul><li>목요일 오후에 중간발표가 있다. 그동안 진행한 부분을 그냥 보여드리면 될 것이라고 생각한다.<ul><li>무리없이 그동안 해둔것만 보여드려도 나쁘지 않을 것 같다. </li><li><strong>중간</strong> 발표니까 최종발표만큼의 완성도를 어차피 기대하지 않으시는 것 같다. </li><li>코드리뷰 같은 부분의 갈증을 좀 느끼고 있었는데 어차피 커밋은 계속 하고 있었고, 이번 기회로 피드백을 받을 수 있었으면 좋겠다. </li></ul></li><li>이번주말이면 입사 1개월차. 시간 참 빠르다.<ul><li>중간발표를 마치고 나서 진행할 추가과제에 대한 부분, 특히 프론트단에 대한 생각을 해볼 필요가 있겠다.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;네이버-3주차-회고-및-반성&quot;&gt;&lt;a href=&quot;#네이버-3주차-회고-및-반성&quot; class=&quot;headerlink&quot; title=&quot;네이버 3주차 회고 및 반성&quot;&gt;&lt;/a&gt;네이버 3주차 회고 및 반성&lt;/h3&gt;&lt;p&gt;다음주말이면 벌써 입사 한달차라니
      
    
    </summary>
    
      <category term="naver" scheme="https://tech.wheejuni.com/categories/naver/"/>
    
      <category term="intern" scheme="https://tech.wheejuni.com/categories/naver/intern/"/>
    
    
  </entry>
  
  <entry>
    <title>네이버에서의 두 번째 일주일</title>
    <link href="https://tech.wheejuni.com/2018/07/15/naver-2nd/"/>
    <id>https://tech.wheejuni.com/2018/07/15/naver-2nd/</id>
    <published>2018-07-15T09:06:24.000Z</published>
    <updated>2021-01-20T14:13:54.925Z</updated>
    
    <content type="html"><![CDATA[<h3 id="네이버-2주차-회고-및-반성"><a href="#네이버-2주차-회고-및-반성" class="headerlink" title="네이버 2주차 회고 및 반성"></a>네이버 2주차 회고 및 반성</h3><p>설렘과 긴장 속에 오리엔테이션을 받은 것이 벌써 2주전이 됐다. 어느새 2주차 마무리. </p><p>시간이 빨리 간다. 하루하루는 긴 것 같은데 돌아보면 또 시간이 빠른 것 같고 이거 참….. </p><h4 id="프로젝트-진행상황"><a href="#프로젝트-진행상황" class="headerlink" title="프로젝트 진행상황"></a>프로젝트 진행상황</h4><p><em>만족스럽다.</em></p><p>데이터 파이프라인을 구축했고 배치 작업과 서비스 프로젝트 두 곳 모두에서 테스트 코드를 통한 검증도 완료했다. 새로운 글이 들어오면 색인에 추가되고 글이 삭제되면 색인에서 빠진다. 일괄 전체색인 작업도 잘 수행된다. </p><p>이번주에는 드디어 프로젝트를 톰캣에 띄워 프론트단을 들여다봤다. 생소한 JSP 문법과 내가 세상에서 제일 싫어하는 jQuery가 굉장히 널리 사용되고 있다. 일단 기존 쏠라 엔진 기반으로 게시물을 페이징하던 것을 ES 기반으로 교체했고, 잘 작동하는 것을 확인했다. 다만 기존 코드가 JS를 통해 동적으로 URL을 만드는 방식이었는데 이번엔 그렇게 하지 않고 페이지가 처음 로딩되는 시점에 다음 페이징 주소로 연결되는 링크를 제공하게끔 고쳤다. </p><p>회사 코드라 코드를 여기에 옮길 수 없는 점이 아쉽긴 한데…. 여튼 아주 단순한 구현을 했다. </p><h4 id="더-잘해보고-싶은-점"><a href="#더-잘해보고-싶은-점" class="headerlink" title="더 잘해보고 싶은 점"></a>더 잘해보고 싶은 점</h4><ul><li>JSP와 JSTL에 대한 이해가 더 필요할듯. 사실 이건 공부할 때는 요즘 이거 쓰는 집이 있나? 해서 깊게 공부하지 않았던 부분인데 쓰는 집이 있네요.</li><li>ORACLE CLOB을 iBATIS는 어떻게 자동으로 핸들링하고 있는지 살펴봐야겠다.<ul><li>원래 4000byte에서 짤리는 거라고 하셨다. </li></ul></li><li>프론트를 어떻게 예쁘게 잘 꾸밀지 생각을….</li><li>ES 형태소 분석 등 분석기가 잘 돌고있는지 뭔지 가늠이 안 된다. <ul><li>이거는 3주차동안 Postman으로 계속 찍어보면서 확인해야겠다. </li></ul></li></ul><h4 id="3주차-계획"><a href="#3주차-계획" class="headerlink" title="3주차 계획"></a>3주차 계획</h4><ul><li>기본 과제가 끝을 향해 가고 있다. 3주차에 마무리되리라 생각한다. </li><li>옵션 과제 (혹은 자율과제) 중에 어떤 부분에 집중해서 남은 4주정도를 알차게 보낼지 구상해야 한다. <ul><li>이 부분은 3주차 금요일까지 알려달라고 하셨으니 그 전에 충분한 구상을. </li></ul></li><li>검색 결과 최적화에 더욱 힘쓰자. </li><li>트레비를 습관적으로 먹지 말자. 400원 * 20일 하면 벌써 8천원임…… <ul><li>이번달 사원증 결제금액이 벌써 만오천원 가까이 된다. </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;네이버-2주차-회고-및-반성&quot;&gt;&lt;a href=&quot;#네이버-2주차-회고-및-반성&quot; class=&quot;headerlink&quot; title=&quot;네이버 2주차 회고 및 반성&quot;&gt;&lt;/a&gt;네이버 2주차 회고 및 반성&lt;/h3&gt;&lt;p&gt;설렘과 긴장 속에 오리엔테이션을 
      
    
    </summary>
    
      <category term="naver" scheme="https://tech.wheejuni.com/categories/naver/"/>
    
      <category term="intern" scheme="https://tech.wheejuni.com/categories/naver/intern/"/>
    
    
  </entry>
  
  <entry>
    <title>ISO 8601 대 삽질기</title>
    <link href="https://tech.wheejuni.com/2018/07/12/iso8601-shit/"/>
    <id>https://tech.wheejuni.com/2018/07/12/iso8601-shit/</id>
    <published>2018-07-12T07:42:58.000Z</published>
    <updated>2021-01-20T14:13:54.917Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ISO-8601-대-삽질기"><a href="#ISO-8601-대-삽질기" class="headerlink" title="ISO 8601 대 삽질기"></a>ISO 8601 대 삽질기</h3><p>최근 게시물을 관리하는 간단한 코드를 구현하며 시간 정보를 관리할 일이 있었다. </p><p>데이터 원본 상의 column type은 DATE(ORACLE)이었지만 iBATIS를 사용하다보니 매핑이 여의치 않아 그냥 String type으로 데이터를 갖고 오다보니 재밌고 빡치는 해프닝을 겪어, 관련한 사항을 잊지 않기 위해 여기에 이렇게 기록해본다. </p><h4 id="문제의-발단"><a href="#문제의-발단" class="headerlink" title="문제의 발단"></a>문제의 발단</h4><p>해당 엔티티는 아래와 같은 코드를 통해 객체가 생성된 현재시점의 시간정보를 생성하고 있다. <em>(실제 작성중인 코드와는 상이함을 미리 알려드린다.)</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">currentTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DateTimeFormatter.ofPattern(<span class="string">"yyyy-mm-dd"</span>).format(LocalDateTime.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그러자 아래와 같은 우스꽝스러운 시간이 표시되기 시작했다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-48-12</span><br><span class="line">2018-51-12</span><br></pre></td></tr></table></figure><h4 id="왜-그럴까"><a href="#왜-그럴까" class="headerlink" title="왜 그럴까?"></a>왜 그럴까?</h4><p>ISO 8601 표기법상의 시간 / 일자 코드를 제대로 숙지하지 못해서 벌어진 일이었다.</p><p><strong>소문자 m과 대문자 M의 차이를 바로 알고 사용해야겠다.</strong></p><p>m(lower case) : minute of hour<br>M(upper case) : month of year</p><p><em>헷갈리지 말자.</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ISO-8601-대-삽질기&quot;&gt;&lt;a href=&quot;#ISO-8601-대-삽질기&quot; class=&quot;headerlink&quot; title=&quot;ISO 8601 대 삽질기&quot;&gt;&lt;/a&gt;ISO 8601 대 삽질기&lt;/h3&gt;&lt;p&gt;최근 게시물을 관리하는 간단한 코드를 구
      
    
    </summary>
    
      <category term="java" scheme="https://tech.wheejuni.com/categories/java/"/>
    
      <category term="datetimeformatter" scheme="https://tech.wheejuni.com/categories/java/datetimeformatter/"/>
    
      <category term="localdatetime" scheme="https://tech.wheejuni.com/categories/java/datetimeformatter/localdatetime/"/>
    
    
  </entry>
  
  <entry>
    <title>네이버에서의 첫 한주</title>
    <link href="https://tech.wheejuni.com/2018/07/07/naver-1stweek/"/>
    <id>https://tech.wheejuni.com/2018/07/07/naver-1stweek/</id>
    <published>2018-07-06T23:24:47.000Z</published>
    <updated>2021-01-20T14:13:54.925Z</updated>
    
    <content type="html"><![CDATA[<h3 id="네이버에서의-첫-일주일"><a href="#네이버에서의-첫-일주일" class="headerlink" title="네이버에서의 첫 일주일"></a>네이버에서의 첫 일주일</h3><p><strong>네이버에서 채용전제형 인턴으로 일하게 되었다.</strong> 시작은 Campus Hackday 참가였다. </p><p><a href="https://tech.wheejuni.com/2018/05/19/naver-hackday/">핵데이 후기 보러가기</a></p><p>이후 우수참가자 선정 안내와 뒤이어(거의 한달쯤 후에….) 진행된 기술면접을 거쳐 쇼핑데이터플랫폼 데이터정제개발파트의 막내로 입사하게 되었다. </p><p><strong>전반적인 입사 과정</strong></p><p>자세한 입사과정 및 개발자 취업 준비과정은 인턴십을 모두 마친 후, 타사 지원 / 면접 참여 경험과 같이 쭉 회고해보는 기회를 가지려고 한다. 여기서는 네이버에 한해 입사 과정을 간단히 서술해보고자 한다. </p><p><em>그리고 아직 채용전제형 인턴임에 유의해 주셨으면 한다.</em> </p><ul><li>Campus Hackday 지원, 서류심사</li><li>Campus Hackday 참가(춘천 네이버 커넥트원, 1박 2일)</li><li>우수참가자(기술면접 대상자) 개별통보</li><li>기술면접</li><li>최종합격</li></ul><p>상기한 다섯개 과정을 다 통과하면 네이버의 채용전제형 인턴으로 입사할 수 있게 된다. 인턴십은 시기별로 기간의 차이가 좀 있는 것 같기는 한데 이번에는 8주가 진행된다. </p><p>네이버의 신입개발자 공개채용이 <strong>사실상 중단</strong>된 상황에서 네이버에 신입 개발자로 입사할 수 있는 방법은 Campus Hackday 참가, 혹은 팀별 상시채용 지원 이외에는 없는 것 같다. 팀별 상시채용 지원은 상당수 경력직 채용이고, 신입으로 입사하려면 해당 공고가 요구하는 경력에 상응하는 역량을 보유했음을 증명해야 할 것이다. </p><p>네이버 신입개발자가 되고 싶다면 Campus Hackday에 가자. 매해 여름 / 겨울에 진행되는 것 같다. </p><p><a href="https://tech.wheejuni.com/2018/05/19/naver-hackday/">핵데이 후기 보러가기</a></p><p>기술면접은 개인별로 내용이 워낙 차이가 커서 여기에 자세히 서술하는 것은 무의미해보인다. 한가지 확실한 것은 자기가 진행한 프로젝트에 대한 이해가 있고, 또 입사하고 나면 자신이 다룰 기술에 대한 기초적인 이해가 있어야 할 것이다. 예를 들어 백엔드 개발자로 입사를 지망한다면 Spring Framework의 아주 로우레벯스러운 부분까진 아니더라도 IoC / DI, Transaction 관리 등이 어떻게 이뤄지는지 정도는 답변할 수 있어야 한다. </p><p>자료구조, 알고리즘 등 기타 전산학 기초 지식도 없으면 안된다. </p><p><strong>이번주에 한 일</strong></p><p><em>정신이 없었다.</em> 화요일까지는. 나도 정신이 없었지만 팀의 선배님들도 매우 바빠 보였다. </p><p>우리 팀이 진행하는 프로젝트의 git을 클론해 와 DB 연동구조나 전체적인 아키텍쳐가 어떻게 되는지를 살폈다. 독특한 내용은 없는 것 같고 다만 오라클 문법에 좀 익숙해질 필요가 있다고 생각된다. </p><p>과제를 진행하기 위해 개발 서버를 받았고 서버에 필요한 것들을 설치한 후 필요한 데이터를 적재하는 작업까지 진행했다. 전체적인 과제의 분량은 진행하기에 딱 적당한 수준이고 야근 없이도 7주간(마지막 한 주는 여러모로 프로젝트 진행이 안 될거 같아 일부러 한 주 뺐다) 프로젝트 진행으로 충분히 구현이 가능할 것 같다. </p><p>오히려 약간 좀 빨리 끝날 것 같기도…..</p><p><strong>느낌 및 소감</strong> </p><h2 id="옆-팀-인턴이-집에-안-간다"><a href="#옆-팀-인턴이-집에-안-간다" class="headerlink" title="옆 팀 인턴이 집에 안 간다."></a>옆 팀 인턴이 집에 안 간다.</h2><p>OT날에 분명히 19시 퇴근을 원칙으로 해주셨으면 한다고 전달받으셨을 텐데 옆집 막내가 집을 안 가니까 괜히 자꾸 의식하게 된다. 오늘 분량은 다 마친 것 같은데도 상쾌하게 자리에서 일어나질 못하는….</p><p>다음주부터는 그냥 당당하게 나의 길을 가야겠다. 반바지도 그냥 입기 시작했다. 그렇다고 해이하게 근무하진 않았다. 출근시간보다도 한시간씩 빨리 나왔으며(이거는…. 의도한 게 아니라 그냥 붐비는 시간대 피해서 나 좋자고 이렇게 나오는거다) 집중할 때는 최고의 집중으로 계획한 것 만큼의 진행률을 기록하고 있다. </p><p>다 잘 돌아가고 있는 것 같다. 기분이 좋다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;네이버에서의-첫-일주일&quot;&gt;&lt;a href=&quot;#네이버에서의-첫-일주일&quot; class=&quot;headerlink&quot; title=&quot;네이버에서의 첫 일주일&quot;&gt;&lt;/a&gt;네이버에서의 첫 일주일&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;네이버에서 채용전제형 인턴으로 일하게 되
      
    
    </summary>
    
      <category term="naver" scheme="https://tech.wheejuni.com/categories/naver/"/>
    
      <category term="intern" scheme="https://tech.wheejuni.com/categories/naver/intern/"/>
    
    
  </entry>
  
  <entry>
    <title>jstat으로 JVM 메모리 사용을 구경해보자.</title>
    <link href="https://tech.wheejuni.com/2018/06/19/jstat-monitoring/"/>
    <id>https://tech.wheejuni.com/2018/06/19/jstat-monitoring/</id>
    <published>2018-06-19T05:25:37.000Z</published>
    <updated>2021-01-20T14:13:54.921Z</updated>
    
    <content type="html"><![CDATA[<h3 id="jstat으로-JVM-메모리-사용을-구경해보자"><a href="#jstat으로-JVM-메모리-사용을-구경해보자" class="headerlink" title="jstat으로 JVM 메모리 사용을 구경해보자."></a>jstat으로 JVM 메모리 사용을 구경해보자.</h3><p>JVM에 대해 학습하다보면 gc가 정말 이론대로(?) 움직이는지 궁금해질 때가 있다. </p><p>IDE에서의 디버깅으로는 이런 메모리 정보를 직관적으로 알기 어렵다. 그래서 jstat이라는 도구가 있다. 참 좋은 도구다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -옵션 -JVM pid</span><br></pre></td></tr></table></figure><p>옵션에는 다양한 프로파일링 타겟이 존재한다. </p><table><thead><tr><th>옵션명</th><th>특징 </th></tr></thead><tbody><tr><td>class</td><td>클래스 로더 동작</td></tr><tr><td>gc</td><td>heap 영역 전체에 대한 데이터</td></tr><tr><td>gcnew</td><td>New 세대에 대한 데이터</td></tr></tbody></table><p>등등이 있다. 이중 내가 시도해본 것은 gcnew이다. </p><p><img src="https://scontent-icn1-1.xx.fbcdn.net/v/t1.0-9/35495645_542053236189591_3224093560965955584_n.jpg?_nc_cat=0&amp;_nc_eui2=AeGfel3hb7tB27dSXNWkPYTKygGbG9RonYNwQChcwFYkCwwkVu0Rd2tKhi4ekYe3IaDTDBwRehHDv2O-QbOd_RBWfjdrPvQQWTbn9PmCpCmkkg&amp;oh=db8ee0c93ee7d69d1f9948b027929526&amp;oe=5BEB815C" alt="작동중인 jstat"></p><p>위 사진에서 맨 오른쪽 열이 gc counter, 즉 new 영역에 대한 minor GC가 발생한 숫자를 기록하고 있는 부분인데 12에서 13으로 한 개 증가하며 한 칸 왼쪽의 열이 보여주고 있는 Eden의 메모리 사용량이 확 줄어든 것을 볼 수 있었다. </p><p>스크린샷에는 잡히지 않았지만 이 때 가득차있던 S0 영역이 완전히 비워지고 S1에 메모리 사용이 잡히기 시작했다. <em>S0, S1 어느 하나는 완전히 비어있어야 한다</em> 는 JVM 이론 시간의 공부가 눈 앞에서 확인되는 순간이었다. </p><p>여러분도 집에서 심심할 때 한 번 돌려보시면 좋겠다. 물론 <strong>공부하는 입장에서야 심심할 때 해볼 수 있는 일이겠지만 상용 서비스를 개발하는 개발자에게는 중요한 정보일 것이다.</strong> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;jstat으로-JVM-메모리-사용을-구경해보자&quot;&gt;&lt;a href=&quot;#jstat으로-JVM-메모리-사용을-구경해보자&quot; class=&quot;headerlink&quot; title=&quot;jstat으로 JVM 메모리 사용을 구경해보자.&quot;&gt;&lt;/a&gt;jstat으로 JV
      
    
    </summary>
    
      <category term="jstat" scheme="https://tech.wheejuni.com/categories/jstat/"/>
    
      <category term="jvm" scheme="https://tech.wheejuni.com/categories/jstat/jvm/"/>
    
      <category term="java" scheme="https://tech.wheejuni.com/categories/jstat/jvm/java/"/>
    
    
  </entry>
  
  <entry>
    <title>JPA N + 1 문제를 해결하자.</title>
    <link href="https://tech.wheejuni.com/2018/06/16/jpa-cartesian/"/>
    <id>https://tech.wheejuni.com/2018/06/16/jpa-cartesian/</id>
    <published>2018-06-16T01:57:31.000Z</published>
    <updated>2021-01-20T14:13:54.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JPA-N-1-문제를-해결하자"><a href="#JPA-N-1-문제를-해결하자" class="headerlink" title="JPA N + 1 문제를 해결하자."></a>JPA N + 1 문제를 해결하자.</h3><p>지난 겨울 프로젝트를 진행하며 일대다 관계를 많이 갖는 엔티티 클래스를 작성할 일이 있었다. 여느 때처럼 JPA의 도움을 받아 어렵지 않게 작성했다고 생각했는데, 데이터베이스 관리와 데브옵스 역할을 담당하고 있던 팀원이 난처한 표정을 짓는 것을 볼 수 있었다. </p><p><strong>엔티티 한 개 조회할 때마다 엄청난 양의 쿼리가 발생한 것이다.</strong> </p><p>처음에는 이 문제에 대해 정확히 이해하지 못하고 자식 엔티티의 자료구조를 바꾼다던지, named query를 사용한다던지 하는 피상적인 해결책만을 생각해낼 수밖에 없었다. SQL의 관점에서 생각해보면 자식 엔티티는 당연히 INNER JOIN 과 같은 키워드로 한 번에 빼오면 되는 문제였는데 이렇게 많은 쿼리가 발생한다는 것을 이해하지 못했기 때문이었다. </p><p>그러나 JPA에 대해 학습하면 할수록 이런 동작은 단순한 우연이 아닌 필연적인 부분이란 것을 알게됐고 이런 이슈를 최적화하는 것이 <strong>역량있는 개발자의 모습</strong> 이 아닐까 하고 생각하게 됐다. 더불어 상당수 조직과 초보 개발자들이 JPA 도입을 꺼리는 이유이기도 하다는 걸 알게 됐다. </p><h4 id="언제-발생하는가"><a href="#언제-발생하는가" class="headerlink" title="언제 발생하는가?"></a>언제 발생하는가?</h4><p>다음의 예제 엔티티 클래스들과 함께 설명을 진행해보겠다. </p><p>마스터와 학생은 일대다 관계를 갖고 있다. 한 마스터가 여러명의 학생을 관리하고 있고, 양방향 연관관계가 수립되어 있다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Master</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="keyword">private</span> Master master;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아래는 마스터들을 조회할 수 있는 레포지토리 인터페이스이다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MasterRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Long</span>, <span class="title">Master</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    (JPA 레포지토리가 기본 제공해주는 메소드들이 당연히 포함되어 있다.)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 상황에서 MasterRepository.findAll() 을 실행했을 때, 우리는 이런 쿼리가 날라가길 기대할 것이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">MASTER</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> STUDENT</span><br><span class="line"><span class="keyword">ON</span> STUDENT.MASTER_ID = MASTER.ID</span><br></pre></td></tr></table></figure><p><em>현실은…..</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">MASTER</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> MASTER_ID = <span class="number">0</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> MASTER_ID = <span class="number">1</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> MASTER_ID = <span class="number">2</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> MASTER_ID = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>DB에 상당한 부하를 일으키게 된다. </p><h4 id="왜-이러는가"><a href="#왜-이러는가" class="headerlink" title="왜 이러는가?"></a>왜 이러는가?</h4><p>JPA가 객체를 조회할 때 SQL이 아닌 <strong>JPQL의 생성과 파싱</strong> 으로 출발하기 때문이다. JPQL이란 SQL을 추상화한 객체지향 쿼리 언어로써, 자바 코드에서 데이터베이스를 조회할 때 특정 SQL 방언이나 저장 엔진에 종속되지 않게 도와준다. 또한 자바 코드를 작성하며 조회할 수 없을만 한 데이터베이스의 테이블명이나 컬럼 이름 대신 POJO의 필드명을 쿼리에 사용할 수 있으므로 개발에 편의성을 제공해 준다. </p><p>그리고 JDBC template의 Prepared Statement보다 한 단계 더 사용하기 편리한 지명 파라메터(named parameter) 기능을 제공한다. 말 그대로 쿼리 안에 변수를 대입할 수 있는 기능으로 잘 활용해 쿼리의 재사용성을 확보하여 조회 성능을 튜닝하고, SQL 주입 공격을 방어할 수 있다. </p><p>언뜻 보면 SQL보다도 좋아보이는 외계인의 기술 같지만 <strong>JPQL의 생성과 실행도 결국 SQL의 실행으로 귀결된다</strong> 는 점을 기억해야 하겠다. 우리가 겪고 있는 N + 1 문제도 사실 여기서 출발한 것이다. </p><p><em>간단한 JPQL 시범</em></p><p>모든 마스터 엔티티를 조회한다고 해보자. </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> m <span class="keyword">from</span> <span class="keyword">Master</span> m</span><br></pre></td></tr></table></figure><p>언뜻 보면 마스터의 모든 정보를 조회한 것 같지만 그렇지 않다. 애스터리스크가 있어야 할 자리에 객체의 별칭(alias)이 들어가 있는 점에 주목하자. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Master&gt; masters = em.createQuery(<span class="string">"select m from Master m"</span>, Master<span class="class">.<span class="keyword">class</span>).<span class="title">getResultList</span>()</span>;</span><br></pre></td></tr></table></figure><p>모든 마스터를 불러온다. 아까 살펴본 것처럼 마스터 객체에는 List<student> students 라는 필드가 있었다. </student></p><p>상기한 쿼리가 실행된 시점에서 이 필드는 <em>아직 조회되지 않았다.</em> </p><p><strong>지연 로딩</strong></p><p>객체에서 해당 필드에 대한 정보를 필요로하게 된 시점에, 지연 로딩이 발생하고, 여기서 모든 문제가 시작된다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Master m = masters.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(m.getStudents.size());</span><br></pre></td></tr></table></figure><p>마스터 객체에 대한 조회는 이미 끝났는데 학생 객체를 다시 조회해야 하므로 JOIN 문을 사용할 수 없고, 마스터의 @Id 값만 가지고 일일이 SELECT문을 만들어 다시 조회해야 하는 부담이 생긴다. </p><h3 id="해결책"><a href="#해결책" class="headerlink" title="해결책"></a>해결책</h3><p><strong>단순하게 생각하면 - EAGER 하게 로딩한다. (즉시 로딩)</strong></p><p>초보 개발자들이 흔히 하는 오해이고 이렇게 되면 모든 문제가 해결되리라 생각한다. 이렇게 엔티티 클래스를 고치는 것이다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OneToMany</span>(fetch = FetchType.EAGER)</span><br><span class="line">List&lt;Student&gt; students = Lists.newArrayList();</span><br></pre></td></tr></table></figure><p>그러나 작성된 쿼리 메소드가 JPQL로 변환되고 다시 그 JPQL이 실행되는 Spring Data JPA의 특성상, 이런 수정은 <strong>절대로 문제를 해결해주지 않는다.</strong></p><h4 id="두-번-생각하면-join-fetch-전략-사용"><a href="#두-번-생각하면-join-fetch-전략-사용" class="headerlink" title="두 번 생각하면 - join fetch 전략 사용"></a>두 번 생각하면 - join fetch 전략 사용</h4><p>커스텀 레포지토리를 작성한 후 직접 쿼리 메소드에 사용할 JPQL을 명시해주면서, fetch 키워드를 추가해주는 것이다. </p><p>커스텀 레포지토리의 작성은 이 글의 범위를 벗어나는 것 같아 다루지 않겠다. 아래와 같은 JPQL을 넣어주면 된다. </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> m <span class="keyword">from</span> <span class="keyword">Master</span> m <span class="keyword">join</span> <span class="keyword">fetch</span> m.students</span><br></pre></td></tr></table></figure><p>이는 아래와 같은 SQL문으로 번역된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">MASTER</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> STUDENT</span><br><span class="line"><span class="keyword">ON</span> STUDENT.MASTER_ID = MASTER.ID</span><br></pre></td></tr></table></figure><p><em>(실제 번역내용은 하이버네이트의 규칙을 따르므로 이와 상이하다)</em></p><h4 id="자식-엔티티-조회에-조건이-걸린다면-FetchMode-SUBSELECT"><a href="#자식-엔티티-조회에-조건이-걸린다면-FetchMode-SUBSELECT" class="headerlink" title="자식 엔티티 조회에 조건이 걸린다면 - FetchMode.SUBSELECT"></a>자식 엔티티 조회에 조건이 걸린다면 - FetchMode.SUBSELECT</h4><p>JPQL을 직접 작성해 영속성 콘텍스트에서 데이터를 조회하는 시점에 조건문이 걸린다면 이와 같은 구현을 해볼만 하다. </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> m <span class="keyword">from</span> <span class="keyword">Master</span> m <span class="keyword">where</span> m.id &gt; <span class="number">10</span></span><br></pre></td></tr></table></figure><p>학생을 관리하는 리스트 필드에 @Fetch(FetchMode.SUBSELECT) 가 걸려있다면 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT</span><br><span class="line"><span class="keyword">WHERE</span> STUDENT.MASTER_ID <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">ID</span> <span class="keyword">FROM</span> <span class="keyword">MASTER</span></span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">ID</span> &gt; <span class="number">10</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>위와 같이 실행된다. </p><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>N + 1과의 사투는 JPA 개발자라면 누구나 한번쯤 겪어보며 경험치를 올려야 할 이슈들 중에 하나다. </p><p>물론 이 글에서 나는 단편적으로 N + 1 문제만을 해결하는 방법 몇 가지에 대해서만 설명한 것이고 실제 MVC계층 구조를 갖는 Spring 환경에서 이 해결책들을 적용하려면 Lazy Initialization Exception 문제를 비롯해서 JPA 객체의 생명주기에 따른 다양한 문제점들이 파생되어 나올 것이다(DETACHED 상태에서 지연로딩이 발생하지 않는다는 것을 기억하자). </p><p>다음에 기회가 되면 이런 문제들에 대한 솔루션도 글로 정리해보고 싶다. </p><p>여튼, N + 1 문제를 해결하려면 다음 두 가지를 잘하자. </p><ul><li>어지간해선 지연 로딩을 사용하자(기본값이 즉시로딩인 경우에도 애노테이션을 통해 지연 로딩을 강제하자)</li><li>JOIN이 필요하다고 생각되는 시점에 인위적으로 JOIN을 걸어주자. </li></ul><p>끝. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JPA-N-1-문제를-해결하자&quot;&gt;&lt;a href=&quot;#JPA-N-1-문제를-해결하자&quot; class=&quot;headerlink&quot; title=&quot;JPA N + 1 문제를 해결하자.&quot;&gt;&lt;/a&gt;JPA N + 1 문제를 해결하자.&lt;/h3&gt;&lt;p&gt;지난 겨울 프로
      
    
    </summary>
    
      <category term="jpa" scheme="https://tech.wheejuni.com/categories/jpa/"/>
    
      <category term="database" scheme="https://tech.wheejuni.com/categories/jpa/database/"/>
    
    
  </entry>
  
  <entry>
    <title>데이터베이스 트랜잭션을 잘 알고싶다.</title>
    <link href="https://tech.wheejuni.com/2018/06/14/database-transaction/"/>
    <id>https://tech.wheejuni.com/2018/06/14/database-transaction/</id>
    <published>2018-06-14T09:33:38.000Z</published>
    <updated>2021-01-20T14:13:54.913Z</updated>
    
    <content type="html"><![CDATA[<h3 id="데이터베이스-트랜잭션을-잘-알고싶다"><a href="#데이터베이스-트랜잭션을-잘-알고싶다" class="headerlink" title="데이터베이스 트랜잭션을 잘 알고싶다."></a>데이터베이스 트랜잭션을 잘 알고싶다.</h3><p>Git을 처음 배우던 시절 Git에 대한 오해들이 좀 있었는데, 그 중 하나는 <code>git commit</code> 과 <code>git push</code>를 혼동하던 것이었다. </p><p><strong>커밋만 하면 원격 저장소에 반영되었다고 생각한 적이 있었다.</strong> 이런 오해는 대형 참사를 불러왔다. 특히 노트북이 없어 학교 전산실에서 작업하고 깃에 올려놓고 집에서 또 작업하고 하던 시기였기 때문에 앗차 하고 컴퓨터를 다시 켜 봐도 데이터는 이미 롤백된 후였다. </p><p>시간이 흘러 데이터베이스 공부를 시작하는 시점이 됐다. 별 생각 없이 사용하던 <code>INSERT INTO</code>가 사실은 깃의 커밋에 불과한 일이란 것을 알게 됐다. </p><p>그치만 데이터가 다행히도 전부 살아있었던 것은 MySQL이 <em>기본값으로 오토 커밋을 지원하기 때문</em> 이라는 소름돋는 사실을 알게됐다. </p><p><strong>트랜잭션과 커밋</strong> </p><p>트랜잭션은 데이터베이스에 변경 사항을 반영하는 행위, 혹은 행위의 집합을 일컫는다(실제 정의는 다를 수 있겠다. 하지만 나는 이렇게 이해해보려고 한다). </p><p>데이터베이스의 트랜잭션은 아래의 네 가지 속성을 만족시켜야 한다. </p><ul><li><p>A - Atomicity(원자성)</p><ul><li>각 트랜잭션은 시작부터 끝까지 결과를 보장해야 하며 중도에 간섭이나 장애가 발생해서는 안된다. </li><li>e.g. 은행 거래 - 입금 트랜잭션이 발생하려면 내 계좌에서 돈을 까고 상대 계좌에 잔액을 더하는 일련의 과정이 한번에 성공해야 한다. </li><li>입금 트랜잭션에 문제가 발생할 것 같으면 <strong>내 계좌에 있는 돈을 차라리 까지 말고 모든 거래 과정이 모두 실패해야만 한다.</strong> </li></ul></li><li><p>C - Consistency(일관성)</p><ul><li>데이터베이스가 원래 갖고 있는 제약 조건과 트랜잭션은 일관되게 유지돼야 한다. </li><li>잔액이 음수가 될 수 없다는 제약 조건이 있다면, 잔고보다 많은 송금 요청이 들어온다면 그 트랜잭션은 무효 처리 돼야 할 것이다. </li></ul></li><li><p>I - Isolation(고립성)</p><ul><li>트랜잭션은 다른 트랜잭션에 종속적이거나 영향을 받으면 아니 된다. </li></ul></li><li><p>D - Durability(내구성)</p><ul><li>트랜잭션은 한 번 데이터베이스에 반영되면 그 내용이 손실되어서는 안 된다. </li></ul></li></ul><p>위 조건을 충족하는 건강한 트랜잭션이 시작됐다면 해당 트랜잭션은 <em>커밋되거나 롤백</em> 돼야 한다. </p><ul><li>COMMIT : 데이터베이스에 해당 트랜잭션을 반영함. </li><li>ROLLBACK: 반영하지 아니함. </li></ul><p><strong>고립 수준</strong> </p><p>thread-safe 문제와 비슷한 상황이 데이터베이스에서도 연출될 수 있다. 데이터베이스는 당연히 다중 접근 시나리오를 상정하고 설계해야 한다. 내가 만들어놓고 나만 쓰고 읽을 거라면 그냥 일기장에 쓰지 굳이 데이터베이스를 운영할 이유가 있을까? 데이터베이스는 많은 사용자가 한번에 쓰고 한번에 읽을 것을 계산에 넣고 만들었기 때문에 <strong>한 시점에 한 데이터를 읽거나 쓰는 동작에 대한 대처</strong> 가 당연히 설정돼있어야 한다. </p><p>트랜잭션이라는 개념이 생긴 것도 그런 까닭이다. 데이터베이스에 접근하는 시도가 모두 트랜잭션의 기준에 맞을 리도 없고, 또 데이터를 쓰는 중에 오류나 손실이 발생할 수도 있기 때문에 트랜잭션 커밋이라는 안전장치를 둬서 네가 반영한 변경 사항이 정말 의도와 맞는지를 체크하게 만들어 놨다. </p><p>문제는 <strong>트랜잭션이 커밋, 혹은 롤백 되기 이전에 같은 데이터를 읽는 동작에 대한 처리</strong> 일 것인데 이를 고립 수준 설정으로 해결하고 있다. </p><p>또 이 설정에 따라 세 가지의 현상이 발생할 수 있는데 이것을 dirty read, non-repeatable read, phantom read라고 칭한다. 이에 대한 각각의 설명은 후술하기로 하고 일단 이것들을 D, R, P로 칭하겠다. </p><ul><li><p>READ UNCOMMITTED - 커밋되지 않은 변경 읽음 </p><ul><li>커밋하지 않은 상태여도 변경사항을 읽어들일 수 있다. </li><li>언뜻 보면 투명하니 좋아보이지만 만약 상대가 트랜잭션을 롤백한다면 잘못된 데이터를 읽어들인 셈이 된다. </li><li>D, R, P</li></ul></li><li><p>READ COMMITTED - 커밋되면 읽음 </p><ul><li>커밋하지 않은 트랜잭션은 가리고, 커밋한 트랜잭션만 읽어들인다. </li><li>반영되지 않을 트랜잭션을 읽어들이지 않는다는 장점은 있지만, 데이터를 삭제하는 커밋이 발생할 경우, 처음 조회된 데이터를 영영 찾을 수 없을 것이다. </li><li>R, P</li></ul></li><li><p>Repeatable Read - 데이터 반복 조회 </p><ul><li>같은 트랜잭션 내에서 한번 더 조회가 발생해도 원래 있던 데이터를 읽어들인다. </li><li>P</li></ul></li><li><p>Serializable </p></li></ul><p><strong>Dirty Read, Non-Repeatable Read, Phantom Read</strong> </p><p>격리 수준과 그에 따른 현상들을 설명해본다. </p><ul><li>Dirty Read - 말 그대로다. 더러운 것을 읽는다. </li></ul><p>Read Uncommitted 상태에서만 발생한다. 커밋되지 않은 트랜잭션을 들여다볼 수 있기 때문에 <strong>반영되지 않을 데이터가 조회되는 문제점이 생기는 것이다.</strong> 데이터를 갖다 쓰는데 실제로 반영되지 않을 데이터였다면 문제가 발생할 것이다. </p><p>이를 방지하기 위해 대부분의 DBMS에서는 <strong>Read Committed를 기본값으로 둔다.</strong> </p><ul><li>Non-Repeatable Read - 돌아올 수 없는 다리 </li></ul><p>한 번 읽어들인 데이터가 다른 트랜잭션 세션에서의 DROP으로 인해 unreachable 상태로 접어드는 것을 말한다. </p><p>커밋된 트랜잭션만 읽어들인다 해도 데이터 자체가 날라가버리면 이 현상을 피할 길이 없다. </p><ul><li>Phantom Read - 데이터베이스의 유령</li></ul><p>트랜잭션이 끝나지 않은 상태에서 조회된 데이터에 대해, 다른 세션의 트랜잭션을 통해 데이터가 추가된다면, 다음 질의에서는 그 데이터가 나타나게 된다. </p><p>이 상황에서 작업을 잘 하다가 만약 다른 세션의 트랜잭션이 롤백된다면 데이터는 망한다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;데이터베이스-트랜잭션을-잘-알고싶다&quot;&gt;&lt;a href=&quot;#데이터베이스-트랜잭션을-잘-알고싶다&quot; class=&quot;headerlink&quot; title=&quot;데이터베이스 트랜잭션을 잘 알고싶다.&quot;&gt;&lt;/a&gt;데이터베이스 트랜잭션을 잘 알고싶다.&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="database" scheme="https://tech.wheejuni.com/categories/database/"/>
    
      <category term="mysql" scheme="https://tech.wheejuni.com/categories/database/mysql/"/>
    
      <category term="jpa" scheme="https://tech.wheejuni.com/categories/database/mysql/jpa/"/>
    
    
  </entry>
  
  <entry>
    <title>JPA에 관한 질문들</title>
    <link href="https://tech.wheejuni.com/2018/06/09/jpa-questions/"/>
    <id>https://tech.wheejuni.com/2018/06/09/jpa-questions/</id>
    <published>2018-06-09T10:31:55.000Z</published>
    <updated>2021-01-20T14:13:54.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JPA에-관한-질문들"><a href="#JPA에-관한-질문들" class="headerlink" title="JPA에 관한 질문들"></a>JPA에 관한 질문들</h3><ul><li>프로젝트에 JPA를 사용하셨는데 다른 사람의 리포지토리를 보면 아시겠지만 MyBatis를 사용한 경우가 많았다. MyBatis를 사용하지 않은 이유는? JPA가 갖는 이점은?</li></ul><p>우선 저밖에 JPA를 사용하지 않은 것 같아 조금 당황스럽기도 했다. 그러나 주니어 개발자가 가장 많이 성장하고 많은 것을 배울 수 있는 건 JPA를 학습하는 일이라고 생각한다. </p><p>먼저 JPA를 통해 웹 애플리케이션을 설계하다보면 <strong>자연스레 객체지향적 설계에 대해 고민하게 된다.</strong> 어떻게 하면 JPA를 JPA답게 사용할까 고민하고 공부하는 그 자체가 <strong>객체지향 프로그래밍에 도움이 된다.</strong> </p><p>MyBatis는 ORM이 <strong>아니다.</strong> 물론 쿼리와 로직을 분리해낼 수 있는 템플릿 역할을 수행해주긴 하지만 도메인 객체의 설계가 바뀔 때마다 복잡한 설정의 변경 과정이 수반되어야 한다. 결국 쿼리를 미리 짜놓고 객체를 설계하는, 프로그램의 전체적인 개발 과정이 <strong>쿼리에 강하게 종속되는 문제를 절대 해결할 수 없다.</strong> JPA는 그런 부담감에서 개발자를 해결시켜주기 때문에 쿼리를 미리 생각해놓고 객체를 설계하는, 객체 지향이 아닌 쿼리 지향 프로그래밍을 해야하는 상황을 막아준다. </p><ul><li><p><em>꼬리질문: JPA가 객체지향적 사고에 도움이 된다고 했는데, JPA를 통한 객체지향적 설계를 가능케 해주는 기능들에 대해 설명해 보아라.</em></p><ul><li><strong>도메인 객체간에 상속관계를 설정할 수 있다.</strong> <code>@MappedSuperclass</code> 나 <code>@Inheritance</code> 애노테이션을 사용할 수 있고, 이런 상속 관계를 테이블에 매핑하는데 있어 TABLE_PER_CLASS나 JOINED 와 같은 전략을 설정할 수도 있다. </li><li>도메인 객체의 속성을 별도의 값 타입으로 분리해낼 수 있다. <code>@Embedded</code> 와 <code>@Embeddable</code> 을 통해 가능해지는 것이다. 이번에 핵데이를 참가하며 영속성 관리를 위해 마이바티스를 사용한 참가자들을 보니 대부분의 도메인 객체 필드들이 String 아니면 Integer였다. 그룹지어 객체 단위로 관리할 수 있는 속성들이 있음에도 마이바티스로 매핑해줘야 하는 부담이 있어 별도의 객체로 빼지 않은 것이다. </li><li><code>@Embeddable</code> 객체를 선언하면 JPA는 이를 별도의 테이블로 관리한다. PK는 없고, 자신을 갖고 있는 객체의 ID를 조인컬럼으로 관리하게 된다. </li></ul></li><li><p>JPA가 데이터를 저장하고 조회하는 과정을 논해 보세요. </p></li></ul><p>Spring Data JPA의 규약에 따라 개발자는 repository 인터페이스를 선언한다. 선언된 리포지토리 인터페이스는 런타임 시에 Spring 의 ApplicationContext에 의해서 프록시 객체로 구현되어 스프링 빈으로 관리되게 된다. </p><p>개발자는 <code>@Service</code> 나 <code>@Controller</code> 어디에서도 리포지토리를 호출할 수 있지만 베스트 프랙티스는 서비스 클래스에서 리포지토리를 호출하는 것이다. </p><p>repository bean에 정의된 메소드가 호출되면 영속성 콘텍스트가 만들어진다. 영속성 콘텍스트는 요청 1개(스레드 1개)에 하나씩 만들어지고 한번 쓰면 <strong>내다버린다.</strong> 1회용이다. </p><ul><li><em>꼬리질문: 한번 쓰고 내다버리면 오버헤드가 너무 큰 것 아닌가? 연산 비용이 너무 많이 소요될 거 같은데?</em><ul><li>그에 대한 고려를 해 Spring Data JPA에서는 EntityManagerFactory라는 객체를 두고 있다. </li><li>공장을 세우는 건 비용이 많이 들지만 공장에서 제품을 찍어내는 것은 비용이 그리 많이 들지 않는다. </li></ul></li></ul><p>영속성 콘텍스트가 요청을 접수한다. 영속성 콘텍스트는 영속성 콘텍스트 공장으로부터 전달받은 datasource를 통해 DB에 객체 정보를 질의하고, ResultSet이 돌아오면 갖고 있던 객체 정보를 통해 객체를 생성해 돌려준다. <strong>유념할 것은 이 객체는 새로 만들어진 객체라는 점이다.</strong> 이 때 객체의 상태는 detached 상태다. </p><ul><li><em>꼬리질문: 객체의 상태란 무슨 말인가? detached라면 어디서 떨어졌다는 말인지?</em><ul><li>영속성 콘텍스트의 세션에서 분리되었다는 말이다. </li><li>JPA에서 도메인 객체는 세 가지 상태를 갖는다 : MANAGED, DETACHED, TRANSIENT이다. </li><li>TRANSIENT는 아직 저장되지 않은 신삥 객체이므로 신경쓸게 별로 없지만 JPA를 처음 학습할 때 가장 구분하기 어려운 개념이 MANAGED와 DETACHED이다. </li><li>MANAGED 객체는 영속성 콘텍스트가 접수한 객체이며 <em>지금 관리중인 객체</em> 이다. 이 객체에 대해선 dirty check나 lazy fetch와 같은 영속성 콘텍스트가 제공해주는 편의 기능을 모두 사용할 수 있다. </li><li>DETACHED 객체는 영속성 콘텍스트가 <strong>접수한 적은 있지만 지금 관리하고 있지는 않은 객체</strong> 이다. 이 객체에 대해서는 JPA가 제공해주는 편의 기능을 하나도 사용할 수 없음에 유의해야 한다. 만약 이 객체가 관리하고 있는 field 중 lazy fetch하는 필드가 있다면 detached 상태에서는 어떠한 수를 써서도 이 필드를 가져올 수 없다. </li></ul></li></ul><p>조회에 대해서는 그렇게 혼동되는 개념이 없는데 저장은 조금 헷갈리는 개념 있을 수 있다. 가장 헷갈리는 개념은 <code>EntityManager.persist()</code> 가 호출된다고 해서 바로 데이터가 DB에 작성되는 것이 아니다. </p><p>JPA 환경에서 모든 쿼리는 쓰기 지연 저장소에 저장된다. 모든 쿼리를 저장해놨다가 <code>EntityManager.flush()</code> 가 호출되거나 모종의 사유로 엔티티 매니저 즉 영속성 콘텍스트가 문을 닫으면 그때 비로소 DB에 컨택해 트랜잭션을 시작하는 것이다. </p><ul><li><p><em>꼬리질문: 그러면 Spring Data JPA에서 영속성 콘텍스트는 언제 열리고 언제 닫히나?</em> </p><ul><li>기본적으로 Spring Data JPA에서는 트랜잭션을 repository bean 안으로 고립시켜놓고 사용한다. </li><li>이렇게 하면 영속성 콘텍스트에 대해 학습이 부족한 개발자들도 영속성 콘텍스트를 마치 JCF 다루듯이 편하게 쓸 수 있고, 쓰기 지연 등 JPA의 특성에 대한 이해가 없어도 쉽게 사용할 수 있을 것 같다.</li><li>그러나 JPA에 대한 이해를 갖춘 상태에서 이렇게 트랜잭션을 고립시키는 것은 옳지 않을 수도 있다. </li><li>가장 흔히 쓰이는 방법은 서비스 클래스에 repository를 주입받고 이 repository를 사용하는 메소드에 대해 <code>@Transactional</code> 애노테이션을 붙여주는 것이다. </li><li>이렇게 되면 서비스 빈이 Spring AOP에 의해 트랜잭션 부가 기능이 추가되어 트랜잭션의 범위가 리포지토리를 침범해 메소드 전역으로 확대되게 된다. </li><li>이 메소드 안에서 <code>repository.findById()</code> 등을 불러 객체를 조회하게 되면 이 객체는 DETACHED가 아닌 MANAGED 상태가 된다. </li><li>이 객체가 return되어 메소드의 실행이 종료되기 전까지 JPA가 제공하는 쓰기지연, dirty check와 같은 부가 기능들을 그대로 사용할 수 있고 lazy fetch의 이점도 누릴 수 있다. </li></ul></li><li><p><em>꼬리질문: Transaction이 지연되어 실행된다고 했는데 그러면 내부적으로 dirty read와 같은 현상이 재현되는 것 아닌가?</em></p><ul><li>그렇지 않다. 왜냐하면 JPA는 객체를 조회할때도 먼저 DB에 질의하는 것이 아니라 자신이 보관하고 있는 객체 스냅샷 저장소를 먼저 들여다보기 때문이다. </li><li>영속성 콘텍스트 공장에서는 JPA가 관리할 객체 (@Entity가 선언된 모든 객체)를 분석한 후 각 객체마다 하니씩 해시테이블의 형태로 객체를 보관할 수 있는 스냅샷 저장소를 만든다. </li><li>이 저장소에는 영속성 콘텍스트가 열려있는 동안 저장되거나 잘의된 모든 객체들이 들어있다. </li><li>따라서 특정 객체에 대한 요청이 들어오면 이 저장소에 만약 같은 PK나 @Id를 갖는 객체가 들어온다면, 이미 변경된 상태의 객체가 리턴되기 때문에 dirty read의 가능성은 없다. </li><li>그리고 한 메소드 안에서 수정과 조회를 같이 수행할 일이 거의 없다. 어차피 영속성 콘텍스트는 자신이 죽을 때 Transaction을 모두 수행하기 때문에 새롭게 메소드에 진입한다거나 하는 경우에는 전혀 해당사항이 없다. </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JPA에-관한-질문들&quot;&gt;&lt;a href=&quot;#JPA에-관한-질문들&quot; class=&quot;headerlink&quot; title=&quot;JPA에 관한 질문들&quot;&gt;&lt;/a&gt;JPA에 관한 질문들&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;프로젝트에 JPA를 사용하셨는데 다른 사람의 리포지
      
    
    </summary>
    
      <category term="java" scheme="https://tech.wheejuni.com/categories/java/"/>
    
      <category term="jpa" scheme="https://tech.wheejuni.com/categories/java/jpa/"/>
    
      <category term="tech_interview" scheme="https://tech.wheejuni.com/categories/java/jpa/tech-interview/"/>
    
    
  </entry>
  
  <entry>
    <title>운영체제에 관한 질문들</title>
    <link href="https://tech.wheejuni.com/2018/06/09/operating-systems-questions/"/>
    <id>https://tech.wheejuni.com/2018/06/09/operating-systems-questions/</id>
    <published>2018-06-09T08:50:36.000Z</published>
    <updated>2021-01-20T14:13:54.927Z</updated>
    
    <content type="html"><![CDATA[<h3 id="운영체제에-관한-질문들"><a href="#운영체제에-관한-질문들" class="headerlink" title="운영체제에 관한 질문들"></a>운영체제에 관한 질문들</h3><ul><li>동기와 비동기의 차이점에 대해 말해 보세요.</li></ul><p>synchronous와 asynchronous의 차이는 “반환값의 기대” 에서 발생한다고 생각합니다. system call이 발생했을 때 리턴값이 돌아올 때까지 기다리면 동기, 리턴값이 돌아올 때까지 기다리지 않고 리턴 값이 만들어졌을 때에 수행할 로직을 참조로써 전달(콜백) 하면 비동기이다. </p><p>동기와 비동기는 각각 blocking, non-blocking일 수도 있다. synchronous non-blocking일 수도 있다(event-driven). 대표적인 사례로 node.js를 꼽을 수 있겠다.</p><ul><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;운영체제에-관한-질문들&quot;&gt;&lt;a href=&quot;#운영체제에-관한-질문들&quot; class=&quot;headerlink&quot; title=&quot;운영체제에 관한 질문들&quot;&gt;&lt;/a&gt;운영체제에 관한 질문들&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;동기와 비동기의 차이점에 대해 말해 보세요.
      
    
    </summary>
    
      <category term="operating_system" scheme="https://tech.wheejuni.com/categories/operating-system/"/>
    
      <category term="tech_interview" scheme="https://tech.wheejuni.com/categories/operating-system/tech-interview/"/>
    
    
  </entry>
  
  <entry>
    <title>자료구조와 알고리즘에 관한 질문들</title>
    <link href="https://tech.wheejuni.com/2018/06/08/algorithm-ds-questions/"/>
    <id>https://tech.wheejuni.com/2018/06/08/algorithm-ds-questions/</id>
    <published>2018-06-08T00:28:21.000Z</published>
    <updated>2021-01-20T14:13:54.908Z</updated>
    
    <content type="html"><![CDATA[<h3 id="자료구조와-알고리즘에-관한-질문들"><a href="#자료구조와-알고리즘에-관한-질문들" class="headerlink" title="자료구조와 알고리즘에 관한 질문들"></a>자료구조와 알고리즘에 관한 질문들</h3><ul><li>소트 종류 아는대로 설명하시고, 좋아하는 소트가 있습니까? 설명하고 손코딩 한번 해 봐라. </li></ul><p>선형 소트와 비선형 소트로 나눠서 설명드려야 할 것 같다. 선형 소트는 시간 복잡도가 O(n) 에서 O(n^2)에 이르는 소트로써 원소를 하나 하나 비교하거나 순회한 후 다시 정렬하는 과정이기 때문에, 발상 자체는 간단하지만 시간 복잡도에서 손해를 크게 본다. </p><p>흔한 예로 버블 소트와 선택 소트(selection sort)를 들 수 있을 것 같다. </p><p>버블 소트는 n번째 원소와 n + 1번째 원소를 비교한 후 작은 것을 앞으로 오게 자리를 바꾸는 것이다. 원소의 숫자만큼 작업을 수행해야 하기 때문에 O(n!)의 시간복잡도가 발생한다. </p><p>선택 소트는 리스트의 크기를 하나씩 줄여나가면서 해당 리스트 안에서 가장 작은 원소를 가장 앞으로 빼는 정렬이다. O(n^2)가 발생한다. </p><p>소트에서 시간복잡도를 줄이려면 비선형 소트를 사용하는 것밖에 방법이 없다. 이른바 3대 소트라고 공부하기도 하는데 퀵소트, 머지소트, 힙소트가 꼽힌다. 셋 다 O(log n)의 시간복잡도를 갖는다. </p><p>제가 가장 좋아하는 퀵소트부터 설명드리면 우선 리스트에서 pivot 값을 고른 후에 리스트의 원소들을 비교하며 계속 재귀호출해 값을 정렬하는 것이다. 다만 이 때 pivot 값이 비효율적으로 설정되면 시간복잡도는 N^2 까지 치솟을 수도 있다. </p><p>제가 제일 좋아하는 소트니까 간단하게 손코딩을 보여드리겠다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick</span><span class="params">(array)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">    pivot = array[len(array) // <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    less = []</span><br><span class="line">    more = []</span><br><span class="line">    equal = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> array:</span><br><span class="line">        <span class="keyword">if</span> number &gt; pivot: </span><br><span class="line">            more.append(number)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> number &lt; pivot:</span><br><span class="line">            less.append(number)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        equal.append(number)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quick(less) + quick(equal) + quick(more)</span><br></pre></td></tr></table></figure><p><em>VS Code에서 짰으니까 손코딩이나 진배없다.</em> </p><ul><li>검색 종류 아는대로 말씀해 보시고, 좋아하는 검색이 있습니까? 설명하고 손코딩 한 번 해봐라. </li></ul><p>검색도 마찬가지로 선형과 비선형으로 나눌 수 있겠다. 선형 검색은 O(n)의 시간복잡도가 발생한다. </p><p>가장 단순하게 생각할 수 있는 방식은 이런 것일 것 같다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(array, n)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range len(array):</span><br><span class="line">        <span class="keyword">if</span> array[i] == n:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>한번씩 다 순회하는 방법인데 그리 효율적이지는 않다. 제가 좋아하는 검색은 이진 검색이다. </p><p>이진 검색은 퀵소트와 메카니즘이 참 비슷한데 중위값을 정해놓은 다음 목표값이 중위값보다 크면 중위값의 오른쪽 원소들로 검색 범위를 한정해서 다시 재귀 호출하고, 만약 작으면 왼쪽 원소들로 한정해서 똑같이 하는 것이다. </p><p>눈치채셨겠지만 이진 검색의 가장 큰 전제조건은 <strong>리스트가 정렬돼있다</strong> 는 것이다. 정렬되지 않은 리스트에서는 이진 검색을 사용할 수 없다. </p><p>만약 운이 정말 좋아 타겟값과 중위값이 일치한다면 시간복잡도는 O(1) 로도 빠질 수 있다. 그러나 말 그대로 이건 운이 좋은 경우고 평균적으로 O(log N)의 복잡도가 발생한다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary</span><span class="params">(array, target, start, end)</span>:</span></span><br><span class="line">    </span><br><span class="line">    middle_index = (start + end) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> middle_index &lt; start <span class="keyword">or</span> middle_index &gt; end:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> array[middle_index] == target:</span><br><span class="line">        <span class="keyword">return</span> middle_index</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> target &gt; array[middle_index]:</span><br><span class="line">        <span class="keyword">return</span> binary(array, target, middle_index, end)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> target &lt; array[middle_index]:</span><br><span class="line">        <span class="keyword">return</span> binary(array, target, start, middle_index)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><ul><li><p><em>당신은 자바 Backend 직무를 수행하게 될 것이다. Python으로 손코딩한 이유는?</em> </p><ul><li>저는 자바를 무척 좋아하고 사랑한다. 제가 개발을 시작한 언어이기도 하고 가장 자신있는 언어이기도 하다. </li><li>손코딩 중 다른 언어를 사용해 죄송합니다만 저는 그동안 자료구조 / 알고리즘 학습이나 예제 구현에 있어 Python 언어를 즐겨 사용해왔다. 가장 큰 이유는 <strong>Main 메소드가 없어도 되고</strong>, 두번째 이유는 <strong>클래스 바깥에서 함수를 선언할 수 있어 알고리즘 작성에 효율성이 좋았기 때문이다.</strong></li><li>제가 아는 만큼 정확하고 빠르게 보여드리기 위해 보일러플레이트를 최대한 소거시킨 Python 코드를 보여드린 것이다. 개념 이해가 중요하다고 생각했다. </li></ul></li><li><p><em>이진 탐색과 이진 탐색 트리가 이름이 비슷한 것 같은데 트리는 뭐가 달라요?</em> </p><ul><li>이진 탐색 트리란 이진 트리를 기반으로 구현한 것이다. </li><li>처음 입력되는 값을 부모로 하고, 작으면 왼쪽 크면 오른쪽 자식으로 놓는다. </li><li>이런 식으로 데이터를 정렬한 후, 트리를 중위 순회하면 값을 오름차순으로 정렬할 수 있다. </li></ul></li><li><p><em>중위 순회는 뭔가요? 순회가 뭐죠?</em> </p><ul><li>순회는 트리 자료 구조를 탐색하며 데이터를 조회하는 순서에 관한 방법론이다. </li><li>전위 순회: 부모부터 시작해 왼쪽 자식을 주욱 조회한 다음, 오른쪽 자식을 조회한다. </li><li>중위 순회: 왼쪽 - 부모 - 오른쪽 순서로 순회한다. </li><li>후위 순회: 왼쪽 - 오른쪽 - 부모 순으로 순회한다. </li></ul></li></ul><ul><li>해시의 개념에 대해 설명해 보세요.</li></ul><p>해시는 데이터를 정수 형태의 코드로 바꾸는 것이다. 데이터를 이렇게 바꿔주는 함수를 해시 함수라고 칭한다. </p><p>해시 함수는 나름의 알고리즘을 사용해서 데이터를 정수로 바꾸는데 모듈러(modulo) 연산이 가장 흔하고 간단한 예시일 것 같다. 데이터가 갖고 있는 필드 값 중 하나를 모듈러 연산 수행해서 그 나머지를 해시코드로 삼는 것이다. </p><p>같은 데이터가 같은 해시함수를 거친다면 항상 같은 결과가 보장돼야 하지만, 해시코드가 같다고 해서 해당 객체의 동등성까지 보장할 순 없다. 서로 다른 객체가 같은 해시코드를 갖게되는 것을 해시 충돌(hash collision) 이라고 부른다. 해시 코드를 인덱스로 삼아 객체를 저장하는 해시테이블에서 이와 같은 해시 충돌은 큰 제약 사항이 될 수도 있다.</p><p>해시 충돌을 해결하는 방법에는 크게 두 갈래가 있다. </p><ul><li>Open Addressing</li><li>Chaining</li></ul><p>먼저 오픈 어드레싱이란 원래 충돌이 발생했던 위치로부터 정해진 규칙에 따라 이동해서 새로운 인덱스에 객체를 보관하는 것이다. 여기엔 또 세 가지 기법이 있다. </p><ul><li>linear probing: 선형 프로빙. n 번째 인덱스에서 해시 충돌이 발생했다면 n + 1, n + 2 순서대로 계속 빈 자리를 찾아 헤매는 것이다. </li><li>quadratic probing: 지수함수의 형태로 인덱스를 탐색한다. </li><li>double hashing: 해시 충돌이 발생하면 다른 해시함수를 한번 더 돌린다. </li></ul><p>chaining이란 충돌이 발생한 인덱스에 링크드리스트와 같은 다른 자료구조를 적용해 같은 자리에 여러개의 값을 보관하는 것이다. </p><p>Open Addressing법의 단점은 최초 충돌이 발생한 위치의 데이터가 더이상 필요없게 되어도 계속 <strong>그 자리를 잡고 저장돼있어야 한다는 점</strong>이다. 만약 데이터가 필요없게 되었다고 그냥 메모리에서 해제하면 이 데이터를 기준으로 저장된 충돌이 발생한 다른 데이터들로 탐색을 수행할 수가 없다. entry point가 사라지는 것이다. </p><p>chaining법은 이런 문제는 없지만 해당 인덱스에 부가적인 자료구조가 더해지므로 공간 복잡도가 올라가는 단점이 있다. </p><p>오픈어드레싱, 체이닝 둘 다 시간복잡도는 O(n) 이다. </p><p><code>java.util.HashMap</code>은 체이닝을 사용한다.         </p><ul><li>링크드리스트와 배열의 차이에 대해 말씀해보세요. </li></ul><p>배열은 대표적인 선형 자료구조이다. 메모리에서 연속된 공간이 배열의 크기만큼 확보되어야 한다. 이는 데이터의 실제 존재 유무와는 무관하다. 때문에 인덱스를 알고 특정 데이터를 조회하는 작업의 시간 복잡도는 O(1)이다. 해당 인덱스에 바로 접근할 수 있기 때문이다. </p><p>그 대신 배열 요소의 삽입 / 삭제에는 큰 비용이 든다. 중간에 새로운 값이 들어왔다면 그 뒤의 원소들의 인덱스가 모두 수정돼야 한다. 삭제도 마찬가지다. 따라서 이런 작업들은 O(n) 의 복잡도가 소요된다. </p><p>한 번 값을 쓰고나면 크게 수정할 일이 없고, 인덱스값을 기준으로 객체를 조회할 일이 많을 때 적합한 자료구조이다. </p><p>링크드리스트는 원소가 다음 원소로 가는 참조를 보관한다. 뒤로만 보관하고 있으면 싱글 링크드리스트, 앞뒤로 다 보관하고 있으면 더블 링크드리스트이다. 더블 링크드리스트로는 뎈(deque)과 같은 원형 자료구조를 구현할 수 있다. </p><p>링크드리스트는 자료가 중간에 삽입되더라도 참조만 바꿔주면 되므로 O(1) 을 유지할 수 있다. 빈번한 삽입 삭제가 필요한 경우엔 링크드리스트를 사용해야 한다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;자료구조와-알고리즘에-관한-질문들&quot;&gt;&lt;a href=&quot;#자료구조와-알고리즘에-관한-질문들&quot; class=&quot;headerlink&quot; title=&quot;자료구조와 알고리즘에 관한 질문들&quot;&gt;&lt;/a&gt;자료구조와 알고리즘에 관한 질문들&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="data_structure" scheme="https://tech.wheejuni.com/categories/data-structure/"/>
    
      <category term="algorithm" scheme="https://tech.wheejuni.com/categories/data-structure/algorithm/"/>
    
      <category term="tech_interview" scheme="https://tech.wheejuni.com/categories/data-structure/algorithm/tech-interview/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP와 네트워크에 관한 질문들</title>
    <link href="https://tech.wheejuni.com/2018/06/07/http-questions/"/>
    <id>https://tech.wheejuni.com/2018/06/07/http-questions/</id>
    <published>2018-06-07T03:35:16.000Z</published>
    <updated>2021-01-20T14:13:54.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP에-관한-질문들"><a href="#HTTP에-관한-질문들" class="headerlink" title="HTTP에 관한 질문들"></a>HTTP에 관한 질문들</h3><ul><li>웹브라우저에 주소를 입력하고 화면이 뜨기까지의 과정을 설명해보세요. </li></ul><p>웹브라우저에 주소를 입력하면 우선 도메인 이름을 resolve해야 한다. </p><p>도메인 네임은 각 시스템마다 입력되어 있는 DNS 서버에 질의하는 방식으로 이뤄진다. 대부분의 경우 각 ISP가 제공해주는 DNS를 사용하고 있고 저 개인적으론 프라이버시에 관심이 많아 8.8.8.8 이라는 외국 사설 DNS를 사용하고 있다. 국내 DNS 서버들이 DPI 등 패킷 수준 감청에 활용되고 있다는 느낌을 받기 때문이다. </p><p>DNS는 자신이 갖고 있는 레코드와 질의 내용을 비교해본 후 자신이 갖고 있지 않은 정보라면 요청을 TLD 네임서버로 보낸다. TLD란 Top level Domain으로 <em>.ac.kr, </em>.com 과 같은 주소를 관리하는 서버들이다. </p><p>TLD로 질의가 올라간다고 해서 바로 답변을 얻을 수 있는 것은 아니고, 해당 도메인 대역에 대한 정보를 얻을 수 있는 NS로 다시 연결시켜준다. NS에서 마지막으로 도메인 이름을 IP주소로 바꿔주거나, CNAME 레코드인 경우 다시 도메인을 찾을 수 있도록 요청을 바꿔준다. </p><ul><li><em>CNAME이 뭔가? 도메인에도 종류가 있는 건가?</em><ul><li>도메인의 레코드에도 몇 가지 종류가 있다. </li><li>가장 기본적인 것은 A Record로 해당 도메인과 서버의 IP 주소가 바로 매치되는 것이다. </li><li>이외에도 CNAME이 있다. CNAME은 Canonical Name으로 원본 레코드 주소의 별칭 같은 것이다. 이때 원본 레코드는 IP주소이면 안되고 스킴 부분을 제외한 URL, 즉 순수 도메인 네임의 형태여야 한다.</li><li>MX 레코드는 메일 서버의 메일 주소 등록을 위해 사용한다. </li></ul></li></ul><p>일단 도메인 네임을 리졸브하고 나서 얻은 호스트 주소로 TCP 커넥션을 오픈하면(L4) 본격적인 데이터 교환이 시작된다. 브라우저가 보낸 GET 요청은 먼저 호스트측의 웹 서버에 닿을 것이다. </p><p>웹 서버는 GET 요청의 헤더를 차근차근 살펴본다. Host 헤더를 기준으로 요청을 역방향 프록시하는 경우가 많다. </p><ul><li><em>Host 헤더란 어떤 것인가? 역방향 프록시는 또 뭔 소린가?</em> <ul><li>Host 헤더는 HTTP 1.1의 표준으로 채택된 <strong>요청 측 헤더</strong> 의 한 종류다. </li><li>HTTP 1.0 까지는 Host 헤더가 부재했고, 일단 DNS를 통해 호스트의 주소를 밝혀내고 나면 이 요청이 어떤 주소를 향하고 있었는지를 알 방법이 없었다. referer 등의 헤더로 우회 구현할 수는 있었지만 부족한 경우가 많았다. </li><li>이 경우 req header의 URI 부분밖에 알 수가 없다(e.g. /home/user). HTTP 1.0 시대에는 이런 부족함이 문제가 안 됐을 수도 있다. </li><li>그러나 한 서버에서 여러 웹 서비스를 호스팅하는 <strong>가상 호스팅</strong> 이 보편화되면서 이 부족함은 큰 불편함이 됐고 따라서 다음 표준에서 Host 헤더가 도입된 것이다. </li><li>Nginx를 기준으로 말씀드리면 server block을 정의할 때 명시하는 <code>server_name</code> 값이 이 Host 헤더의 내용과 비교되는 것이다. </li><li>역방향 프록시란 이렇게 요청이 웹 서버까지 다 도달한 다음에야 다음 행선지로 요청이 넘어가는 방식을 말하는 것이다. 원래 네트워크에서 프록시란 클라이언트 측이 모든 요청을 특정한 행선지를 한 번 거쳐서 처리하게 설정하는 것을 말한다. 즉 지금 나가는 요청이 어디를 거쳐야하는지 클라이언트측에서 설정해야 하는 것이다. 이를 <strong>정방향 프록시</strong> 혹은 그냥 프록시라고 말한다. 그냥 프록시라고 많이 말하는 것 같다. </li><li>그러나 이런 구현을 클라이언트 측에서는 모르게 하고 호스트의 웹 서버에 도달해서야 호스트 웹 서버가 프록시처럼 작동하는 일을 역방향 프록시라고 칭한다. </li></ul></li></ul><p>요청이 이제 웹 서버의 역방향 프록시를 거쳐 웹 애플리케이션 서버에 도달했다. 만약 요청이 정적 자원이라면 웹 서버가 해당 자원을 리스폰스하고 요청이 종료될 것이다. </p><ul><li><em>정적 자원이란?</em><ul><li>말 그대로 바뀌지 않는 자원, 즉 파일을 말한다. 첨부파일이나 그림 파일, 간단한 텍스트 등등…. </li><li>제 프로젝트에서도 Nginx의 정적 호스팅 기능을 사용하였다. 단순한 첨부파일 조회, 이미지 파일 조회 등의 기능을 WAS로 넘기지 않고 Nginx단에서 처리함으로써 서비스의 부하를 줄이고 응답 속도를 빠르게 하고자 했다. </li><li>정적 자원 외에 동적 페이지, dynamic page가 있을 수 있다. 요청에 따라 응답 내용이 계속 바뀌어야 하는 경우엔 정적 호스팅으로 불충분하며 웹 애플리케이션 서버가 처리해줘야 한다. </li></ul></li></ul><p>만약 요청이 동적 응답을 요구한다면 앞서 말씀드린 역방향 프록시를 통해 웹 애플리케이션으로 요청을 전달해야 한다(L7). 애플리케이션은 요청을 열어보고 필요한 작업을 수행한 뒤 응답한다. 응답은 요청의 역순이다. </p><p>웹 브라우저는 돌려받은 HTML, CSS 등 파일을 한 줄 한 줄 열어보고 Gecko와 같은 레이아웃 엔진을 통해 화면을 그려낸다. </p><ul><li>HTTP method 아는대로 설명해보세요. </li></ul><p>GET, POST, PUT, PATCH, OPTIONS, DELETE….. </p><p>요청 헤더의 첫 줄, 가장 앞 칸에 HTTP 메소드가 명시된다. (GET /user/info)</p><p>중요한 것은 HTTP message의 형태차이는 GET과 POST 계열 두 가지만 있을 뿐이다. GET에서는 HTTP request body를 사용하지 않는다. POST 등 나머지에서는 본문이 존재한다. OPTIONS는 존재하지 않는다. </p><ul><li>상태 코드 아는대로 설명해보시오. </li></ul><p>100번대 : 단순 정보 </p><p>200번대: 요청 성공 코드. 200 OK </p><p>300번대: 변경 코드, 301 Moved Temporarily <em>(Permanently)</em>, 302 Found, 304 Unchanged…. </p><p>400번대: 요청측 오류 코드, 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found</p><p>500번대: 서버측 오류 코드, 500 Internal Server Error, 503 Bad Gateway </p><ul><li>TCP와 UDP의 차이점에 대해 서술하시오. </li></ul><p>TCP는 <strong>느리고</strong> UDP는 <strong>빠르다.</strong></p><p>왜 이런 차이가 나는지 설명하겠다. TCP는 아시는 것처럼 핸드셰이크도 수행하고 패리티 비트도 있다. </p><p>커넥션이 열리기 전 3-way handshake를 수행해야 한다. 연결이 닫힐 때는 4-way다. 이런 식으로 연결 상태를 확인하며 받는 쪽이 받을 준비가 됐는지, 보내는 쪽이 정보를 다 보내고 연결이 끊어진건지를 확인하는 것이다. </p><p>정합성이 중요한 데이터를 주고받을때는 커다란 장점이지만 정합성보다 속도가 요구되는 상황에서는 치명적인 약점이다. 예를 들면 온라인 게임같은 상황이다. 한 두개의 패킷 로스가 발생하더라도 속도를 높게 유지하는 것이 이런 상황에선 더 도움이 된다. 이럴때는 UDP를 써야 한다. </p><p>온라인 게임에서는 UDP를 사용해 RTT를 최대한 낮추려고 노력한다. 그래도 충분하지 않아 소프트웨어적으로 보간 지연(interpolation delay)을 둬서 클라이언트-서버 양측의 시간차이를 보정하기도 한다. </p><ul><li><p>OSI 7계층? </p><ul><li>1계층 : 물리 계층, RJ-45, RS-232 같은 규격들</li><li>2계층 : 데이터 링크 계층 </li><li>3계층 : 네트워크 계층</li><li>4계층 : 전송 계층</li><li>5계층 : 세션 계층</li><li>6계층 : 표현 계층 </li><li>7계층 : 응용 계층 </li></ul></li><li><p>HTTP 2.0의 특징에 대해 간단히 서술해 보시오.</p></li></ul><p>HTTP2.0은 빠르다. 그리고 안전하다. </p><p>우선 안전한 이유부터 설명드리면 2.0부터는 TLS의 적용이 의무화된다. L6 ~ L7을 아우르는 표준이 됐기 때문에 L6에서의 TLS를 의무화시킬 수 있었다. </p><p>그리고 빠르다. 빠른 이유는 두가지가 있는데 스트림과 서버 푸시다. </p><p>하나의 요청이 끝나고 4방향 악수가 끝난 다음에야 통신이 종료되고 다음 통신으로 넘어가는 기존 규격과는 다르게 2.0은 스트림을 열어놓고 필요한 정보를 계속 요청하거나 수신할 수 있다. 이 과정에서 헤더는 압축되어 표현된다. 연결을 새로 수립하고 끊는 오버헤드를 절감할 수 있다. </p><p>그리고 서버 푸시도 중요한 기술이다. 클라이언트가 특정 경로로 요청을 보냈을 때 부가적으로 요청해야 할 것들(웹페이지를 예로 들면 CSS나 .js 파일들)을 서버가 미리 알아차리고 푸시해줄 수 있다. 이 과정에서도 오버헤드가 절감된다. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTTP에-관한-질문들&quot;&gt;&lt;a href=&quot;#HTTP에-관한-질문들&quot; class=&quot;headerlink&quot; title=&quot;HTTP에 관한 질문들&quot;&gt;&lt;/a&gt;HTTP에 관한 질문들&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;웹브라우저에 주소를 입력하고 화면이 뜨기까지
      
    
    </summary>
    
      <category term="tech_interview" scheme="https://tech.wheejuni.com/categories/tech-interview/"/>
    
      <category term="http" scheme="https://tech.wheejuni.com/categories/tech-interview/http/"/>
    
    
  </entry>
  
  <entry>
    <title>자바에 관한 질문들</title>
    <link href="https://tech.wheejuni.com/2018/06/06/java-questions/"/>
    <id>https://tech.wheejuni.com/2018/06/06/java-questions/</id>
    <published>2018-06-06T01:15:55.000Z</published>
    <updated>2021-01-20T14:13:54.918Z</updated>
    
    <content type="html"><![CDATA[<h3 id="자바에-관한-질문들"><a href="#자바에-관한-질문들" class="headerlink" title="자바에 관한 질문들"></a>자바에 관한 질문들</h3><ul><li>객체지향의 5대 원칙에 대해 있는대로 설명해 보시오. </li></ul><p>5대 원칙이라고 말씀하시면 SOLID 말씀이실 것이다. 메탈기어 솔리드가 참 재밌었는데…. </p><p>S : SRP, Single Responsibility Principle로써 객체와 메소드가 각각 하나씩의 책임을 갖게 하는 원칙이다. 하나의 책임을 수행하도록 객체와 메소드의 분리를 수행해야 하고 필요하다면 접근 제어자를 통해 책임을 강제시키는 것도 필요하다.</p><ul><li>꼬리질문: 접근 제어자를 통해 책임을 강제시킨다는 말씀은 무슨 소린가? <ul><li>객체 내부의 정보에 다른 클래스의 메소드에서 맘대로 접근해 정보를 수정할 수 없게 하고 객체가 스스로 자신의 값을 바꾸는 등의 작업을 수행케 하는 것이다. 이는 객체지향의 다른 원칙들 중 하나인 캡슐화(encapsulation)에도 해당하는 사항이다. </li><li>예를 들어 몸무게 값을 갖고 있는 필드를 public으로 선언한다면 해당 필드에는 int 범위 내의 어떠한 숫자라도 위치할 수 있을 것이다. 이런 상황은 개발자가 의도하지 않은 상황으로, 이런 필드는 마땅히 수정자(setter) 메소드를 통해 접근해 값을 바꾸게 하고 데이터에 대한 유효성 검사를 시행하는 것이 옳다. </li><li>public 필드는 일단 API가 공개되면 개발자의 의도대로 값을 전혀 통제할 수 없기 때문에 위험하다. 이는 나중에 또 설명… </li></ul></li></ul><p>O: OCP, Open Close Principle로써 객체는 확장에는 열려있고(open) 변경/수정에는 닫혀있어야(close) 한다. 쉽게 말해 값이나 성질 등을 하드코딩하기보다는 다형성(polymorphism)과 상속을 활용해 새로운 클래스로 확장시켜나가는 작업이 필요하다. </p><p>L: Liskov Substitution Principle 즉 리스코프 치환 법칙이다. 변수의 타입이 선언됐을 때 하위 타입은 상위 타입의 기능을 문제없이 모두 수행할 수 있어야 한다. 하위 타입에만 존재하는 값이나 성질을 가지고 상위 타입의 메소드를 오버라이드하는 경우 이 원칙이 깨지는 경우를 많이 본다. </p><p>I: 인터페이스 </p><p><em>인터페이스 분리의 원칙이다. 타입에서 제공하는 메소드를 모두 사용할 필요가 없다면 더 작은 타입으로 분리해 내서 인터페이스를 다시 구현해야 한다.</em></p><p>D: Dependency Inversion Principle 의존성 역전의 원칙이다. 객체는 자신이 의존하고 있는 다른 객체의 세부 구현을 몰라도 된다는 원칙이다. 즉 “타입” 에 의존하고 “클래스” 에는 의존 관계를 갖지 말라는 얘기다. </p><p>저의 개인적인 생각입니다만 SRP와 OCP를 지키다보면 DIP는 자동으로 지켜지는 경우가 많았다. 객체가 하나씩 책임을 갖고 서로 의존관계를 갖다 보면 DIP는 자동으로 만족된다. 하나의 책임을 가진 객체들이 모여서 큰 기능을 이루게 되면 클래스나 메소드 내부의 하드 코딩된 값들이나 동작들이 모두 소거되고 확장성있고 유지보수하기 쉬운 코드를 작성하게 되는 것 같다. </p><p><em>더 좋은 답변: 더 안정적인 클래스/타입에 의존해야 한다는 원칙이다.</em></p><ul><li>추상클래스와 인터페이스의 차이는? 뭘 써야 옳은가? </li></ul><p>결론부터 말씀드리면 이펙티브 자바에서는 “인터페이스를 사용하라” 고 말한다. 제 생각도 같다. </p><p>인터페이스에도 디폴드 메소드가 도입됨에 따라 추상 클래스를 사용할 이유는 점점 없어지고 있다. 다만 추상 클래스를 사용하면 클래스가 사용하는 자료구조 등을 통일하도록 “권장” 할 수 있다는 점이 그나마의 이점이지만 어차피 서브클래스를 작성할 때 필드를 새로 정의하면 깨질 장점이므로 솔직히 말씀드리면 제 눈에 보이는 추상클래스의 장점이 별로 없다. </p><p>뿐만 아니라 추상클래스가 인터페이스에 비해 뒤떨어지는 가장 치명적인 단점은 <strong>다중 상속이 안 된다</strong> 는 점이다. 한번에 하나의 추상클래스만 상속받을 수 있으므로 여러 기능을 가지려면 여러 기능을 가진 슈퍼클래스를 갖던지 아니면 타입을 분리해내야 한다. </p><p>인터페이스는 다중 구현이 가능하므로 이런 단점을 극복할 수 있다. “믹스인(mix-in) 클래스를 만들기 쉽다” 고도 말한다. 예를 들어 Serializable도 갖고 Comparable도 가지면서 원래 구현하고자 하는 타입도 가지고 하는 식의 구현이 가능하다. </p><ul><li>JCF에 대해 있는대로 설명해보세요. </li></ul><p>JCF는 크게 세 가지 계열로 나눠볼 수 있을 것 같은데 List, Map, Set이 그것이다. 먼저 각 계열별 특징을 간략히 설명드리면 List는 순차 저장이 보장되는 배열같은 자료구조이고 값의 중복이 허용된다. Set은 값의 중복이 허용되지 않으며 순차 저장이 보장되지 않는다. Map은 Key-Value 쌍으로 이뤄진 자료구조이다. </p><p><strong>List</strong></p><p>List에서 흔히 사용하는 것을 ArrayList를 들 수 있다. ArrayList는 말 그대로 array를 사용한 리스트로 내부적으로 고정된 크기의 배열을 갖고 있다가 <strong>값이 가득 차면 두 배 늘어난 크기의 배열을 새로 만들고 거기에 데이터를 옮겨쓰는 작업을 반복</strong> 한다. </p><p>배열에 담긴 모든 데이터를 복사하고 옮기고 또 원 데이터를 말소시키는 작업은 오버헤드가 발생할 수 있기 때문에 처음부터 리스트가 꽤 많은 요소를 담을 것 같다 싶으면 애초에 좀 큰 배열을 사용하도록 명시적으로 선언해주는 것도 방법일 것이다. <code>java.util.ArrayList</code>의 생성자에는 int값으로 내부 배열의 초기 크기를 명시해줄 수 있다. 참고로 빈 생성자로 어레이리스트 객체를 선언했다면 내부에 만들어지는 배열의 크기는 16이다. </p><p>자바에서 가장 흔히 사용되는 선형 자료구조이고 연속된 배열을 사용하기때문에 인덱스를 아는 상태에서 값을 조회하는 작업은 O(1), 데이터의 삽입 / 삭제는 O(n)의 시간 복잡도가 발생한다. </p><p>자바에서도 Linkedlist를 사용할 수 있다. 똑같은 List 인터페이스의 구현체이기 때문에 사용법은 어레이리스트와 같고 단순히 앞 원소가 다음 원소의 주소값을 참조로 갖는 Single linkedlist로 구현되어 있다. 이 경우 데이터의 삽입 삭제도 O(1)로 수행할 수 있게 된다. </p><p>thread-safe가 보장돼야 하는 경우 synchronized 메소드와 자료구조가 적용된 <code>java.util.Vector</code>를 사용할 수 있지만 성능이 떨어지게 되기 때문에 필요한 상황에만 제한적으로 사용해야 하고 concurrent 패키지에 있는 CopyOnWriteArrayList의 사용을 고려해보는 것이 좋다. </p><p><strong>Map</strong></p><p>맵은 키 - 밸류 저장소 방식의 자료구조이다. 키는 <strong>중복될 수 없다</strong>. </p><p>Map 인터페이스의 잘 알려진 구현체로는 HashMap과 TreeMap이 존재한다. </p><p>우선 HashMap부터 살펴보면 이 자료구조는 해시테이블을 통해 키를 관리하고 값을 저장할 수 있는 자료구조이다. 해시테이블 구조이므로 키는 중복될 수 없다. Key는 또한 원시형 데이터 타입을 <strong>사용할 수 없다.</strong> java.lang.Object의 서브클래스만이 해시맵의 키가 될 수 있으며 hashCode()와 equals() 가 오버라이드되어 있는 객체여야 한다는 <strong>강제조건은 없지만 구현하는 것이 필수적이다.</strong> </p><ul><li><em>꼬리질문: 두 메소드가 오버라이드되어야 하는 이유는? 해시테이블의 동작 원리는?</em><ul><li>해시테이블의 작동 원리부터 살펴드리면 해시테이블은 객체를 해시 함수에 넣고 한번 돌린 후 산출된 해시값을 인덱스로 삼아 값을 저장하는 방식이다. </li><li>java.lang.Object의 hashCode() 메소드는 객체를 해시코드로 바꿔주는 메소드로써 아무런 오버라이드가 되어있지 않다면 native 메소드가 호출되어 <strong>사용중인 JVM의 전략에 따라 해시코드를 만들어주게 된다.</strong></li><li>참고로 말씀드리면 OpenJDK의 경우 해시 코드 생성 전략이 6개가 있는데 기본 전략은 2번, 메모리 주소 기반 생성법이다. </li><li>여튼 해시함수는 정의역이 치역보다 크기 때문에 <strong>생성된 해시코드의 중복은 필연적으로 발생하기 마련이다.</strong> 중복이 발생한 상황을 hash collision이라고 하며 이를 resolve하기 위해 open addressing, chaining 등의 방법이 사용되는데 java.util.HashMap은 chaining 법을 사용하고 있다. 이는 동일한 hashcode를 갖는 key에 엮인 값들은 몽땅 한 테이블에 링크드리스트의 형태로 몰아넣은 것이다. </li><li>이 때 중복이 발생한 인덱스까지 찾아가는 데에는 .hashCode()가, 일단 찾아간 후 실제 개발자가 원하는 값을 찾아 링크드리스트를 탐색하는 데에는 .equals() 를 통한 <strong>객체의 동등성 비교</strong>가 사용되기 때문에 두 메소드가 반드시 동시에 구현돼야 하는 것이다. </li></ul></li></ul><p>HashMap의 성능을 최적화하기 위해서는 좋은 전략으로 구현된 .hashCode()가 중요하고, 해시테이블의 적합한 사이즈도 중요하다. 비둘기집의 원리라는 것이 있다. 잠시 설명드리면 n개의 새장에 n + 1 마리의 새를 집어넣으면 적어도 하나의 새장에는 반드시 두 마리 이상의 새가 들어가게 되는 간단한 정리를 말하는 것이다. </p><p>아무리 고품질의 hash function도 충돌 현상을 피하기 어려운데 저장해야 할 객체의 숫자에 맞는 해시테이블의 크기마저 갖지 못했다면 해시 테이블의 성능은 떨어질 수밖에 없다. HashMap도 이를 충분히 고려한 후 구현되었기 때문에 0.75라는 <strong>load factor</strong> 상수값을 갖고 전체 사이즈의 75% 이상 객체가 차게 되면 자동으로 크기를 <strong>두 배 늘린다.</strong> </p><p>TreeMap은 Red-Black Tree 기반의 자료구조이다. 사용법은 해시맵과 같다. 키의 값을 기준으로 정렬이 필요할 때 더 우수한 성능을 보여준다. </p><p>thread-safe함을 보장하기 위해서 HashTable을 사용할 수 있는데 성능을 위해서라면 concurrent 패키지에 있는 ConcurrentHashMap을 사용하는 것이 더 좋겠다.</p><p><strong>Set</strong></p><p>Set은 값이 중복될 수 없고 순차적 저장이 보장되지 않는 자료구조이다. 자바책들에서는 보따리로 많이 비유하곤 한다. </p><p>HashSet은 HashMap을 기반으로 한 Set 인터페이스의 구현체이다. 내부적으로 HashMap의 키 값에 입력받은 객체를 다 넣고 구현한다. 이때 value 칸에 넣을 더미 오브젝트를 객체가 생성될 시점에 하나 만들어서 들고있는 것이 재밌는 점이다. </p><p>이외의 동작원리는 해시맵과 아예 같다. </p><p>TreeSet은 TreeMap을 기반으로 했다. </p><ul><li>접근 제어자에 대해 설명해보세요. </li></ul><p>네 종류가 있다. </p><ul><li>public: 암데서나 접근 가능함.</li><li>private: 아무데서도 접근이 불가능함. 자기 자신만 접근할 수 있음</li><li>(default): <strong>아무런 접근 제어자를 달지 않으면</strong> 디폴트 상태. 같은 패키지 내에서만 접근가능</li><li>protected: 같은 패키지 내와 <strong>자신을 상속한 서브클래스</strong> 에서 접근가능</li></ul><p>interface에서는 모든 메소드가 퍼블릭이다. </p><ul><li>Overload / Override 차이가 뭐에요? </li></ul><p>오버로드는 저그의 인구수를 늘려주는데 하이브에서 연구하면 수송선으로도 쓸 수 있다. 디텍터이기도 하다. </p><p>같은 이름을 갖는 메소드의 파라메터만 달리 해서 다른 기능을 수행시키는 것이다. 생성자 오버로딩이 즐겨쓰인다. 너무 남용하면 안되고 명확한 문서화를 통해 구현하는 것이 좋겠다. </p><p>무작정 생성자 오버로딩만 할 게 아니라 생성자 파라메터의 숫자가 많다면 <strong>builder 패턴의 도입을 고려</strong>해야 한다. </p><p>오버라이드는 상위 타입 / 클래스에 정의되어 있는 메소드를 자식 클래스에서 재정의하는 것이다. 대표적으로 <code>java.lang.Object</code> 에 구현되어 있는 메소드들을 오버라이드해서 쓰는 경우가 많다. </p><ul><li><p><em>꼬리질문: java.lang.Object에 있는 메소드들에 대해서 설명해보세요.</em></p><ul><li>hashCode(): 객체를 해시코드로 바꿔주는 메소드. </li><li>equals(): 객체의 동등성(equality)을 판별하는 메소드. </li><li>toString(): 객체를 문자열로 바꿔주는 메소드.</li><li>finalize(): 객체룰 소멸시키는 메소드…. 인데 이걸 부른다고 해서 바로 gc가 도는 건 아닙니다. </li><li>clone(): 객체를 복사하는 메소드. <strong>딥 카피가 필요한지 섈로우 카피가 필요한지 오버라이드 당시에 결단해야 합니다.</strong> </li></ul></li><li><p>static에 대해 설명해보세요. </p></li></ul><p>static은 정적 변수, 혹은 메소드로 주로 상수값을 저장하거나 유틸 클래스 등을 작성할때 즐겨 쓴다. </p><p>기술적인 설명을 해 보자면 이 static 변수는 클래스로더가 돌 때 객체가 만들어지지 않아도 무조건 heap에 변수가 저장되고 class area에 그 참조가 올라가게 된다. 따라서 new를 통해 객체를 만들지 않아도 원래의 기능을 다 수행할 수 있다. </p><ul><li>String에 대해 아는대로 설명해보세요. </li></ul><p>String은 재밌는 클래스인데 가장 흔히 쓰이지만 가장 오해도 많이 받기도 하고 JVM 내부적인 최적화도 많이 돼있는 클래스이다. </p><p>우선 String 객체를 만들때부터의 과정부터 설명드리고 싶다. 우리는 <code>String a = &quot;a&quot;;</code> 이런 식의 구현을 많이하고 <code>new String(&quot;a&quot;);</code> 와 같은 구현은 잘 하지 않는다. </p><p>문자열을 스트링 변수에 바로 할당하면 컴파일 타임에 최적화가 발생하는데, 이 최적화 과정 중에는 interning이라는 과정이 포함되어있다. 같은 값을 갖는 스트링 객체를 String pool에 보관하고 <strong>다음번에도 같은 문자열이 선언되면 새 객체를 만들지 않고 풀에서 갖다 쓰는</strong> 방식의 구조를 가지게 된다. </p><p>String pool이 어디에 위치하냐면…. JDK 1.6까지는 PermGen에 있었으나 1.7부터 PermGen을 deprecate시키기 위한 설계 변경을 하기 시작하면서 Tenured로 이동했다. 그 말인즉슨 gc의 대상이 된다는 말이다. </p><p>그래서 String은 객체이지만 <strong>동일성 비교</strong> 가 먹히는 경우도 있다. 풀에서 반환된 값의 경우 메모리 번지수까지 같을 가능성이 왕왕 있기 때문이다. 하지만 <strong>객체의 동일성으로 그 내용을 비교하는 것은 정석이 아니다.</strong> 어떠한 경우에도 String 클래스가 제공하는 <code>.equalsIgnoreCase()</code> 와 같은 메소드를 통해 객체의 동등성을 비교해야 할 것이다. </p><p>이유는 String에 관련한 유틸 클래스 중 interning 과정을 거치지 않고 문자열 객체를 만드는 경우가 종종 있기 때문이다. 예를 들어 <code>.substring()</code> 같은 메소드는 스트링을 몇 번째 자리부터 몇 번째 자리까지 잘라 새 객체를 만들어주는데 이 때는 인터닝 안하고 바로 <code>new String()</code>으로 객체를 만들어서 갖다준다. 이런 경우 어떠한 상황에도 <strong>동일성 비교가 먹히지 않는다.</strong></p><p>또 하나 우리가 기억해야 할 점은 String은 <strong>불변 객체</strong> 라는 점이다. 한번 선언되면 그 내용을 바꿀 수 없다. <strong>그렇기 때문에 interning과 같은 최적화가 가능한 것이다.</strong> 문제는 문자열의 내용을 바꿔야 할 일이 있을때 내용을 복제하고, 내용을 바꾼 다음 <strong>새로운 객체를 생성해 그 내용을 덮어써야 한다는 점</strong> 이다. 적지않은 오버헤드가 발생할 여지가 있다. </p><p>문자열의 덧셈 연산을 할 수 있다. <code>&quot;a&quot; + &quot;b&quot; = &quot;ab&quot;</code> 가 된다. 이런 덧셈 연산을 할 경우 .concat() 메소드도 있지만…. 이 메소드는 앞서 설명드린 내용을 그대로 코드로 바꾼 것에 불과하다. </p><p>문자열의 덧셈연산을 할 경우 JDK1.8 까지는 StringBuilder를 이용한 형태로 최적화된다. JDK1.9 부터는 <code>StringConcatFactory</code> 라는 객체의 도움을 받는 것으로 최적화 전략이 변경되었다. </p><ul><li><p><em>꼬리질문: 그러면 개발자가 StringBuilder를 선언해서 쓸 필요는 없겠다.</em></p><ul><li>그렇지 않다. 덧셈 연산 한 번당 빌더 객체 하나가 새로 만들어진다는 점에 주목하자. </li><li>같은 문자열 덧셈 연산을 100번, 1000번 수행했다면 글자 하나 더하고 객체를 버리고, 새로 만들고 하는 작업을 반복하게 된다. </li><li>이런 경우 처음부터 빌더를 만들어서 <code>.append()</code>로 최적화하는 방향이 맞다. </li></ul></li><li><p><em>꼬리질문: StringBuilder와 StringBuffer의 차이점에 대해 논하시오.</em> </p><ul><li>둘 다 슈퍼클래스는 AbstractStringBuilder로써 구현한 abstract method는 같다. </li><li>그러나 StringBuffer는 메소드와 변수에 synchronized 예약어를 붙여놓았다. <strong>thread-safe를 보장해야 할 상황에만 제한적으로 사용해야 퍼포먼스를 보장할 수 있다.</strong></li><li>개인적인 실험을 해 본 기억이 난다. StringBuilder와 StringBuffer의 .append() 작업을 각각 1억 번 수행했는데 3초(3000ms) 정도의 실행시간 차이가 발생했다. 적지 않은 차이라고 생각한다. </li></ul></li></ul><p><em>디자인 패턴 정리</em> </p><p><strong>Spring Framework</strong></p><p><strong>스프링에서 사용되는 디자인 패턴을 나열하고 설명해 보시오.</strong></p><ul><li><p>Builder 패턴: Security에서의 config method, 개발자가 정의한 모델 클래스의 생성에도 많이 쓰인다. </p></li><li><p>Adapter 패턴: Controller의 RequestMapping에 사용됨. </p></li><li><p>Factory 패턴: 특정 타입의 서브클래스들의 인스턴스를 만들어주는 패턴. JDBC 연동 등에 사용됨.</p></li><li><p>Decorator 패턴: 특정 타입의 구현체가 실제 구현체를 갖고 있으면서, 자신은 부가기능만을 구현하고 전달받은 실제 구현체에게 실제 기능을 위임하는 방식.<br>인터페이스의 수정 없이 부가기능을 구현할 수 있다. </p></li></ul><p>JDK Dynamic Proxy가 이 방식을 따른다. </p><ul><li>React.js 에서의 활용: 자바스크립트에서 decorator 패턴을 구현하는 좋은 사례는 고계함수(high-order functions)이다. 리액트에서도 고계 함수가 사용된다. 고계함수를 통해 routing, state management등의 부가 기능이 구현되며 고계함수에서는 부가기능만 구현하고 render()등 원래 기능의 구현은 고계함수의 생성자로 전달된 원래 컴포넌트에서 수행되는 것이다. </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;자바에-관한-질문들&quot;&gt;&lt;a href=&quot;#자바에-관한-질문들&quot; class=&quot;headerlink&quot; title=&quot;자바에 관한 질문들&quot;&gt;&lt;/a&gt;자바에 관한 질문들&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;객체지향의 5대 원칙에 대해 있는대로 설명해 보시오. &lt;/
      
    
    </summary>
    
      <category term="java" scheme="https://tech.wheejuni.com/categories/java/"/>
    
      <category term="tech_interview" scheme="https://tech.wheejuni.com/categories/java/tech-interview/"/>
    
    
  </entry>
  
  <entry>
    <title>스프링에 관한 질문들</title>
    <link href="https://tech.wheejuni.com/2018/06/04/spring-questions/"/>
    <id>https://tech.wheejuni.com/2018/06/04/spring-questions/</id>
    <published>2018-06-04T09:58:04.000Z</published>
    <updated>2021-01-20T14:13:54.930Z</updated>
    
    <content type="html"><![CDATA[<h3 id="스프링에-관한-질문들"><a href="#스프링에-관한-질문들" class="headerlink" title="스프링에 관한 질문들"></a>스프링에 관한 질문들</h3><p><em>기술 면접을 2주 앞두고 면접에 필요한 내용들을 정리하며 “…질문들” 시리즈를 연재해본다.</em></p><p><strong>스프링의 구조, 요청 / 응답</strong></p><ul><li>스프링은 어떻게 요청을 처리하는가? 요청을 처리하는 순서대로 설명해 보아라. </li></ul><p>면접관님 우선 이렇게 어려운 질문을 해주신 것에 대해 제 자신을 뒤돌아보게 됩니다. 혹시나 제가 채용 과정중 맘 상하게 해드린 부분이 있다면 용서를….</p><p>Spring MVC의 관점에서 설명하겠다. Spring MVC는 <strong>Front Controller 패턴</strong>을 채택하고 있다. </p><p>Front Controller란 웹 애플리케이션의 가장 앞단에 <strong>모든 요청을 받는 서블릿</strong>을 두고 일단 들어온 요청을 개발자가 명시한 바에 따라 분기처리해나가며 요청을 처리하는 방식이다. Spring MVC에서 Front Controller의 역할을 하는 서블릿을 <strong>DispatcherServlet</strong> 이라 칭한다. </p><p>DispatcherServlet은 한개일 수도 있고 <strong>복수개일 수도 있다.</strong> 단 DispatcherServlet을 분할하여 관리할 수 있게 한 것은 Legacy JSP와의 호환을 위해 그렇게 남겨둔 것으로 <strong>한개의 DispatcherServlet이 모든 요청을 받아들인 후 IoC Container에 진입해 분기처리할 수 있는데 굳이 복수개의 서블릿을 운용할 필요는 없다.</strong> </p><p>DispatcherServlet 앞에 Filter라는 것이 있다. Filter는 요청을 말그대로 필터링하면서 HTTP request header 등 정보를 읽어들여 DispatcherServlet에 진입하기 전 필요한 처리를 한다. </p><ul><li><em>꼬리질문: Filter와 Interceptor의 차이는?</em> <ul><li>Filter는 IoC Container에서 관리되는 콩이 아니다. Filter는 DispatcherServlet보다도 앞단에 위치하는 객체로 Spring이 관리하지 않는 객체이므로 Dependency Injection 등의 구현을 할 수 없다. </li><li>그대신 Filter를 Spring Config class에서 등록시키고, 이 때 Autowired된 객체의 참조를 생성자로 전달할 수는 있다. 실제로 이런 구현을 많이 한다. 예를 들어 SecurityConfig.java에서 인증에 필요한 객체들을 bean으로 받아놓은 후 filter에 참조를 넘겨줄 수 있다. </li><li>Interceptor는 스프링이 관리하는 콩이다. </li></ul></li></ul><p>일단 DispatcherServlet에 진입하고 나면 적합한 컨트롤러를 찾아 매핑시켜줘야 한다. 최근의 Spring MVC에서는 AnnotationMethodHandlerAdapter가 사용된다. @RestController나 @Controller로 애노테이션 된 클래스 아래에 있는 @GetMapping, @PostMapping 등 메소드들이 스캔의 대상이 된다. </p><p>HandlerAdapter는 간단한 인터페이스로 handle() 메소드 하나가 전부다. 적합한 컨트롤러를 찾아 HttpServletRequest를 전달하고 응답을 돌려주는 역할을 한다. </p><p>Spring MVC에서 사용할 수 있는 컨트롤러의 타입에는 제한이 없다. 개발자가 마음껏 정의해서 쓸 수 있다. 이를 가능하게 해주는 것이 HandlerAdapter이다. 컨트롤러의 메소드에서 파라메터를 전달받을 수 있다. 이 파라메터를 전달해주는 역할은 ArgumentResolver가 수행한다. </p><p>기본 등록되어있는 ArgumentResolver 이외의 다른 객체를 파라메터로 사용하고 싶다면 custom으로 구현해주면 되겠다. </p><p>HandlerAdapter의 handle() 메소드가 갖는 리턴 타입은 ModelAndView다. HTTP Body에 직접 접근해 응답을 기록하는 @ResponseBody 애노테이션이 붙어있지 않는 이상 모든 컨트롤러는 ModelAndView로 응답을 전달해야 하고, ViewResolver가 그 역할을 수행해준다. 이때 property에 기록된 template suffix 등이 적용된다. </p><p>@ResponseBody나 @RestController의 경우 ModelAndView 타입을 리턴하는 ViewResolver 대신 MessageConverter가 작동한다. MessageConverter는 컨트롤러의 메소드가 리턴한 객체를 전략에 따라 적절한 message로 변환하여 HTTP body에 직접 내용을 기록한다. </p><p>대표적인 것으로 Jackson2HttpMessageConverter.java 가 있다. 이 객체는 컨트롤러가 리턴한 객체를 com.fasterxml.jackson.objectMapper() 의 writeValueAsString() 메소드에 넣고 스트링으로 객체를 변환한 후 해당 스트링을 http body에 기록하게 된다. </p><p>ModelAndView 타입이건 ResponseBody에 대한 응답이건 응답이 기록되게 되면 Spring MVC의 요청 처리 사이클이 완료된 것이다. </p><ul><li><p>*꼬리질문: DispatcherServlet은 IoC Container에 바로 접근해서 Spring bean을 사용할 수 있는가? </p><ul><li>반은 맞고 반은 틀림. IoC Container의 구현체인 Web application context는 root application context와 servlet application context로 구분됨. Servlet Web ApplicationContext는 controller 등 handleradapter와 requesthandler를 위한 Spring Bean만 갖고 있음. Servlet Web ApplicationContext는 복수개일 수 있음. </li><li>Root Web ApplicationContext는 하나의 프로젝트 당 하나임. 복수개로 등록된 Servlet Web ApplicationContext가 하나의 Root Web ApplicationContext를 바라보며 DAO, service 계층의 스프링 빈 등 의존성을 이용해 요청을 처리하는 것임</li><li>DispatcherServlet 한개당 Servlet Web ApplicationContext는 하나여야 함. </li></ul></li></ul><p><strong>Spring IoC Container</strong></p><ul><li>IoC Container라는 언급을 자주 하셨는데 이는 무엇인가? </li></ul><p>IoC Container는 스프링 그 자체다. </p><p>DI Container라고도 하고 이걸 그냥 스프링이라고 부르는 개발자들도 있다. 혹은 Singleton Container라고 불리기도 한다. </p><p>핵심은 <strong>싱글톤 보일러플레이트 없이</strong> 객체들의 싱글톤 상태를 유지시켜주는 것이다. 이를 위해 스프링은 객체들을 직접 생성해 컨테이너 안에서 그 생명주기를 관리하며 싱글톤 상태를 깨지 않는 관리를 하게 된다. </p><p>다른 객체에 대한 의존성 주입이 필요하다면 IoC Container가 직접 주입해준다. 여기서 제어권의 역전이 발생한다. 객체는 특정 객체가 아닌 타입에 의존하면서 실제 구현체에 대해서는 모르는 상태를 유지하는 것이다. </p><p>스프링의 ApplicationContext는 간단한 인터페이스로써 BeanFactory를 상속하고 있다. .getBean() 을 통해 Bean 객체를 요청받으며 만약 싱글톤 레지스트리에서 보관하고 있지 않는 객체인 경우에는 BeanFactory를 통해 새로운 객체를 만들어서 돌려준다. 이 때도 객체는 싱글톤 레지스트리에 등록시키며 앞으로 다른 요청이 있을 경우 싱글톤 레지스트리에서 빼서 갖다준다. 새로운 객체를 두 번 만들지 않는다. </p><ul><li><em>꼬리질문: Spring이 이런 구현을 가져가는 이유는 뭐라고 생각하는가?</em><ul><li>아무리 JVM이 현대화되고 최적화됐지만 객체의 생성은 약간의 오버헤드를 가져오는 일임에는 틀림이 없다. </li><li>접속이 새로 들어와 스레드가 생길 때마다 새로운 서비스 객체, 각종 컴포넌트 객체가 새로 생긴다면 JVM의 객체 생성과 GC 메카니즘에는 상당한 부하가 걸릴 것이다. </li><li>멤버 변수를 가질 필요가 없고 비즈니스 로직을 수행하는 객체라면 Bean으로 관리하는 것을 고려해야 한다. </li></ul></li></ul><p>스프링은 ApplicationContext로 객체를 관리하면서 다양한 부가기능을 구현할 수 있게 도와준다. Spring AOP가 대표적인 사례로 애노테이션을 통해 객체에 부가기능을 추가할 수 있는 것은 결국 Spring의 ApplicationContext가 런타임 시에 객체를 만들어 싱글톤 레지스트리에 등록하는 과정 중에서 프록시 객체의 생성과 같은 객체 내용/역할의 변조가 가능하기 때문이다. </p><ul><li><p><em>꼬리질문: Spring AOP의 작동 원리에 대해 설명해 보아라.</em></p><ul><li>Spring AOP를 가능케 해주는 두 가지 방법, 그리고 크게 세 가지의 Framework support가 있다. </li><li>먼저 Runtime Weaving 부터 살펴보면 JDK Dynamic Proxy와 CGLib이 있다. </li><li>JDK Dynamic Proxy는 decorator 패턴을 따르는 것으로 proxy 객체를 형성해 부가 기능의 구현을 전담시킨 후, 원래 기능의 수행은 원 객체에 위임시키는 구현 방식이다. </li><li>JDK Dynamic Proxy의 proxy 객체에는 .invoke() 메소드가 존재한다. .invoke() 메소드는 InvocationHandler의 구현체에 존재하는 메소드이다. </li><li>JDK Dynamic Proxy는 인터페이스에 대해서만 weaving할 수 있다.</li><li>concrete class에 대한 weaving은 CGLib을 사용한다. CGLib은 원 객체를 상속해 새로운 객체를 구현하는 방법으로 weaving을 실시하고, class와 method에 대한 overriding이 수반되는 방식이다. 따라서 코틀린과 함께 이용할때는 open 예약어를 통해 상속을 오픈시켜줘야 한다. </li><li>AspectJ를 응용한 Compile Time Weaving도 가능하다. AspectJ를 사용하는 경우 Load Time Weaving도 가능하다. </li><li>AspectJ는 실제 바이트 코드에 대한 변조이므로 제약조건이 가장 적고 성능도 가장 좋게 나온다. </li><li>주의해야 할 점: Spring AOP에서 @AspectJ 애노테이션을 사용하는 것은 AspectJ를 통한 compile time weaving을 수행하는 것이 아니다. JDK Dynamic Proxy / CGLib 기반 Runtime weaving 하에서 AspectJ의 <strong>문법만을 갖다 쓰는 것</strong> 에 불과하다. </li></ul></li><li><p><em>꼬리질문2: AOP 기반 Transaction 관리에 대해 설명해 보아라.</em> </p><ul><li>javax.persistence.Transactional 을 붙이면 트랜잭션 부가 기능 프록시 객체가 서비스 클래스에 붙게 된다. </li><li>Transaction을 시작하고 소멸시키는 생명주기가 프록시 객체 안에서 이뤄지게 된다. </li><li>클래스 레벨로 설정할 수도 있고, 메소드 레벨로 설정할 수도 있지만 중요한 사실은 <strong>클래스 내부 호출에 대해서는 의도대로 작동하지 않는다</strong> 는 점이다. </li><li>프록시 객체가 받은 요청에 대해서만 transaction이 사용될 것이다. 즉, public 하게 선언된 메소드를 통해 <strong>작업이 직접 호출되어</strong> 수행된 경우만 프록시 객체가 transaction 관리를 해줄 수 있다. 내부 호출에 대해서는 이미 동작이 원래 객체에 위임된 시점 이후의 일이기 때문에 프록시가 트랜잭션 관리를 해줄 수 없다. </li></ul></li><li><p>ApplicationContext가 객체를 만들고 보관하는 과정에 대해 자세히 설명해보아라. </p></li></ul><p>먼저 ComponentScan 애노테이션에서부터 모든 과정이 시작된다. 부트 환경에서라면 @SpringBootApplication이 그 시작이 되기도 한다. </p><p>스프링은 처음 구동될 때 @Bean, @Component, @Service 등의 애노테이션이 붙어있는, 즉 자기가 관리해야 할 클래스를 모두 스캔한다. 이 때 스캔의 범위는 개발자가 적절하게 부여해줄 수 있다. </p><p>만약 instantiate되어 관리돼야 할 클래스가 다른 빈에 다시 의존하고 있다면 재귀적으로 해당 빈에 대한 instantiation도 수행한다. 이런 식으로 전체 패키지(혹은 개발자가 스캔하라고 지시한 패키지)에 대한 스캔을 수행하며 아무런 의존성도 업는 객체를 발견할때까지 재귀호출을 계속한다. </p><ul><li><p><em>꼬리질문: Spring은 어떻게 자신이 관리할 빈인지 알아보는 것인가?</em></p><ul><li>애노테이션으로 관리된다. 혹은 .xml등 외부 설정 파일을 통해 관리해줄 수도 있다. 중요한 사실은 스프링은 이런 설정 관리를 위해 <strong>특정한 파일 형식이나 표현방법을 강제하진 않는다</strong> 는 점이다. </li><li>클래스에 붙은 애노테이션을 검색하고 해석하기 위해 Reflection를 사용한다. reflection 작업에 대한 최적화를 위해 스프링 개발자는 JVM 튜닝 등 다양한 전략의 도입을 고려할 필요도 있다. </li></ul></li><li><p><em>꼬리질문2: 어떻게 하면 리플렉션을 최적화할 수 있을까?</em></p><ul><li>Reflection이 들여다보는 메모리 영역에 대한 최적화일 것이다. 리플렉션이 들여다보는 정보는 class area에 저장된다. </li><li>JDK 1.7까지 이 영역은 Permanent Generation(이른바 PermGen)에 위치했다. JDK1.8 환경부터 이 영역은 metaspace로 이동했다. </li><li>솔직히 저도 잘 모르겠는데 입사하면 열심히 배우겠다. </li></ul></li><li><p><em>꼬리질문3: 애플리케이션 콘텍스트가 초기화되는 과정 중 일어날 수 있는 문제들은 어떤 게 있는가?</em></p><ul><li>가장 흔한 것으로는 의존해야 할 객체가 없는 경우, 즉 @Autowired를 통해 주입받고자 하는 객체나 설정 정보가 주입되지 않는 경우다. </li><li>properties 파일에 있어야 할 설정 정보가 부재하거나 interface만 선언해 놓고 타입에 의존한 다음 실제 구현체를 만들어주지 않은 경우가 여기에 해당한다. </li><li>두 번째로 흔한 오류는 circular reference 즉 순환 참조의 오류다. 같은 클래스에서 의존하고 있는 두 가지 이상의 객체가 서로에 대해 의존하고 있는 경우 발생한다. </li><li>이 경우 @Bean 이 선언되어 있는 설정 클래스를 분리해주거나 @Primary 애노테이션 등을 통해 instantiation의 우선순위를 바꿔주면 잘 해결된다. </li><li>정말 드문 경우가 있는데 Servlet Web ApplicationContext에 있는 객체에 대해 RootApplicationContext가 관리하는 객체에서 의존하는 경우다. 정말 드문 경우고 최악의 경우라고 볼 수 있다. </li><li>의존성은 위에서 아래로 흐르는 것이 가장 좋다. 의존성 체인의 가장 밑단에 있어야 할 컨트롤러 등 프레젠테이션 레이어의 클래스들은 주입받으면 안된다. </li><li>서비스는 컨트롤러를 주입받을 수 없다. </li></ul></li></ul><p><strong>Spring Security</strong></p><ul><li>핵데이 프로젝트에서 스프링 시큐리티를 사용하셨는데 어떤 흐름으로 인증이 처리되는지 간단히 설명해 보아라. </li></ul><p>인증이 처리되는 과정은 크게 세 파트로 나눌 수 있겠다. 요청 - 인증 - 인가 가 그것이다. </p><p>먼저 요청이 들어오면 DispatcherServlet 앞단에 위치하고 있는 javax.servlet.Filter 구현체들이 요청을 반갑게 맞아줄 것이다. </p><p>RequestMatcher 등을 통해 이 요청이 인증받아야할 요청인지, 혹은 로그인을 위한 요청인지를 판별하게 된다. 이때 필터 객체는 이미 구현되어 있는 스프링 시큐리티 관련 객체들에 대한 참조를 갖고 있는 상황이다. </p><p>일단 필터가 요청에 대한 인증이 필요하다고 판단하면 AuthenticationManager를 호출하여 인증 절차를 시작한다. 이 때 요청을 그대로 매니저로 넘기는 것은 아니고 요청에 필요한 정보만 쏙 빼서 Authentication 클래스의 서브클래스들 (대표적인 것으로, UsernamePasswordAuthenticationToken)에 정보를 담아 매니저로 보내야 한다. </p><p>AuthenticationManager는 별거 아니고 거대한 주머니에 불과하다. AuthenticationProvider를 들고 있는 주머니이다. .authenticate() 메소드를 통해 인증 요청이 접수되면 AuthenticationManager는 자기의 주머니에 담겨있는 AuthenticationProvider를 하나 하나 훑어보며 어떤 공급자가 이 요청을 잘 처리해줄 수 있을지를 고민한다. </p><p>이제 역할을 AuthenticationProvider에게 넘어왔다. 매니저가 문을 두드리며 “이 요청 네 것 맞니?” 라고 물어볼때 자신의 요청이다싶으면 true를 반환하고, 인증을 수행하기 시작한다. </p><p>모든 인증정보가 명확해 인증해줘도 되겠다는 판단이 들면 AuthenticationProvider는 마찬가지로 Authentication의 서브클래스인 인증 객체를 리턴한다.</p><p>리턴할 인증 정보는 Authentication의 서브클래스라면 무엇이든 좋지만 UserDetails 인터페이스의 구현체들이 애용된다. Spring Security는 기본 구현체로 org.springframework.security.core.User 클래스를 제공한다. 이 때 User 정보를 만들기 위해 UserDetailsService 인터페이스를 구현하는 경우도 있다. </p><p>모든 인증 절차가 성공적이었다면 filter가 그 결과를 돌려받는다. .successfulAuthentication() 메소드가 호출되는데 이 때 인증 정보를 기억시켜줘야 같은 스레드 내에서 요청 정보가 공유될 수 있다. 새로운 SecurityContext를 만들고 SecurityContextHolder에 집어넣어 보관한다. S..Holder는 ThreadLocal 객체를 통해 인증 정보를 관리하기때문에 같은 요청에 대해서는 계속 인증 정보가 보관된다. </p><ul><li><p>하나의 요청이 두 개 이상의 스레드를 만드는 경우 애노테이션을 통해 인증정보 관리 전략을 갈아끼울 수 있다. </p><ul><li><p><em>꼬리질문: 왜 스프링은 프로바이더를 통해 인증 과정을 관리하는가?</em></p><ul><li>스프링이 지향하는 핵심 가치 중 하나는 <strong>확장성</strong> 과 <strong>customizable 함(?)</strong> 이라고 생각한다. </li><li>개발자의 의도에 따라 얼마든지 인증 과정을 추가할 수도, 혹은 변경할 수도 있어야 한다. </li><li>같은 웹 애플리케이션 콘텍스트 안에서 여러가지의 인증방법을 가져가야 할 수도 있다. 예를 들어 단순한 로그인 창을 통한 로그인 요청이라면 UsernamePasswordAuthenticationToken 을 사용하고 UserDetailsService에 의존하는 인증 프로바이더로 충분하지만, 저의 프로젝트와 같이 JWT라도 도입할라 치면 만약 이렇게 확장성없는 구조로 구현됐다면 일일이 하드 코딩을 통해 변경 내용을 도입했어야 할 것이다. </li></ul></li><li><p><em>꼬리질문: 인증 전, 후 를 가르는 기준은?</em></p><ul><li>스프링은 “완전한 정보를 갖고 있는 인증 객체(fully-populated authentication principal)”라면 인증 절차가 끝난 객체로 본다. </li><li>완전한 정보를 가르는 기준은 대부분의 경우에 권한을 들고 있는지, 아닌지로 구분된다. </li><li>일테면 UsernamePasswordAuthenticationToken의 경우 두 가지의 생성자를 갖고 있다. 하나는 유저네임과 비번만을 파람으로 받지만 두 번째의 경우 GrantedAuthority의 서브클래스를 가진 컬렉션을 추가로 전달해야 한다. </li><li><code>Collection&lt;? extends GrantedAuthority&gt;</code>를 들고 있는 인증 객체는 .isAuthenticated() 메소드에서 true를 리턴할 것이다. </li></ul></li></ul></li></ul><ul><li>PreAuthorize, PostAuthorize는 뭔가? global method security 라는 놈도 붙어있던데…. <ul><li>AOP기반 인증 처리기다. </li><li>Controller의 메소드에 이 애노테이션이 달려있으면 AOP를 통한 부가기능 추가 메카니즘으로 인증 로직을 스프링이 자동으로 구현해준다. </li><li>PreAuthorize는 <strong>메소드 진입 전</strong> 인증 정보를 평가하고 진입을 통제한다, PostAuthorize는 그 반대다. </li><li>SecurityContextHolder가 관리하는 SecurityContext, 그 속의 Authentication Principal을 통해 권한 정보를 fetch 하고 이 메소드에 접근 인가된 사용자인지를 알아본다. </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;스프링에-관한-질문들&quot;&gt;&lt;a href=&quot;#스프링에-관한-질문들&quot; class=&quot;headerlink&quot; title=&quot;스프링에 관한 질문들&quot;&gt;&lt;/a&gt;스프링에 관한 질문들&lt;/h3&gt;&lt;p&gt;&lt;em&gt;기술 면접을 2주 앞두고 면접에 필요한 내용들을 정리하
      
    
    </summary>
    
      <category term="java" scheme="https://tech.wheejuni.com/categories/java/"/>
    
      <category term="spring" scheme="https://tech.wheejuni.com/categories/java/spring/"/>
    
    
  </entry>
  
</feed>
